(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{936:function(t,s,a){"use strict";a.r(s);var n=a(3),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),s("p",[t._v("​        装饰器是一种语法结构，用来在定义时修改类的行为。")]),t._v(" "),s("p",[t._v("​        在语法上，装饰器有如下几个特征。")]),t._v(" "),s("ul",[s("li",[t._v("第一个字符（或者说前缀）是@，后面是一个表达式。")]),t._v(" "),s("li",[t._v("@后面的表达式，必须是一个函数（或者执行后可以得到一个函数）。")]),t._v(" "),s("li",[t._v("这个函数接受所修饰对象的一些相关值作为参数。")]),t._v(" "),s("li",[t._v("这个函数要么不返回值，要么返回一个新对象取代所修饰的目标对象。")])]),t._v(" "),s("div",{staticClass:"language-typescript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-typescript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 装饰器有多种形式，基本上只要在@符号后面添加表达式都是可以的")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunc")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFuncFactory")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("libraryModule")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prop\n"),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("someObj")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n@"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("wrap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dict"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'prop'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("​        相比使用子类改变父类，装饰器更加简洁优雅，缺点是不那么直观，功能也受到一些限制。所以，装饰器一般只用来为类添加某种特定行为。")]),t._v(" "),s("div",{staticClass:"language-typescript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-typescript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("frozen")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一个用在类本身")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("configurable")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//三个用在类的方法")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("enumerable")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token decorator"}},[s("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("throttle")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expensiveMethod")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h2",{attrs:{id:"装饰器的版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器的版本"}},[t._v("#")]),t._v(" 装饰器的版本")]),t._v(" "),s("p",[t._v("​        标准语法可以直接使用，传统语法需要打开--experimentalDecorators编译参数。")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("tsc "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--target")]),t._v(" ES5 "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--experimentalDecorators")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h2",{attrs:{id:"装饰器的结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器的结构"}},[t._v("#")]),t._v(" 装饰器的结构")]),t._v(" "),s("p",[t._v("​        Decorator是装饰器的类型定义。它是一个函数，使用时会接收到value和context两个参数。")]),t._v(" "),s("ul",[s("li",[t._v("value：所装饰的对象。")]),t._v(" "),s("li",[t._v("context：上下文对象，TS提供一个原生接口ClassMethodDecoratorContext，描述这个对象。\n"),s("ul",[s("li",[t._v("context对象的属性，根据所装饰对象的不同而不同，其中只有两个属性（kind和name）是必有的，其他都是可选的。\n"),s("ul",[s("li",[t._v("kind：字符串，表示所装饰对象的类型。")]),t._v(" "),s("li",[t._v("name：字符串或者 Symbol 值，所装饰对象的名字，比如类名、属性名等。")]),t._v(" "),s("li",[t._v("addInitializer()：函数，用来添加类的初始化逻辑。在类完全定义结束后执行。")]),t._v(" "),s("li",[t._v("private：布尔值，表示所装饰的对象是否为类的私有成员。")]),t._v(" "),s("li",[t._v("static：布尔值，表示所装饰的对象是否为类的静态成员。")]),t._v(" "),s("li",[t._v("access：一个对象，包含了某个值的 get 和 set 方法。")])])])])])]),t._v(" "),s("h2",{attrs:{id:"类装饰器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类装饰器"}},[t._v("#")]),t._v(" 类装饰器")]),t._v(" "),s("p",[t._v("​        类装饰器接受两个参数：value（当前类本身）和context（上下文对象）。其中，context对象的kind属性固定为字符串class。")]),t._v(" "),s("p",[t._v("​        类装饰器一般用来对类进行操作，可以不返回任何值。")]),t._v(" "),s("p",[t._v("​        类装饰器可以返回一个函数，替代当前类的构造方法。")]),t._v(" "),s("p",[t._v("​        类装饰器也可以返回一个新的类，替代原来所装饰的类。")]),t._v(" "),s("h2",{attrs:{id:"方法装饰器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法装饰器"}},[t._v("#")]),t._v(" 方法装饰器")]),t._v(" "),s("p",[t._v("​        方法装饰器用来装饰类的方法（method）。方法装饰器会改写类的原始方法(.prototype上的)。")]),t._v(" "),s("p",[t._v("​        方法装饰器是一个函数，接受两个参数：value和context。参数value是方法本身，参数context是上下文对象，有以下属性。")]),t._v(" "),s("ul",[s("li",[t._v("kind：值固定为字符串method，表示当前为方法装饰器。")]),t._v(" "),s("li",[t._v("name：所装饰的方法名，类型为字符串或 Symbol 值。")]),t._v(" "),s("li",[t._v("static：布尔值，表示是否为静态方法。该属性为只读属性。")]),t._v(" "),s("li",[t._v("private：布尔值，表示是否为私有方法。该属性为只读属性。")]),t._v(" "),s("li",[t._v("access：对象，包含了方法的存取器，但是只有get()方法用来取值，没有set()方法进行赋值。")]),t._v(" "),s("li",[t._v("addInitializer()：为方法增加初始化函数。一个钩子方法，用来在类的初始化阶段添加回调函数。")])]),t._v(" "),s("p",[t._v("​        如果方法装饰器返回一个新的函数，就会替代所装饰的原始函数。")]),t._v(" "),s("p",[t._v("​        利用方法装饰器，可以将类的方法变成延迟执行。")]),t._v(" "),s("h2",{attrs:{id:"属性装饰器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#属性装饰器"}},[t._v("#")]),t._v(" 属性装饰器")]),t._v(" "),s("p",[t._v("​        属性装饰器用来装饰定义在类顶部的属性（field）。")]),t._v(" "),s("blockquote",[s("p",[t._v("注意，装饰器的第一个参数value的类型是undefined，这意味着这个参数实际上没用的，装饰器不能从value获取所装饰属性的值。另外，第二个参数context对象的kind属性的值为字符串field，而不是“property”或“attribute”，这一点是需要注意的。")])]),t._v(" "),s("p",[t._v("​       属性装饰器要么不返回值，要么返回一个函数，该函数会自动执行，用来对所装饰属性进行初始化。该函数的参数是所装饰属性的初始值，该函数的返回值是该属性的最终值。")]),t._v(" "),s("p",[t._v("​        属性装饰器的返回值函数，可以用来更改属性的初始值。")]),t._v(" "),s("p",[t._v("​        属性装饰器的上下文对象context的access属性，提供所装饰属性的存取器。")]),t._v(" "),s("h2",{attrs:{id:"getter-装饰器-setter-装饰器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getter-装饰器-setter-装饰器"}},[t._v("#")]),t._v(" getter 装饰器，setter 装饰器")]),t._v(" "),s("p",[t._v("​        属性装饰器的上下文对象context的access属性，提供所装饰属性的存取器。")]),t._v(" "),s("blockquote",[s("p",[t._v("注意，getter 装饰器的上下文对象context的access属性，只包含get()方法；setter 装饰器的access属性，只包含set()方法。")])]),t._v(" "),s("p",[t._v("​        这两个装饰器要么不返回值，要么返回一个函数，取代原来的取值器或存值器。")]),t._v(" "),s("h2",{attrs:{id:"accessor-装饰器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#accessor-装饰器"}},[t._v("#")]),t._v(" accessor 装饰器")]),t._v(" "),s("div",{staticClass:"language-typescript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-typescript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  accessor x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// accessor等同于为公开属性x自动生成取值器和存值器，它们作用于私有属性x")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//公开的x与私有的x不是同一个。也就是说，上面的代码等同于下面的代码。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("C")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  #x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("#x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("#x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[t._v("​        accessor也可以与静态属性和私有属性一起使用。")]),t._v(" "),s("p",[t._v("​        accessor 装饰器的value参数，是一个包含get()方法和set()方法的对象。")]),t._v(" "),s("p",[t._v("​        该装饰器可以不返回值，或者返回一个新的对象，用来取代原来的get()方法和set()方法。")]),t._v(" "),s("p",[t._v("​        此外，装饰器返回的对象还可以包括一个init()方法，用来改变私有属性的初始值。")]),t._v(" "),s("h2",{attrs:{id:"装饰器的执行顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器的执行顺序"}},[t._v("#")]),t._v(" 装饰器的执行顺序")]),t._v(" "),s("p",[t._v("​        装饰器的执行分为两个阶段。")]),t._v(" "),s("ul",[s("li",[t._v("评估（evaluation）：计算@符号后面的表达式的值，得到的应该是函数。")]),t._v(" "),s("li",[t._v("应用（application）：将评估装饰器后得到的函数，应用于所装饰对象。")])]),t._v(" "),s("p",[t._v("​        也就是说，装饰器的执行顺序是，先评估所有装饰器表达式的值，再将其应用于当前类。")]),t._v(" "),s("p",[t._v("​        应用装饰器时，顺序依次为方法装饰器和属性装饰器，然后是类装饰器。如果一个方法或属性有多个装饰器，则内层的装饰器先执行，外层的装饰器后执行。")]),t._v(" "),s("h1",{attrs:{id:"装饰器-旧语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装饰器-旧语法"}},[t._v("#")]),t._v(" 装饰器(旧语法)")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://wangdoc.com/typescript/decorator-legacy",target:"_blank",rel:"noopener noreferrer"}},[t._v("装饰器（旧语法） - TypeScript 教程 - 网道 (wangdoc.com)"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);