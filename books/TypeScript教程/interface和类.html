<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>interface和类 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.f272a1d3.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.464cc3ea.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.db1c35d8.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.88465532.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/112.8496b045.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.b772a431.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.d2694f57.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.363ac90d.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.017aee18.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.1ee0dad1.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.f060d1ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.fe797c66.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.c7bd9e89.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.a84dc19a.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.391e1a8e.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.c989d9a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.d29dfabd.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.ad8e18e6.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.ab00fb51.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.9877a9b7.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.c6596a91.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.21d6e151.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.2c54009e.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.132ddfcb.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.4003c3b3.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.77effa46.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.3443776e.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.25492e11.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.14d2c67b.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.e7878cf4.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.301cccf5.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.11ab1cfc.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.bd542041.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.0ca8509f.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.c008e4de.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.f066530f.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.ff75154e.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.f6acb1a1.js"><link rel="prefetch" href="/vivien-blog/assets/js/132.0a4d8821.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.66e315c3.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.cc0056df.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.ce2dec2d.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.099aee64.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.703953fd.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.2c60b621.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.9d0ff547.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.06b34afc.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.362f0a63.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.aea2c93b.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.ba303bf2.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.a0db7cbe.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.d71bb6eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.d4cf7feb.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.f85f9cdc.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.af1829bd.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.542b86e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.0913fb27.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e55f1610.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.2fd2d217.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.0d01bb51.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.18330ce2.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.f63999dd.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.dc50e9aa.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.09c49d82.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.5cd0ff12.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.1380315b.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.9a8bc83a.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.dfc3dc84.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.9f0491a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.56c7442b.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.572118ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.a2889e9a.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.94b92181.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.1f624d36.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.4c5ccd6c.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.b26a90b4.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.7e99ec91.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.f38ecb23.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.a7eaecbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.40c7032a.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.8e17d480.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.1d10e785.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.f7a1d218.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.d0d1c459.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.cd29a7fb.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.6c524010.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.71c0d7e3.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.3e2ceae4.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.16f48649.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.54c9caee.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.932acfca.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.a26eda75.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.d4fcb8e2.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.49f89693.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.ff5755c4.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f99c6d3c.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.72422da4.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.31dada36.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.d8b153a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.65b735d3.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.4a1f3b55.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.0deae352.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.1b20365f.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.b1ad1f90.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.c9cb2e95.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.eafe982f.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.c05b267e.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.85b693c3.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6fe5ff10.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.03ddba74.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.6d7da126.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.4f0d306e.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.c6a69e36.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.2ecafbc8.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.e2bdc300.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.7b088a51.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.3c6883a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.7e923a1d.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.b80a80de.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.400ff4ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.e5c8d0d5.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.043b10e7.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.0c10e4a4.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.0b6d56b6.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.e522ef3c.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.3d16361d.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.3ac0aa11.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.1023cffa.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.a6b38371.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.cee5c33c.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.50ffeb12.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#849b87;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>TypeScript教程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/TypeScript教程/简介和基本用法.html" class="sidebar-link">简介和基本用法</a></li><li><a href="/vivien-blog/books/TypeScript教程/类型系统.html" class="sidebar-link">类型系统</a></li><li><a href="/vivien-blog/books/TypeScript教程/数组和元组.html" class="sidebar-link">数组和元组</a></li><li><a href="/vivien-blog/books/TypeScript教程/symbol类型和对象.html" class="sidebar-link">symbol类型和对象</a></li><li><a href="/vivien-blog/books/TypeScript教程/函数.html" class="sidebar-link">函数</a></li><li><a href="/vivien-blog/books/TypeScript教程/interface和类.html" class="active sidebar-link">interface和类</a></li><li><a href="/vivien-blog/books/TypeScript教程/泛型和类型断言.html" class="sidebar-link">泛型和类型断言</a></li><li><a href="/vivien-blog/books/TypeScript教程/Enum、namespace和模块.html" class="sidebar-link">Enum、namespace和模块</a></li><li><a href="/vivien-blog/books/TypeScript教程/装饰器.html" class="sidebar-link">装饰器</a></li><li><a href="/vivien-blog/books/TypeScript教程/declare关键字.html" class="sidebar-link">declare关键字</a></li><li><a href="/vivien-blog/books/TypeScript教程/类型运算符和类型映射.html" class="sidebar-link">类型运算符和类型映射</a></li><li><a href="/vivien-blog/books/TypeScript教程/其它.html" class="sidebar-link">其它</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue.js设计与实现</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>interface和类</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">interface和类</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/4/8</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>TypeScript</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="interface"><a href="#interface" class="header-anchor">#</a> interface</h2> <p>​        interface是对象的模板，可以看作是一种类型约定，中文译为接口。使用了某个模板的对象，就拥有了指定的类型结构。方括号运算符可以取出interface某个属性的类型。</p> <blockquote><p>赋值时，变量的形状必须和接口的形状保持一致。定义的变量比接口少一些属性、多一些属性都是不允许的。</p></blockquote> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  lastName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型</span>
<span class="token keyword">const</span> p<span class="token operator">:</span>Person <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">// 变量p的类型就是接口Person，所以必须符合Person指定的结构</span>
  firstName<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>
  lastName<span class="token operator">:</span> <span class="token string">'Smith'</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">25</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 实现该接口很简单，只要指定它作为对象的类型即可</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> Person<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​        interface可以表示对象的各种语法，它的成员有5种形式：</p> <ul><li>对象属性
<ul><li>分别使用冒号指定每个属性的类型。</li> <li>属性之间使用分号或逗号分隔，最后一个属性结尾的分号或逗号可以省略。</li> <li>如果属性是可选的，就在属性名后面加一个问号。</li> <li>如果属性是只读的，需要加上readonly修饰符。</li></ul></li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">readonly</span> y<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>对象的属性索引
<ul><li>属性索引共有string、number和symbol三种类型。</li> <li>一个接口中最多只能定义一个字符串索引。字符串索引会约束该类型中所有名字为字符串的属性。</li> <li>属性的数值索引，其实是指定数组的类型。</li> <li>一个接口中最多只能定义一个数值索引。数值索引会约束所有名称为数值的属性。</li> <li>如果一个interface同时定义了字符串索引和数值索引，那么数值索引必须服从于字符串索引。因为在JavaScript中，数值属性名最终是自动转换成字符串属性名。</li></ul></li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>prop<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj<span class="token operator">:</span><span class="token constant">C</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 属性名的类型是数值，所以可以用数组对变量obj赋值</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>prop<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> <span class="token comment">// 报错。数值索引的属性值类型与字符串索引不一致，就会报错</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>prop<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 正确。数值索引必须兼容字符串索引的类型声明</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li>对象方法
<ul><li>对象的方法共有三种写法。属性名可以采用表达式。</li> <li>类型方法可以重载。interface里面的函数重载不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。</li></ul></li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 写法一</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 写法二</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span>
  <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 写法三</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  f<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 属性名可以采用表达式，所以下面的写法也是可以的。</span>
<span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token string">'f'</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 函数重载，不需要给出实现，需要额外在对象外部给出函数方法的实现</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ul><li>函数
<ul><li>interface 也可以用来声明独立的函数。</li></ul></li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Add</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 声明了一个函数类型</span>
<span class="token keyword">const</span> myAdd<span class="token operator">:</span><span class="token function-variable function">Add</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>构造函数
<ul><li>interface 内部可以使用new关键字，表示构造函数。</li></ul></li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">ErrorConstructor</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> Error<span class="token punctuation">;</span> <span class="token comment">// 内部有new命令，表示它是一个构造函数</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>有时我们希望一个接口允许有任意的属性，可以使用如下方式。</li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token comment">// 使用 [propName: string] 定义了任意属性取 string 类型的值。</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span>
<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>propName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 如果接口中有多个类型的属性，则可以在任意属性中使用联合类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="interface-的继承"><a href="#interface-的继承" class="header-anchor">#</a> interface 的继承</h2> <h3 id="interface-继承-interface"><a href="#interface-继承-interface" class="header-anchor">#</a> interface 继承 interface</h3> <p>​        interface可以使用extends关键字，继承其他interface。extends关键字会从继承的接口里面拷贝属性类型。这样就不必书写重复的属性。</p> <p>​        interface 允许多重继承。多重接口继承，实际上相当于多个父接口的合并。多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Style</span> <span class="token punctuation">{</span>
  color<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token keyword">extends</span> <span class="token class-name">Style</span><span class="token punctuation">,</span> Shape <span class="token punctuation">{</span>
  radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// Circle同时继承了Style和Shape，所以拥有三个属性color、name和radius</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​        如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 报错</span>
<span class="token keyword">interface</span> <span class="token class-name">Baz</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span><span class="token punctuation">,</span> Bar <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// Baz同时继承了Foo和Bar，但是后两者的同名属性id有类型冲突</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="interface-继承-type"><a href="#interface-继承-type" class="header-anchor">#</a> interface 继承 type</h3> <p>​        interface可以继承type命令定义的对象类型。如果type命令定义的类型不是对象，interface就无法继承。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Country</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  capital<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">CountryWithPop</span> <span class="token keyword">extends</span> <span class="token class-name">Country</span> <span class="token punctuation">{</span>
  population<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// CountryWithPop继承了type命令定义的Country对象，并且新增了一个population属性</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="interface-继承-class"><a href="#interface-继承-class" class="header-anchor">#</a> interface 继承 class</h3> <p>​        interface还可以继承class，即继承该类的所有成员。某些类拥有私有成员和保护成员，interface可以继承这样的类，但无法用于对象，意义不大。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span> <span class="token comment">// A有私有成员和保护成员</span>
  <span class="token keyword">private</span> x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token keyword">protected</span> y<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span> <span class="token comment">// B继承了A，但无法用于对象，因为对象不能实现这些成员</span>
  z<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>
<span class="token comment">// 报错</span>
<span class="token keyword">const</span> b<span class="token operator">:</span><span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token comment">// 报错</span>
<span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token punctuation">{</span> <span class="token comment">//致B只能用于其他class</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token comment">// 这时其他class与A之间不构成父类和子类的关系，使得x与y无法部署</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="接口合并"><a href="#接口合并" class="header-anchor">#</a> 接口合并</h2> <p>​        多个同名接口会合并成一个接口。JavaScript开发者常常对全局对象或者外部库，添加自己的属性和方法。只要使用interface给出这些自定义属性和方法的类型，就能自动跟原始的interface合并，使得扩展外部类型非常方便。</p> <p>​        同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。</p> <p>​        同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。但是，如果有一个参数是字面量类型，字面量类型的优先级会排到最前面。</p> <p>​        如果两个interface组成的联合类型存在同名属性，那么该属性的类型也是联合类型。</p> <blockquote><p>接口的合并：接口中的属性在合并时会简单的合并到一个接口中，并的属性的类型必须是唯一的。</p></blockquote> <h2 id="interface-与-type-的异同"><a href="#interface-与-type-的异同" class="header-anchor">#</a> interface 与 type 的异同</h2> <p>​       interface命令与type命令作用类似，都可以表示对象类型。很多对象类型既可用interface表示，也可用type表示。而且，两者往往可以换用，几乎所有的 interface 命令都可以改写为 type 命令。</p> <p>​        它们的相似之处，表现在都能为对象类型起名。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Country</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  capital<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Country</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  capital<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>class命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用type或interface。</p></blockquote> <p>​     interface 与 type 的区别有下面几点：</p> <ul><li>type能够表示非对象类型，而interface只能表示对象类型（包括数组、函数等）。</li> <li>interface可以继承其他类型，type不支持继承。
<ul><li>继承的主要作用是添加属性，type定义的对象类型如果想要添加属性，只能使用&amp;运算符，重新定义一个类型。(&amp;运算符表示同时具备两个类型的特征，可以起到两个对象类型合并的作用。)</li> <li>interface添加属性，采用的是继承的写法。继承时，type 和 interface 是可以换用的。interface 可以继承 type。type 也可以继承 interface。</li></ul></li> <li>同名interface会自动合并，同名type则会报错。即TS不允许使用type多次定义同一个类型。</li> <li>interface不能包含属性映射（mapping），type可以。</li> <li>this关键字只能用于interface。</li> <li>type可以扩展原始数据类型，interface 不行。</li> <li>interface无法表达某些复杂类型（比如交叉类型和联合类型），但是type可以。</li></ul> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span> <span class="token comment">// interface 可以继承 type</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> <span class="token class-name">Bar</span> <span class="token operator">=</span> Foo <span class="token operator">&amp;</span> <span class="token punctuation">{</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// type 也可以继承 interface</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>如果有复杂的类型运算，那么没有其他选择只能使用type；一般情况下，interface灵活性比较高，便于扩充类型或自动合并，建议优先使用。</p></blockquote> <h2 id="类"><a href="#类" class="header-anchor">#</a> 类</h2> <p>​        类是面向对象编程的基本构件，封装了属性和方法，TypeScript 给予了全面支持。</p> <blockquote><p>​        这里对类相关的概念做一个简单的介绍。
类（Class）：定义了一件事物的抽象特点，包含它的属性和方法
对象（Object）：类的实例，通过 new 生成
面向对象（OOP）的三大特性：封装、继承、多态
封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要(也不可能)知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据
继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性
多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat
存取器（getter &amp; setter）：用以改变属性的读取和赋值行为
修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法
抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</p></blockquote> <h3 id="属性的类型"><a href="#属性的类型" class="header-anchor">#</a> 属性的类型</h3> <p>​        类的属性可以在顶层声明，也可以在构造方法内部声明。对于顶层声明的属性，可以在声明时同时给出类型。</p> <p>​        如果不给出类型，TypeScript 会认为是any。如果声明时给出初值，可以不写类型，TypeScript 会自行推断属性的类型。</p> <p>​        TypeScript 有一个配置项strictPropertyInitialization，只要打开（默认是打开的），就会检查属性是否设置了初值，如果没有就报错。</p> <p>​        如果类的顶层属性不赋值，就会报错。如果不希望出现报错，可以使用非空断言。就是说，在属性名后面添加感叹号，表示这两个属性肯定不会为空，TypeScript就不报错了。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 打开 strictPropertyInitialization</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="readonly-修饰符"><a href="#readonly-修饰符" class="header-anchor">#</a> readonly 修饰符</h3> <p>​        属性名前面加上readonly修饰符，就表示该属性是只读的。实例对象不能修改这个属性。</p> <p>​        readonly 属性的初始值，可以写在顶层属性，也可以写在构造方法里面。</p> <p>​        构造方法内部设置只读属性的初值、修改只读属性的值，都是可以的。或者说，如果两个地方都设置了只读属性的值，以构造方法为准。在其他方法修改只读属性都会报错。</p> <p>​        如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。</p> <blockquote><p>修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。readonly只允许出现在属性声明或索引签名或构造函数中。</p></blockquote> <h3 id="方法的类型"><a href="#方法的类型" class="header-anchor">#</a> 方法的类型</h3> <p>​        类的方法就是普通函数，类型声明方式与函数一致。</p> <p>​        类的方法跟普通函数一样，可以使用参数默认值，以及函数重载。</p> <p>​        构造方法可以接受一个参数，也可以接受两个参数，采用函数重载进行类型声明。另外，构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。</p> <h3 id="存取器方法"><a href="#存取器方法" class="header-anchor">#</a> 存取器方法</h3> <p>​        存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name"><span class="token constant">C</span></span> <span class="token punctuation">{</span>
  _name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 取值器，其中get是关键词，name是属性名</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token comment">// 外部读取name属性时，实例对象会自动调用这个方法，该方法的返回值就是name属性的值</span>
  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 存值器，其中set是关键词，name是属性名</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token comment">// 外部写入name属性时，实例对象会自动调用这个方法，并将所赋的值作为函数参数传入</span>
<span class="token punctuation">}</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​        TypeScript 对存取器有以下规则。</p> <ul><li>如果某个属性只有get方法，没有set方法，那么该属性自动成为只读属性。</li> <li>TS 5.1版之前，set方法的参数类型，必须兼容get方法的返回值类型，否则报错。TS5.1 版做出了改变，现在两者可以不兼容。</li> <li>get方法与set方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。</li></ul> <h3 id="属性索引"><a href="#属性索引" class="header-anchor">#</a> 属性索引</h3> <p>​        类允许定义属性索引。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>s<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//所有属性名类型为字符串的属性，属性值要么是布尔值，要么是返回布尔值的函数</span>
  <span class="token function">get</span><span class="token punctuation">(</span>s<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​        注意，由于类的方法是一种特殊属性(属性值为函数的属性)，所以属性索引的类型定义也涵盖了方法。如果一个对象同时定义了属性索引和方法，那么前者必须包含后者的类型。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>s<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​        属性存取器视同属性。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>s<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span> <span class="token comment">// 属性索引虽然没有涉及方法类型，但是不会报错</span>
  <span class="token keyword">get</span> <span class="token function">isInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 读取器虽然是一个函数方法，但是视同属性</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="类的-interface-接口"><a href="#类的-interface-接口" class="header-anchor">#</a> 类的 interface 接口</h2> <p>​        有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口，用 implements 关键字来实现。</p> <h3 id="implements-关键字"><a href="#implements-关键字" class="header-anchor">#</a> implements 关键字</h3> <p>​        interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。</p> <p>​       interface只是指定检查条件，如果不满足这些条件就会报错。它并不能代替class自身的类型声明。比如，类B实现了接口A，但A并不能代替B的类型声明，B类依然需要声明参数的类型，需要声明可选属性。</p> <p>​        类可以定义接口没有声明的方法和属性。表示除了满足接口给出的条件，类还有额外的条件。</p> <p>​        implements关键字后面，不仅可以是接口，也可以是另一个类。这时，后面的类将被当作接口。在接口继承类的时候，也只会继承它的实例属性和实例方法。</p> <p>​        注意，interface描述的是类的对外接口，也就是实例的公开属性和公开方法，不能定义私有的属性和方法。这是因为TypeScript设计者认为，私有属性是类的内部实现，接口作为模板，不应该涉及类的内部代码写法。</p> <h3 id="实现多个接口"><a href="#实现多个接口" class="header-anchor">#</a> 实现多个接口</h3> <p>​        一个类可以实现多个接口(其实是接受多重限制)，每个接口之间使用逗号分隔。但是，同时实现多个接口并不是一个好的写法，容易使得代码难以管理，可以使用两种方法替代。第一种方法是类的继承。第二种方法是接口的继承。在 TypeScript 中，接口与接口之间可以是继承关系。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">implements</span> <span class="token class-name">MotorVehicle</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SecretCar</span> <span class="token keyword">extends</span> <span class="token class-name">Car</span> <span class="token keyword">implements</span> <span class="token class-name">Flyable</span><span class="token punctuation">,</span> Swimmable <span class="token punctuation">{</span> <span class="token comment">// 类的继承</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span> <span class="token comment">// 接口的继承</span>
  b<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​       注意，发生多重实现时（即一个接口同时实现多个接口），不同接口不能有互相冲突的属性。</p> <h3 id="类与接口的合并"><a href="#类与接口的合并" class="header-anchor">#</a> 类与接口的合并</h3> <p>​      TypeScript不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。注意，合并进类的非空属性，如果在赋值之前读取，会返回undefined。</p> <blockquote><p>类的合并：类的合并与接口的合并规则一致。</p></blockquote> <h2 id="class-类型"><a href="#class-类型" class="header-anchor">#</a> Class 类型</h2> <h3 id="实例类型"><a href="#实例类型" class="header-anchor">#</a> 实例类型</h3> <p>​        TypeScript的类本身就是一种类型，但是它代表该类的实例类型，而不是class的自身类型。</p> <p>​        对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">MotorVehicle</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">implements</span> <span class="token class-name">MotorVehicle</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token comment">// 写法一</span>
<span class="token keyword">const</span> c1<span class="token operator">:</span>Car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 写法二</span>
<span class="token keyword">const</span> c2<span class="token operator">:</span>MotorVehicle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​        作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。</p> <p>​        由于类名作为类型使用，实际上代表一个对象，因此可以把类看作为对象类型起名。事实上，TypeScript有三种方法可以为对象类型起名：type、interface 和 class。</p> <h3 id="类的自身类型"><a href="#类的自身类型" class="header-anchor">#</a> 类的自身类型</h3> <p>​        类的自身类型就是一个构造函数，可以单独定义一个接口来表示。要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。</p> <p>​        类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。构造函数也可以写成对象形式。</p> <p>​        可以把构造函数提取出来，单独定义一个接口，这样可以大大提高代码的通用性。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">PointConstructor</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span><span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span>Point<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">createPoint</span><span class="token punctuation">(</span>
  PointClass<span class="token operator">:</span> PointConstructor<span class="token punctuation">,</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">)</span><span class="token operator">:</span>Point <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PointClass</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="结构类型原则"><a href="#结构类型原则" class="header-anchor">#</a> 结构类型原则</h3> <p>​        Class也遵循结构类型原则。一个对象只要满足 Class 的实例结构，就跟该 Class 属于同一个类型。</p> <p>​        如果两个类的实例结构相同，那么这两个类就是兼容的，可以用在对方的使用场合。</p> <p>​        只要 A 类具有 B 类的结构，哪怕还有额外的属性和方法，TypeScript也认为 A 兼容 B 的类型。</p> <p>​        不仅是类，如果某个对象跟某个 class 的实例结构相同，TypeScript也认为两者的类型相同。由于这种情况，运算符instanceof不适用于判断某个对象是否跟某个 class 属于同一类型。</p> <p>​        空类不包含任何成员，任何其他类都可以看作与空类结构相同。因此，凡是类型为空类的地方，所有类（包括对象）都可以使用。</p> <p>​        注意，确定两个类的兼容关系时，只检查实例成员，不考虑静态成员和构造方法。</p> <p>​        如果类中存在私有成员（private）或保护成员（protected），那么确定兼容关系时，TypeScript 要求私有成员和保护成员来自同一个类，这意味着两个类需要存在继承关系。</p> <h2 id="类的继承"><a href="#类的继承" class="header-anchor">#</a> 类的继承</h2> <p>​        类(这里又称子类)可以使用extends关键字继承另一个类(这里又称基类)的所有属性和方法。一般来讲，一个类只能继承自另一个类。</p> <p>​        根据结构类型原则，子类也可以用于类型为基类的场合。子类可以覆盖基类的同名方法。</p> <p>​        使用super关键字指代基类是常见做法。</p> <p>​        子类的同名方法不能与基类的类型定义相冲突。</p> <p>​        如果基类包括保护成员(protected修饰符)，子类可以将该成员的可访问性设置为公开(public修饰符)，也可以保持保护成员不变，但是不能改用私有成员(private修饰符)。</p> <p>​        extends关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。</p> <p>​       对于那些只设置了类型、没有初值的顶层属性，有一个细节需要注意。没有设置初值，代码在不同的编译设置下编译结果不一样。解决方法就是使用declare命令，去声明顶层成员的类型，告诉 TS这些成员的赋值由基类实现。</p> <h2 id="可访问性修饰符"><a href="#可访问性修饰符" class="header-anchor">#</a> 可访问性修饰符</h2> <p>​        类的内部成员的外部可访问性，由三个可访问性修饰符控制：public、private和protected。这三个修饰符的位置，都写在属性或方法的最前面。</p> <h3 id="public"><a href="#public" class="header-anchor">#</a> public</h3> <p>​        public修饰符表示这是公开成员，<em>*外部可以自由访问**</em>***。是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。正常情况下，除非为了醒目和代码可读性，public都是省略不写的。</p> <ul><li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li></ul> <h3 id="private"><a href="#private" class="header-anchor">#</a> private</h3> <p>​        private修饰符表示私有成员，<em>*只能用在当前类的内部**</em>***，<em>*类的实例和子类都不能使用**</em>***该成员。如果在类的内部，当前类的实例可以获取私有成员。</p> <ul><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li></ul> <blockquote><p>​        严格地说，private定义的私有成员，并不是真正意义的私有成员。一方面，编译成JavaScript后，private关键字就被剥离了，这时外部访问该成员就不会报错。另一方面，由于前一个原因，TypeScript对于访问private成员没有严格禁止，使用方括号写法（[]）或者in运算符，实例对象就能访问该成员。
​        建议不使用private，改用 ES2022 的写法（属性名前加#），获得真正意义的私有成员。</p></blockquote> <p>​        构造方法也可以是私有的，这就直接防止了使用new命令生成实例对象(实现了单例模式)，只能在类的内部创建实例对象。当构造函数修饰为 private 时，该类不允许被继承或者实例化，当构造函数修饰为 protected 时，该类只允许被继承。</p> <h3 id="protected"><a href="#protected" class="header-anchor">#</a> protected</h3> <p>​        protected修饰符表示该成员是保护成员，<em>*只能在类的内部使用**</em>**<em>该成员，<em>*实例无法使用**</em>*<em><em>该成员，但是</em>*子类内部可以使用****</em></em>。子类不仅可以拿到父类的保护成员，还可以定义同名成员。在类的外部，实例对象不能读取保护成员，但是在类的内部可以。</p> <ul><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li></ul> <h3 id="实例属性的简写形式"><a href="#实例属性的简写形式" class="header-anchor">#</a> 实例属性的简写形式</h3> <p>​        实际开发中，很多实例属性的值，是通过构造方法传入的。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 属性x和y的值是通过构造方法的参数传入的</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​        这样的写法等于对同一个属性要声明两次类型，一次在类的头部，另一次在构造方法的参数里面。这有些累赘，TypeScript 就提供了一种简写形式。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>
    <span class="token keyword">public</span> x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token comment">//这里的public不能省略</span>
    <span class="token keyword">public</span> y<span class="token operator">:</span><span class="token builtin">number</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>x <span class="token comment">// 10</span>
p<span class="token punctuation">.</span>y <span class="token comment">// 10</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>构造方法的参数x前面有public修饰符，这时 TypeScript 就会自动声明一个公开属性x，不必在构造方法里面写任何代码，同时还会设置x的值为构造方法的参数值。</p></blockquote> <p>​        除了public修饰符，构造方法的参数名只要有private、protected、readonly修饰符，都会自动声明对应修饰符的实例属性。readonly还可以与其他三个可访问性修饰符，一起使用。</p> <h2 id="静态成员"><a href="#静态成员" class="header-anchor">#</a> 静态成员</h2> <p>​        类的内部可以使用static关键字，定义静态成员。静态成员是只能通过类本身使用的成员，不能通过实例对象使用。static关键字前面可以使用 public、private、protected 修饰符。静态私有属性也可以用ES6语法的 #前缀 表示。public和protected的静态成员可以被继承。</p> <h2 id="泛型类"><a href="#泛型类" class="header-anchor">#</a> 泛型类</h2> <p>​        类也可以写成泛型，使用类型参数。注意，静态成员不能使用泛型的类型参数。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Box<span class="token operator">&lt;</span>Type<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">// 类Box有类型参数Type，因此属于泛型类。</span>
  contents<span class="token operator">:</span> Type<span class="token punctuation">;</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token operator">:</span>Type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>contents <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的Box&lt;string&gt;可以省略不写</span>
<span class="token keyword">const</span> b<span class="token operator">:</span>Box<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 因为可以从等号右边推断得到</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="抽象类-抽象成员"><a href="#抽象类-抽象成员" class="header-anchor">#</a> 抽象类，抽象成员</h2> <p>​        TypeScript允许在类的定义前面，加上关键字abstract，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做抽象类。抽象类只能当作基类使用，用来在它的基础上定义子类。</p> <blockquote><p>抽象类是不允许被实例化的。抽象类中的抽象方法必须被子类实现。即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类。</p></blockquote> <p>​        抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。</p> <p>​        抽象类的子类也可以是抽象类，也就是说，抽象类可以继承其他抽象类。</p> <p>​       抽象类的内部可以有已经实现好的属性和方法，也可以有未实现的属性和方法。后者叫抽象成员，即属性名和方法名有abstract关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。</p> <p>​        这里有几个注意点。</p> <ul><li>抽象成员只能存在于抽象类，不能存在于普通类。</li> <li>抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加abstract关键字。</li> <li>抽象成员前也不能有private修饰符，否则无法在子类中实现该成员。</li> <li>一个子类最多只能继承一个抽象类。</li></ul> <h2 id="this-问题"><a href="#this-问题" class="header-anchor">#</a> this 问题</h2> <p>​        类的方法经常用到this关键字，它表示该方法当前所在的对象。</p> <p>​        TypeScript 允许函数增加一个名为this的参数，放在参数列表的第一位，用来描述函数内部的this关键字的类型。编译时，TypeScript 一旦发现函数的第一个参数名为this，则会去除这个参数，即编译结果不会带有该参数。</p> <p>​        this参数的类型可以声明为各种对象。</p> <p>​        在类的内部，this本身也可以当作类型使用，表示当前类的实例对象。</p> <p>​        TypeScript提供了一个noImplicitThis编译选项。如果打开了这个设置项，如果this的值推断为any类型，就会报错。</p> <p>​        注意，this类型不允许应用于静态成员。静态成员拿不到实例对象。</p> <p>​        有些方法返回一个布尔值，表示当前的this是否属于某种类型。这时，这些方法的返回值类型可以写成this is Type的形式，其中用到了is运算符。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/4/13 07:03:33</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/TypeScript教程/函数.html" class="prev">
          函数
        </a></span> <span class="next"><a href="/vivien-blog/books/TypeScript教程/泛型和类型断言.html">
          泛型和类型断言
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#interface" class="sidebar-link reco-side-interface" data-v-9f22dc18>interface</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#interface-的继承" class="sidebar-link reco-side-interface-的继承" data-v-9f22dc18>interface 的继承</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#interface-继承-interface" class="sidebar-link reco-side-interface-继承-interface" data-v-9f22dc18>interface 继承 interface</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#interface-继承-type" class="sidebar-link reco-side-interface-继承-type" data-v-9f22dc18>interface 继承 type</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#interface-继承-class" class="sidebar-link reco-side-interface-继承-class" data-v-9f22dc18>interface 继承 class</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#接口合并" class="sidebar-link reco-side-接口合并" data-v-9f22dc18>接口合并</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#interface-与-type-的异同" class="sidebar-link reco-side-interface-与-type-的异同" data-v-9f22dc18>interface 与 type 的异同</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#类" class="sidebar-link reco-side-类" data-v-9f22dc18>类</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#属性的类型" class="sidebar-link reco-side-属性的类型" data-v-9f22dc18>属性的类型</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#readonly-修饰符" class="sidebar-link reco-side-readonly-修饰符" data-v-9f22dc18>readonly 修饰符</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#方法的类型" class="sidebar-link reco-side-方法的类型" data-v-9f22dc18>方法的类型</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#存取器方法" class="sidebar-link reco-side-存取器方法" data-v-9f22dc18>存取器方法</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#属性索引" class="sidebar-link reco-side-属性索引" data-v-9f22dc18>属性索引</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#类的-interface-接口" class="sidebar-link reco-side-类的-interface-接口" data-v-9f22dc18>类的 interface 接口</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#implements-关键字" class="sidebar-link reco-side-implements-关键字" data-v-9f22dc18>implements 关键字</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#实现多个接口" class="sidebar-link reco-side-实现多个接口" data-v-9f22dc18>实现多个接口</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#类与接口的合并" class="sidebar-link reco-side-类与接口的合并" data-v-9f22dc18>类与接口的合并</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#class-类型" class="sidebar-link reco-side-class-类型" data-v-9f22dc18>Class 类型</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#实例类型" class="sidebar-link reco-side-实例类型" data-v-9f22dc18>实例类型</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#类的自身类型" class="sidebar-link reco-side-类的自身类型" data-v-9f22dc18>类的自身类型</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#结构类型原则" class="sidebar-link reco-side-结构类型原则" data-v-9f22dc18>结构类型原则</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#类的继承" class="sidebar-link reco-side-类的继承" data-v-9f22dc18>类的继承</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#可访问性修饰符" class="sidebar-link reco-side-可访问性修饰符" data-v-9f22dc18>可访问性修饰符</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#public" class="sidebar-link reco-side-public" data-v-9f22dc18>public</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#private" class="sidebar-link reco-side-private" data-v-9f22dc18>private</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#protected" class="sidebar-link reco-side-protected" data-v-9f22dc18>protected</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#实例属性的简写形式" class="sidebar-link reco-side-实例属性的简写形式" data-v-9f22dc18>实例属性的简写形式</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#静态成员" class="sidebar-link reco-side-静态成员" data-v-9f22dc18>静态成员</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#泛型类" class="sidebar-link reco-side-泛型类" data-v-9f22dc18>泛型类</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#抽象类-抽象成员" class="sidebar-link reco-side-抽象类-抽象成员" data-v-9f22dc18>抽象类，抽象成员</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/TypeScript%E6%95%99%E7%A8%8B/interface%E5%92%8C%E7%B1%BB.html#this-问题" class="sidebar-link reco-side-this-问题" data-v-9f22dc18>this 问题</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.f272a1d3.js" defer></script><script src="/vivien-blog/assets/js/7.464cc3ea.js" defer></script><script src="/vivien-blog/assets/js/2.db1c35d8.js" defer></script><script src="/vivien-blog/assets/js/1.88465532.js" defer></script><script src="/vivien-blog/assets/js/112.8496b045.js" defer></script>
  </body>
</html>
