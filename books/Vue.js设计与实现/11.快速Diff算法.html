<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>11.快速Diff算法 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.1b7b4fd5.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.210383a7.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.00d63d32.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.96251043.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/16.0fcf1058.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.fa80c4ef.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.057c90a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.19c4abac.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.8bc66b45.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.a3435343.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.0068d84a.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.04fc30e6.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.9ff39244.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3b79619c.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.d5bf9027.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.698ce34c.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.45f08108.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.3681f055.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.387f6115.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.4d7580b7.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.c3fe5fe0.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.f0df6d73.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.2388eeb0.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.94a902d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.35c6f7e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.f7ecaac7.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.53eceb0f.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.1bbfbebb.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.b66bb0a4.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.1a72171a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.49317ff6.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.1919ad13.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.46542121.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.d20b2438.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.096c8422.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.6f10ade2.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.be3e0f7e.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.92794b90.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.93cec235.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.41118c66.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.3131a535.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.c4515dab.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.2fe122be.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.341cf97a.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.c523984f.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.06b93e75.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.9f594ab7.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.409fd3e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.5a3a4049.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.21fac10f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.c590614b.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.b8c03943.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.2c65a62c.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.15a38861.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.934f6b75.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.8704b94b.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e6e61ee0.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.c193bc49.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.03974196.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.7e51c94f.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.1da6c0eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.44155ea4.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.c892cb88.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.20dcb46a.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.ab72969e.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.35261d9d.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.d1f877b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.58cf6028.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.1056cd44.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.d32266a5.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.652b8114.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.1deb9d35.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.1b0a642d.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.f74917b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.b394b7e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.b1d92ead.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.fa969ab7.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.3676a039.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.8625a796.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.85e6ae67.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.cf3b4106.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.195eccac.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.a23fa0b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.cc54345c.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.3074601a.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.5861d737.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.89926beb.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.28daaf49.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.7333cd13.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.c0ec386a.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.47dd6986.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.7a8aca22.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.45edd43b.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.7b6e7073.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f8cbb551.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.6cc4496a.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.91f8578c.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.2a8f1cef.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.7a4f08f0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.072edcd7.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.11e37d34.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.b2ed6145.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.b0ffe6f1.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.37f798b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.4a2f8418.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.26d75a07.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.de800dca.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6ac0d041.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.cbde96fb.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.96d5beb2.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.4d9e115c.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.948fa90e.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.246d9e36.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.79d82321.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.d881655a.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.0d3c4c1c.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.241b57a2.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.4cb09072.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.6b6a6d21.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.09f385e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.684c40fa.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.3abfbc85.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.8e112cc6.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.ccd72f8f.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.50ca9f79.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.bfe29f10.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.a5f404ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.c86f128e.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.59512bfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.cf1ceb98.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="active sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>11.快速Diff算法</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">11.快速Diff算法</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/11</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><blockquote><p>1、预处理：首先，对新旧虚拟 DOM 树进行预处理，包括：标记所有静态节点、标记所有拥有 key的节点。</p> <p>2、根节点比较：比较新旧虚拟 DOM 树的根节点，如果相同则跳过，否则进行深度比较。</p> <p>3、深度比较：深度比较的流程如下: ①比较两个节点的类型，如果不同则直接生成更新操作。②如果两个节点的类型相同，则比较两个节点的属性，如果不同则生成更新操作。③如果两个节点的类型和属性都相同，则比较两个节点的子节点。</p> <p>4.生成更新操作 根据两个节点之间的差异，生成更新真实 DOM 所需的最小操作集。</p></blockquote> <p>​	快速 Diff 算法：正如其名，该算法的实测速度非常快。该算法最早应用于 ivi 和 inferno 这两个框架，Vue.js 3 借鉴并扩展了它。下图比较了 ivi、inferno 以及 Vue.js 2 的性能：</p> <p><img src="/vivien-blog/assets/img/image-20240911093315955.369a8bcf.png" alt="性能比较"></p> <blockquote><p>从中可以看出，在 DOM 操作的各个方面，ivi 和 inferno 所采用的快速 Diff 算法的性能都要稍优于 Vue.js 2 所采用的双端 Diff 算法。既然快速 Diff 算法如此高效，我们有必要了解它的思路。</p></blockquote> <h2 id="相同的前置元素和后置元素"><a href="#相同的前置元素和后置元素" class="header-anchor">#</a> 相同的前置元素和后置元素</h2> <blockquote><p>截取可复用的部分，不可复用的部分再进行 Diff。</p></blockquote> <p>​	不同于简单 Diff 算法和双端 Diff 算法，快速 Diff 算法包含<strong>预处理</strong>步骤，这其实是<strong>借鉴了纯文本 Diff 算法的思路</strong>。在纯文本 Diff 算法中，存在对两段文本进行预处理的过程。例如，在对两段文本进行 Diff 之前，可以先对它们进行全等比较：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>text1 <span class="token operator">===</span> text2<span class="token punctuation">)</span> <span class="token keyword">return</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这也称为<strong>快捷路径</strong>。如果两段文本<strong>全等</strong>，那么就无须进入核心 Diff 算法的步骤了。除此之外，预处理过程还会处理两段文本相同的<strong>前缀和后缀</strong>。假设有如下两段文本：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token constant">TEXT1</span><span class="token operator">:</span> <span class="token constant">I</span> use vue <span class="token keyword">for</span> app development
 <span class="token constant">TEXT2</span><span class="token operator">:</span> <span class="token constant">I</span> use react <span class="token keyword">for</span> app development
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	通过肉眼可以很容易发现，这两段文本的头部和尾部分别有一段相同的内容：</p> <p><img src="/vivien-blog/assets/img/image-20240911093700425.bb3c4337.png" alt="文本预处理"></p> <p>​	<strong>对于内容相同的问题，是不需要进行核心 Diff 操作的</strong>。因此，对于 TEXT1 和 TEXT2 来说，真正需要进行 Diff 操作的部分是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token constant">TEXT1</span><span class="token operator">:</span> vue
 <span class="token constant">TEXT2</span><span class="token operator">:</span> react
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	这实际上是简化问题的一种方式。这么做的好处是，在特定情况下我们能够轻松地判断文本的插入和删除，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token constant">TEXT1</span><span class="token operator">:</span> <span class="token constant">I</span> like you
 <span class="token constant">TEXT2</span><span class="token operator">:</span> <span class="token constant">I</span> like you too
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	经过预处理，去掉这两段文本中相同的前缀内容和后缀内容之后，它将变成：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token constant">TEXT1</span><span class="token operator">:</span>
 <span class="token constant">TEXT2</span><span class="token operator">:</span> too
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	可以看到，经过预处理后，TEXT1 的内容为空。这说明 TEXT2 在 TEXT1 的基础上增加了字符串 too。相反，我们还可以将这两段文本的位置互换：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token constant">TEXT1</span><span class="token operator">:</span> <span class="token constant">I</span> like you too
 <span class="token constant">TEXT2</span><span class="token operator">:</span> <span class="token constant">I</span> like you
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	这两段文本经过预处理后将变成：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token constant">TEXT1</span><span class="token operator">:</span> too
 <span class="token constant">TEXT2</span><span class="token operator">:</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	由此可知，TEXT2 是在 TEXT1 的基础上删除了字符串 too。</p> <p>​	快速 Diff 算法借鉴了纯文本 Diff 算法中预处理的步骤。例如：</p> <p><img src="/vivien-blog/assets/img/image-20240911094003092.6d98e337.png" alt="新旧两组子节点"></p> <blockquote><p>这两组子节点的顺序如下：</p> <ul><li>旧的一组子节点：p-1、p-2、p-3。</li> <li>新的一组子节点：p-1、p-4、p-2、p-3。</li></ul></blockquote> <p>​	通过观察可以发现，两组子节点具有<strong>相同的前置节点</strong> p-1，以及相同的后置节点 p-2 和 p-3：</p> <p><img src="/vivien-blog/assets/img/image-20240911094123056.d383f567.png" alt="相同的前置节点和后置节点"></p> <p>​	对于<strong>相同</strong>的前置节点和后置节点，由于它们在新旧两组子节点中的<strong>相对位置不变</strong>，所以我们<strong>无须移动</strong>它们，但仍然需要在它们之间<strong>打补丁</strong>。</p> <h3 id="前置节点"><a href="#前置节点" class="header-anchor">#</a> 前置节点</h3> <p>​	对于前置节点，我们可以建立索引 j，其初始值为 0，用来指向两组子节点的开头：</p> <p><img src="/vivien-blog/assets/img/image-20240911094223439.a3b2ec6e.png" alt="建立索引j，指向两组子节点的开头"></p> <p>​	然后开启一个 while 循环，让索引 j 递增，直到遇到不相同的节点为止：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchKeyedChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
   <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
   <span class="token comment">// 处理相同的前置节点</span>
   <span class="token comment">// 索引 j 指向新旧两组子节点的开头</span>
   <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">let</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
   <span class="token keyword">let</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
   <span class="token comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用 patch 函数进行更新</span>
     <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
     <span class="token comment">// 更新索引 j，让其递增</span>
     j<span class="token operator">++</span>
     oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
     newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span> <span class="token comment">// 就是从左往右遍历打补丁，直到遇到 key 不相等的 VNode 即停下来。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>我们使用 while 循环查找<strong>所有相同的前置节点</strong>，并调用 patch 函数进行<strong>打补丁</strong>，<strong>直到遇到 key 值不同</strong>的节点为止。这样，我们就完成了对前置节点的更新。</p></blockquote> <p>​	在这一步更新操作过后，新旧两组子节点的状态如下：</p> <p><img src="/vivien-blog/assets/img/image-20240911094357455.e8b0ed86.png" alt="处理完前置节点后的状态"></p> <blockquote><p>注意，当 while 循环终止时，索引 j 的值为 1。</p></blockquote> <h3 id="后置节点"><a href="#后置节点" class="header-anchor">#</a> 后置节点</h3> <p>​	接下来，我们需要处理相同的后置节点。由于<strong>新旧两组子节点的数量可能不同</strong>，所以我们需要<strong>两个索引</strong> newEnd 和 oldEnd，分别指向新旧两组子节点中的<strong>最后一个</strong>节点：</p> <p><img src="/vivien-blog/assets/img/image-20240911094441385.662b2fad.png" alt="建立索引，指向两组子节点的最后一个节点"></p> <p>​	然后，再开启一个 while 循环，并<strong>从后向前遍历</strong>这两组子节点，<strong>直到遇到 key 值不同</strong>的节点为止：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchKeyedChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
   <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
   <span class="token comment">// 更新相同的前置节点</span>
   <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">let</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
   <span class="token keyword">let</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
     j<span class="token operator">++</span>
     oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
     newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 更新相同的后置节点</span>
   <span class="token comment">// 索引 oldEnd 指向旧的一组子节点的最后一个节点</span>
   <span class="token keyword">let</span> oldEnd <span class="token operator">=</span> oldChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token comment">// 索引 newEnd 指向新的一组子节点的最后一个节点</span>
   <span class="token keyword">let</span> newEnd <span class="token operator">=</span> newChildren<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>

   oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>oldEnd<span class="token punctuation">]</span>
   newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>newEnd<span class="token punctuation">]</span>

   <span class="token comment">// while 循环从后向前遍历，直到遇到拥有不同 key 值的节点为止</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用 patch 函数进行更新</span>
     <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
     <span class="token comment">// 递减 oldEnd 和 nextEnd</span>
     oldEnd<span class="token operator">--</span>
     newEnd<span class="token operator">--</span>
     oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>oldEnd<span class="token punctuation">]</span>
     newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>newEnd<span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><blockquote><p>与处理相同的前置节点一样，在 while 循环内，需要调用 patch 函数进行<strong>打补丁</strong>，然后递减两个索引 oldEnd、newEnd 的值。</p> <ol><li>从左往右遍历，找到新旧节点 key 不同时即跳出循环，此时 j 指针就是新旧 VNode 不一致的位置索引。</li> <li>开启另一个循环，从右向左遍历，此时新旧节点集合因为数量可能不一样多，所以需要分别定一个结束索引（即节点集合的长度 -1），然后从右往左遍历。</li> <li>如果遇到相同 key 的节点则 path 对比内容是否需要更新，然后尾指针各自递减，继续下个循环。</li> <li>往前找到新旧虚拟节点不同的，则退出循环，此时的新旧节点集合的尾指针指向的就是 key 不同的虚拟节点。</li></ol></blockquote> <p>​	在这一步更新操作过后，新旧两组子节点的状态如下：</p> <p><img src="/vivien-blog/assets/img/image-20240911094614198.ba9ff2c2.png" alt="处理完后置节点后的状态"></p> <p>​	当相同的前置节点和后置节点被处理完毕后，旧的一组子节点已经全部被处理了，而在新的一组子节点中，还遗留了一个未被处理的节点 p-4。</p> <h3 id="新增节点"><a href="#新增节点" class="header-anchor">#</a> 新增节点</h3> <p>​	其实不难发现，节点 p-4 是一个新增节点。那么，如何用程序得出“节点 p-4 是新增节点”这个结论呢？这需要我们观察三个索引 j、newEnd 和 oldEnd 之间的关系。</p> <ul><li>条件一 oldEnd &lt; j 成立：说明在预处理过程中，所有旧子节点都处理完毕了。</li> <li>条件二 newEnd &gt;= j 成立：说明在预处理过后，在新的一组子节点中，仍然有未被处理的节点，而这些遗留的节点将被视作<strong>新增节点</strong>。</li></ul> <p>​	如果条件一和条件二同时成立，说明在新的一组子节点中，存在遗留节点，且这些节点都是新增节点。因此我们需要将它们挂载到正确的位置：</p> <p><img src="/vivien-blog/assets/img/image-20240911094737159.98cc7679.png" alt="新增节点的情况"></p> <p>​	在新的一组子节点中，索引值处于 j 和 newEnd 之间的任何节点都需要作为新的子节点进行挂载。为了将这些节点挂载到正确位置，我们必须找到正确的锚点元素。</p> <p>​	观察上图中新的一组子节点可知，新增节点应该挂载到节点 p-2 所对应的真实 DOM 前面。所以，节点 p-2 对应的真实 DOM 节点就是挂载操作的锚点元素：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchKeyedChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
   <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
   <span class="token comment">// 更新相同的前置节点</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// 更新相同的后置节点</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// 预处理完毕后，如果满足如下条件，则说明从 j --&gt; newEnd 之间的节点应作为新节点插入</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 锚点的索引</span>
     <span class="token keyword">const</span> anchorIndex <span class="token operator">=</span> newEnd <span class="token operator">+</span> <span class="token number">1</span>
     <span class="token comment">// 锚点元素</span>
     <span class="token keyword">const</span> anchor <span class="token operator">=</span> anchorIndex <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length <span class="token operator">?</span> newChildren<span class="token punctuation">[</span>anchorIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>el <span class="token operator">:</span> <span class="token keyword">null</span>
     <span class="token comment">// 采用 while 循环，调用 patch 函数逐个挂载新增节点</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>​	首先计算锚点的索引值（即 anchorIndex）为 newEnd + 1。如果小于新的一组子节点的数量，则说明锚点元素在新的一组子节点中，所以直接使用newChildren[anchorIndex].el 作为锚点元素；否则说明索引 newEnd 对应的节点已经是尾部节点了，这时无须提供锚点元素。有了<strong>锚点</strong>元素之后，我们开启了一个 while循环，用来遍历索引 j 和索引 newEnd 之间的节点，并调用 patch 函数<strong>挂载</strong>它们。</p> <blockquote><p>由于插入都是用的 inserBefore，而且后面节点的顺序都确定了，所以可以参照当前节点的下个节点的 el 进行插入。</p> <p>newEnd 是新元素数组中，从尾开始往前比对，直到不匹配，这里需要注意不要将其跟 j 搞混了。</p></blockquote> <h3 id="删除节点"><a href="#删除节点" class="header-anchor">#</a> 删除节点</h3> <p>​	上面的案例展示了新增节点的情况，我们再来看看删除节点的情况：</p> <p><img src="/vivien-blog/assets/img/image-20240911094916595.ffaca1e2.png" alt="删除节点的情况"></p> <blockquote><p>在这个例子中，新旧两组子节点的顺序如下。</p> <ul><li>旧的一组子节点：p-1、p-2、p-3。</li> <li>新的一组子节点：p-1、p-3。</li></ul> <p>我们同样使用索引 j、oldEnd 和 newEnd 进行标记：</p> <p><img src="/vivien-blog/assets/img/image-20240911095048986.72856da4.png" alt="在删除节点的情况下，各个索引的关系"></p> <p>​	接着，对相同的前置节点进行预处理，处理后的状态如下：</p> <p><img src="/vivien-blog/assets/img/image-20240911095128616.637c6e4a.png" alt="处理完前置节点后，各个索引的关系"></p> <p>​	然后，对相同的后置节点进行预处理，处理后的状态如下：</p> <p><img src="/vivien-blog/assets/img/image-20240911095210660.a4e532f7.png" alt="处理完后置节点后，各个索引的关系"></p></blockquote> <p>​	当相同的前置节点和后置节点全部被处理完毕后，新的一组子节点已经全部被处理完毕了，而旧的一组子节点中遗留了一个节点 p-2。这说明，应该卸载节点 p-2。实际上，<strong>遗留的节点可能有多个</strong>：</p> <p><img src="/vivien-blog/assets/img/image-20240911095243843.800a382e.png" alt="遗留的节点可能有多个"></p> <p>​	索引 j 和索引 oldEnd 之间的任何节点都应该被卸载，具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchKeyedChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
   <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
   <span class="token comment">// 更新相同的前置节点</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// 更新相同的后置节点</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// j -&gt; oldEnd 之间的节点应该被卸载</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">unmount</span><span class="token punctuation">(</span>oldChildren<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>新增了一个 else...if 分支。当满足条件 <strong>j &gt; newEnd &amp;&amp; j &lt;=oldEnd</strong> 时，则开启一个 while 循环，并调用 unmount 函数<strong>逐个卸载</strong>这些遗留节点。</p></blockquote> <h2 id="判断是否需要进行-dom-移动操作"><a href="#判断是否需要进行-dom-移动操作" class="header-anchor">#</a> 判断是否需要进行 DOM 移动操作</h2> <blockquote><p>预处理的本质是找到相同的前置节点和后置节点理想情况下，预处理之后只需要增加或删除节点即可。非理想情况下就是还要处理节点的移动。</p></blockquote> <p>​	快速 Diff 算法的<strong>预处理</strong>过程，即<strong>处理相同的前置节点和后置节点</strong>。但是，前面给出的例子比较理想化，当处理完相同的前置节点或后置节点后，新旧两组子节点中总会有一组子节点全部被处理完毕。在这种情况下，只需要简单地挂载、卸载节点即可。但有时情况会比较复杂：</p> <p><img src="/vivien-blog/assets/img/image-20240911104220451.fe79b16b.png" alt="复杂情况下的新旧两组子节点"></p> <blockquote><p>在这个例子中，新旧两组子节点的顺序如下：</p> <ul><li>旧的一组子节点：p-1、p-2、p-3、p-4、p-6、p-5。</li> <li>新的一组子节点：p-1、p-3、p-4、p-2、p-7、p-5。</li></ul> <p>​	可以看到，与旧的一组子节点相比，新的一组子节点多出了一个新节点 p-7，少了一个节点 p-6。这个例子并不像前面的例子那样理想化，我们无法简单地通过预处理过程完成更新。在这个例子中，相同的前置节点只有 p-1，而相同的后置节点只有 p-5：</p> <p><img src="/vivien-blog/assets/img/image-20240911104514910.89685a58.png" alt="复杂情况下仅有少量相同的前置节点和后置节点"></p></blockquote> <p>​	经过预处理后两组子节点的状态如下：</p> <p><img src="/vivien-blog/assets/img/image-20240911104617786.b231c4e8.png" alt="处理完前置节点和后置节点后的状态"></p> <blockquote><p>可以看到，经过预处理后，无论是新的一组子节点，还是旧的一组子节点，都有部分节点未经处理。这时就需要我们进一步处理。</p> <p>​	怎么处理呢？其实无论是简单 Diff 算法，还是双端 Diff 算法，抑或快速 Diff 算法，它们都遵循同样的处理规则：</p> <ul><li>判断是否有节点需要移动，以及应该如何移动；</li> <li>找出那些需要被添加或移除的节点。</li></ul></blockquote> <p>​	所以接下来我们的任务就是，判断哪些节点需要移动，以及应该如何移动。观察上图可知，在这种非理想的情况下，当相同的前置节点和后置节点被处理完毕后，索引 j、newEnd 和 oldEnd 不满足下面两个条件中的任何一个：</p> <ul><li>j &gt; oldEnd &amp;&amp; j &lt;= newEnd</li> <li>j &gt; newEnd &amp;&amp; j &lt;= oldEnd</li></ul> <p>​	因此，我们需要增加新的 else 分支来处理上图所示的情况：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchKeyedChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
   <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
   <span class="token comment">// 更新相同的前置节点</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// 更新相同的后置节点</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 增加 else 分支来处理非理想情况</span>
   <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>后续的处理逻辑将会编写在这个 else 分支内。</p></blockquote> <p>​	知道了在哪里编写处理代码，接下来我们学习具体的处理思路。</p> <p>​	首先，我们需要构造一个数组 source，它的长度等于<strong>新的一组子节点在经过预处理之后剩余未处理节点的数量</strong>，并且 <strong>source 中每个元素的初始值都是 -1</strong>：</p> <p><img src="/vivien-blog/assets/img/image-20240911105006674.5e0d1bba.png" alt="构造source数组"></p> <p>​	我们可以通过下面的代码完成 source 数组的构造：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">// 构造 source 数组</span>
   <span class="token comment">// 新的一组子节点中剩余未处理节点的数量</span>
   <span class="token keyword">const</span> count <span class="token operator">=</span> newEnd <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>
   <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
   source<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>首先，我们需要计算新的一组子节点中剩余未处理节点的数量，即 newEnd - j + 1，然后创建一个长度与之相同的数组 source，最后使用 fill 函数完成数组的填充。</p> <p>数组 source 的作用：观察上图可以发现，<strong>数组 source 中的每一个元素分别与新的一组子节点中剩余未处理节点对应</strong>。</p></blockquote> <p>​	实际上，<strong>source 数组将用来存储新的一组子节点中的节点在旧的一组子节点中的位置索引</strong>，后面将会使用它计算出一个最长递增子序列，并用于辅助完成 DOM 移动的操作：</p> <p><img src="/vivien-blog/assets/img/image-20240911105432217.c8538f48.png" alt="填充source数组"></p> <blockquote><p>上图 展示了填充 source 数组的过程。由于 source 数组存储的是新子节点在旧的一组子节点中的位置索引，所以有：</p> <ul><li>新的一组子节点中的节点 p-3 在旧的一组子节点中的索引为 2，因此 source 数组的第一个元素值为 2；</li> <li>新的一组子节点中的节点 p-4 在旧的一组子节点中的索引为 3，因此 source 数组的第二个元素值为 3；</li> <li>新的一组子节点中的节点 p-2 在旧的一组子节点中的索引为 1，因此 source 数组的第三个元素值为 1；</li> <li>新的一组子节点中的节点 p-7 比较特殊，因为在旧的一组子节点中<strong>没有</strong>与其 key 值相等的节点，所以 source 数组的第四个元素值<strong>保留原来的 -1</strong>。</li></ul> <p>核心思路就是尽可能找到能复用的节点进行 patch 操作。</p> <p>source 存储的是中间部分<strong>新虚拟节点在旧虚拟节点集合中对应的索引</strong>，如果没有找到则保留初始值 -1，-1的就是最终需要新增的。</p></blockquote> <p>​	我们可以通过两层 for 循环来完成 source 数组的填充工作，外层循环用于遍历旧的一组子节点，内层循环用于遍历新的一组子节点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> count <span class="token operator">=</span> newEnd <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>
   <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
   source<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

   <span class="token comment">// oldStart 和 newStart 分别为起始索引，即 j</span>
   <span class="token keyword">const</span> oldStart <span class="token operator">=</span> j
   <span class="token keyword">const</span> newStart <span class="token operator">=</span> j
   <span class="token comment">// 遍历旧的一组子节点</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token comment">// 遍历新的一组子节点</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> newStart<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token comment">// 找到拥有相同 key 值的可复用节点</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> newVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 调用 patch 进行更新</span>
         <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
         <span class="token comment">// 最后填充 source 数组</span>
         source<span class="token punctuation">[</span>k <span class="token operator">-</span> newStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>注意，由于<strong>数组 source 的索引是从 0 开始的</strong>，而<strong>未处理节点的索引未必从 0 开始</strong>，所以在填充数组时需要使用表达式 k - newStart 的值作为数组的索引值。外层循环的变量 i 就是当前节点在旧的一组子节点中的位置索引，因此直接将变量 i 的值赋给 source[k - newStart] 即可。</p> <p><strong>未处理节点即为 newStart</strong>，不一定是 0，所以不能直接用 k，需要 k-newStart 获取当前在未处理新节点数组中实际的 index。</p></blockquote> <p>​	现在，source 数组已经填充完毕，我们后面会用到它。不过在进一步学习之前，我们需要回头思考一下上面那段用于填充 source 数组的代码存在怎样的问题。这段代码中我们采用了两层嵌套的循环，其时间复杂度为 O(n1 * n2)，其中 n1 和 n2 为新旧两组子节点的数量，我们也可以使用 O(n^2) 来表示。</p> <p>​	当新旧两组子节点的数量较多时，两层嵌套的循环会带来性能问题。出于优化的目的，我们可以<strong>为新的一组子节点构建一张索引表</strong>，用来存储节点的 <strong>key</strong> 和节点位置<strong>索引</strong>之间的映射：</p> <p><img src="/vivien-blog/assets/img/image-20240911110200565.33862d87.png" alt="使用索引表填充source数组"></p> <p>​	有了索引表，我们就可以利用它快速地填充 source 数组：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> count <span class="token operator">=</span> newEnd <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>
   <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
   source<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

   <span class="token comment">// oldStart 和 newStart 分别为起始索引，即 j</span>
   <span class="token keyword">const</span> oldStart <span class="token operator">=</span> j
   <span class="token keyword">const</span> newStart <span class="token operator">=</span> j
   <span class="token comment">// 构建索引表</span>
   <span class="token keyword">const</span> keyIndex <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     keyIndex<span class="token punctuation">[</span>newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
   <span class="token punctuation">}</span>
   <span class="token comment">// 遍历旧的一组子节点中剩余未处理的节点</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token comment">// 通过索引表快速找到新的一组子节点中具有相同 key 值的节点位置</span>
     <span class="token keyword">const</span> k <span class="token operator">=</span> keyIndex<span class="token punctuation">[</span>oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token comment">// 调用 patch 函数完成更新</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
       <span class="token comment">// 填充 source 数组</span>
       source<span class="token punctuation">[</span>k <span class="token operator">-</span> newStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 没找到</span>
       <span class="token function">unmount</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><blockquote><p>同样使用了两个 for 循环，不过它们不再是嵌套的关系，所以能够将代码的时间复杂度降至 O(n)。</p> <p>其中，第一个 for 循环用来<strong>构建索引表</strong>，索引表存储的是节点的 key 值与节点在新的一组子节点中位置索引之间的映射，第二个 for 循环用来<strong>遍历旧的一组子节点</strong>。</p> <p>可以看到，我们拿旧子节点的 key 值去索引表 keyIndex 中查找该节点在新的一组子节点中的位置，并将查找结果存储到变量 k 中。</p> <p>如果 k 存在，说明该节点是可复用的，所以我们调用 patch 函数进行打补丁，并填充 source 数组；否则说明该节点已经不存在于新的一组子节点中了，这时我们需要调用 unmount函数卸载它。</p></blockquote> <p>​	上述流程执行完毕后，source 数组已经填充完毕了。</p> <p>​	接下来我们应该思考的是，如何判断节点是否需要移动。实际上，快速 Diff 算法判断节点是否需要移动的方法与简单 Diff 算法类似：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">// 构造 source 数组</span>
   <span class="token keyword">const</span> count <span class="token operator">=</span> newEnd <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment">// 新的一组子节点中剩余未处理节点的数量</span>
   <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
   source<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> oldStart <span class="token operator">=</span> j
   <span class="token keyword">const</span> newStart <span class="token operator">=</span> j
   <span class="token comment">// 新增两个变量，moved 和 pos</span>
   <span class="token keyword">let</span> moved <span class="token operator">=</span> <span class="token boolean">false</span>
   <span class="token keyword">let</span> pos <span class="token operator">=</span> <span class="token number">0</span>

   <span class="token keyword">const</span> keyIndex <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     keyIndex<span class="token punctuation">[</span>newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
   <span class="token punctuation">}</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token keyword">const</span> k <span class="token operator">=</span> keyIndex<span class="token punctuation">[</span>oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
       source<span class="token punctuation">[</span>k <span class="token operator">-</span> newStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
       <span class="token comment">// 判断节点是否需要移动</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         moved <span class="token operator">=</span> <span class="token boolean">true</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         pos <span class="token operator">=</span> k
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token function">unmount</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><blockquote><p>新增了两个变量 moved 和 pos。前者的初始值为 false，代表是否需要移动节点，后者的初始值为 0，代表遍历旧的一组子节点的过程中遇到的最大索引值 k。</p> <p>我们在学习简单 Diff 算法时曾提到，如果在遍历过程中遇到的<strong>索引值呈现递增趋势</strong>，则说明不需要移动节点，反之则需要。所以在第二个 for 循环内，我们通过比较变量 k 与变量 pos 的值来判断是否需要移动节点。</p> <p>**解析：**pos 相当于普通 Diff 算法中的 lastIndex，即 oldChildren 按序遍历，正常来说索引序列应该是递增的，如果出现某个节点在 newChildren 中的索引打破了这个递增序列，说明该节点在 newChildren 中应该被移动了。</p></blockquote> <p>​	除此之外，我们还需要一个数量标识，代表<strong>已经更新过的节点数量</strong>。我们知道，<strong>已经更新过的节点数量应该小于新的一组子节点中需要更新的节点数量</strong>。一旦前者超过后者，则说明有多余的节点，我们应该将它们卸载：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">// 构造 source 数组</span>
   <span class="token keyword">const</span> count <span class="token operator">=</span> newEnd <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span>
   <span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
   source<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> oldStart <span class="token operator">=</span> j
   <span class="token keyword">const</span> newStart <span class="token operator">=</span> j
   <span class="token keyword">let</span> moved <span class="token operator">=</span> <span class="token boolean">false</span>
   <span class="token keyword">let</span> pos <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">const</span> keyIndex <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> newStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     keyIndex<span class="token punctuation">[</span>newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
   <span class="token punctuation">}</span>
   <span class="token comment">// 新增 patched 变量，代表更新过的节点数量</span>
   <span class="token keyword">let</span> patched <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token comment">// 如果更新过的节点数量小于等于需要更新的节点数量，则执行更新</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>patched <span class="token operator">&lt;=</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> k <span class="token operator">=</span> keyIndex<span class="token punctuation">[</span>oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">]</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
         <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
         <span class="token comment">// 每更新一个节点，都将 patched 变量 +1</span>
         patched<span class="token operator">++</span>
         source<span class="token punctuation">[</span>k <span class="token operator">-</span> newStart<span class="token punctuation">]</span> <span class="token operator">=</span> i
         <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           moved <span class="token operator">=</span> <span class="token boolean">true</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           pos <span class="token operator">=</span> k
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 没找到</span>
         <span class="token function">unmount</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点</span>
       <span class="token function">unmount</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><blockquote><p>增加了 patched 变量，其初始值为 0，代表更新过的节点数量。</p> <p>接着，在第二个 for 循环中增加了判断 patched &lt;= count，如果此条件成立，则正常执行更新，并且每次更新后都让变量 patched 自增；否则说明剩余的节点都是多余的，于是调用 unmount 函数将它们卸载。</p></blockquote> <p>​	现在，我们通过判断变量 moved 的值，已经能够知道是否需要移动节点，同时也处理了很多边界条件。</p> <h2 id="如何移动元素"><a href="#如何移动元素" class="header-anchor">#</a> 如何移动元素</h2> <p>​	前面，我们实现了两个目标：</p> <ul><li>判断是否需要进行 DOM 移动操作。我们<strong>创建了变量 moved 作为标识</strong>（是否需要移动），当它的值为true 时，说明需要进行 DOM 移动操作。</li> <li><strong>构建 source 数组</strong>。该数组的长度等于新的一组子节点去掉相同的前置/后置节点后，剩余未处理节点的数量。source 数组中<strong>存储着新的一组子节点中的节点在旧的一组子节点中的位置</strong>，后面我们会根据 source 数组计算出一个最长递增子序列，用于 DOM  移动操作。</li></ul> <p>​	接下来，我们学习如何进行 DOM 移动操作：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> oldEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> newEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> newEnd <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> oldStart<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> oldEnd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果 moved 为真，则需要进行 DOM 移动操作</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>在 for 循环后增加了一个 if 判断分支。如果变量 moved 的值为 true，则说明需要进行 DOM 移动操作，所以用于 DOM 移动操作的逻辑将编写在该 if 语句块内。</p></blockquote> <p>​	为了进行 DOM 移动操作，我们首先要根据 source 数组计算出它的最长递增子序列。source 数组仍然取用在前面例子：</p> <p><img src="/vivien-blog/assets/img/image-20240911110200565.33862d87.png" alt="用于计算source数组的递增子序列的例子"></p> <blockquote><p>在这个例子中，我们计算出 source 数组为 [2, 3, 1, -1]。</p></blockquote> <p>​	那么，该数组的最长递增子序列是什么呢？这就需要我们了解最长递增子序列的概念。</p> <div class="custom-block tip"><p class="title">什么是一个序列的递增子序列</p><p>​	简单来说，<strong>给定一个数值序列，找到它的一个子序列，并且该子序列中的值是递增的，子序列中的元素在原序列中不一定连续。<strong>一个序列可能有很多个递增子序列，其中最长的那一个就称为</strong>最长递增子序列</strong>。</p> <p>举个例子，假设给定数值序列 [ 0, 8, 4, 12 ]，那么它的最长递增子序列就是 [0, 8, 12]。</p> <p>当然，<strong>对于同一个数值序列来说，它的最长递增子序列可能有多个</strong>，例如 [0, 4, 12] 也是本例的答案之一。</p></div><p>​	理解了什么是最长递增子序列，接下来我们就可以求解 source 数组的最长递增子序列了:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 计算最长递增子序列</span>
   <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span> <span class="token comment">// [ 0, 1 ]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>使用 lis 函数计算一个数组的最长递增子序列。lis 函数接收source 数组作为参数，并返回 source 数组的最长递增子序列之一。</p></blockquote> <p>​	在上例中，你可能疑惑为什么通过 lis 函数计算得到的是 [0, 1]？实际上，source 数组 [2, 3, 1, -1] 的最长递增子序列应该是 [2, 3]，但我们得到的结果是 [0, 1]，这是为什么呢？这是因为 lis 函数的<strong>返回结果是最长递增子序列中的元素在 source 数组中的位置索引</strong>:</p> <p><img src="/vivien-blog/assets/img/image-20240911112917928.2c20623a.png" alt="递增子序列中存储的是source数组内元素的位置索引"></p> <blockquote><p>因为 source 数组的最长递增子序列为 [2, 3]，其中元素 2 在该数组中的索引为 0，而数组 3 在该数组中的索引为 1，所以最终结果为 [0, 1]。</p></blockquote> <p>​	有了最长递增子序列的索引信息后，下一步要重新对节点进行编号:</p> <p><img src="/vivien-blog/assets/img/image-20240911113048999.088036fc.png" alt="重新对节点进行编号后的状态"></p> <blockquote><p>注意，在编号时，我们忽略了经过预处理的节点 p-1 和 p-5。所以，索引为 0 的节点是 p-2，而索引为 1 节点是 p-3，以此类推。</p> <p>重新编号是为了让子序列 seq 与新的索引值产生对应关系。其实，最长递增子序列 seq 拥有一个非常重要的意义。</p> <p>以上例来说，子序列 seq 的值为 [0, 1]，它的含义是：**在新的一组子节点中，重新编号后索引值为 0 和 1 的这两个节点在更新前后顺序没有发生变化。**换句话说，重新编号后，索引值为 0 和 1 的节点不需要移动（因为递增，位置不用动）。在新的一组子节点中，节点 p-3 的索引为0，节点 p-4 的索引为 1，所以节点 p-3 和 p-4 所对应的真实 DOM 不需要移动。换句话说，只有节点 p-2 和 p-7 可能需要移动。</p></blockquote> <p>​	 为了完成节点的移动，我们还需要创建两个索引值 i 和 s：</p> <ul><li>用索引 i 指向新的一组子节点中的最后一个节点；</li> <li>用索引 s 指向最长递增子序列中的最后一个元素。</li></ul> <p>​	为了简化图示，我们在去掉了旧的一组子节点以及无关的线条和变量：</p> <p><img src="/vivien-blog/assets/img/image-20240911113726812.ebe6ff21.png" alt="建立索引s和i，分别指向子序列和索引的最后一个位置"></p> <p>​	接下来，我们将开启一个 for 循环，让变量 i 和 s 按照上图中箭头的方向移动：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>

   <span class="token comment">// s 指向最长递增子序列的最后一个元素</span>
   <span class="token keyword">let</span> s <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token comment">// i 指向新的一组子节点的最后一个元素</span>
   <span class="token keyword">let</span> i <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token comment">// for 循环使得 i 递减，即按照图 11-24 中箭头的方向移动</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> seq<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果节点的索引 i 不等于 seq[s] 的值，说明该节点需要移动</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 当 i === seq[s] 时，说明该位置的节点不需要移动</span>
       <span class="token comment">// 只需要让 s 指向下一个位置</span>
       s<span class="token operator">--</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>其中，for 循环的目的是让变量 i 按照上图中箭头的方向移动，以便能够逐个访问新的一组子节点中的节点，这里的变量 i 就是节点的索引。</p> <p>在 for 循环内，判断条件 i!== seq[s]，如果节点的索引 i 不等于 seq[s] 的值，则说明该节点对应的真实 DOM需要移动，否则说明当前访问的节点不需要移动，但这时变量 s 需要按照上图中箭头的方向移动，即让变量 s 递减。</p></blockquote> <p>​	接下来我们就按照上述思路执行更新。初始时索引 i 指向节点 p-7。由于节点 p-7 对  应的 source 数组中相同位置的元素值为 -1，所以我们应该将节点 p-7 作为全新的节点进行挂载：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>

   <span class="token comment">// s 指向最长递增子序列的最后一个元素</span>
   <span class="token keyword">let</span> s <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token comment">// i 指向新的一组子节点的最后一个元素</span>
   <span class="token keyword">let</span> i <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token comment">// for 循环使得 i 递减，即按照图 11-24 中箭头的方向移动</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 说明索引为 i 的节点是全新的节点，应该将其挂载</span>
       <span class="token comment">// 该节点在新 children 中的真实位置索引</span>
       <span class="token keyword">const</span> pos <span class="token operator">=</span> i <span class="token operator">+</span> newStart
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>
       <span class="token comment">// 该节点的下一个节点的位置索引</span>
       <span class="token keyword">const</span> nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>
       <span class="token comment">// 锚点</span>
       <span class="token keyword">const</span> anchor <span class="token operator">=</span> nextPos <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length
         <span class="token operator">?</span> newChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el
         <span class="token operator">:</span> <span class="token keyword">null</span>
       <span class="token comment">// 挂载</span>
       <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> seq<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果节点的索引 i 不等于 seq[s] 的值，说明该节点需要移动</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 当 i === seq[s] 时，说明该位置的节点不需要移动</span>
       <span class="token comment">// 只需要让 s 指向下一个位置</span>
       s<span class="token operator">--</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>如果 source[i] 的值为 -1，则说明索引为 i 的节点是全新的节点，于是我们调用 patch函数将其挂载到容器中。</p> <p>注意，由于索引 i 是重新编号后的，因此为了得到真实索引值，我们需要计算表达式 i + newStart 的值。</p></blockquote> <p>​	新节点创建完毕后，for 循环已经执行了一次，此时索引 i 向上移动一步，指向了节点p-2：</p> <p><img src="/vivien-blog/assets/img/image-20240911133702272.d23afc77.png" alt="节点以及索引的当前状态"></p> <blockquote><p>​	 接着，进行下一轮 for 循环：</p> <p>1、source[i] 是否等于 -1？很明显，此时索引 i 的值为 2，source[2] 的值等于 1，因此节点 p-2 不是全新的节点，不需要挂载它，进行下一步的判断。</p> <p>2、i !== seq[s] 是否成立？此时索引 i 的值为 2，索引 s 的值为 1。因此 2 !== seq[1] 成立，节点 p-2 所对应的真实 DOM 需要移动。</p></blockquote> <p>​	在第二步中，我们知道了节点 p-2 所对应的真实 DOM 应该移动：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>moved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token function">lis</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>

   <span class="token comment">// s 指向最长递增子序列的最后一个元素</span>
   <span class="token keyword">let</span> s <span class="token operator">=</span> seq<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token keyword">let</span> i <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 省略部分代码</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> seq<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 说明该节点需要移动</span>
       <span class="token comment">// 该节点在新的一组子节点中的真实位置索引</span>
       <span class="token keyword">const</span> pos <span class="token operator">=</span> i <span class="token operator">+</span> newStart
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>
       <span class="token comment">// 该节点的下一个节点的位置索引</span>
       <span class="token keyword">const</span> nextPos <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span>
       <span class="token comment">// 锚点</span>
       <span class="token keyword">const</span> anchor <span class="token operator">=</span> nextPos <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length
         <span class="token operator">?</span> newChildren<span class="token punctuation">[</span>nextPos<span class="token punctuation">]</span><span class="token punctuation">.</span>el
         <span class="token operator">:</span> <span class="token keyword">null</span>
       <span class="token comment">// 移动</span>
       <span class="token function">insert</span><span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 当 i === seq[s] 时，说明该位置的节点不需要移动</span>
       <span class="token comment">// 并让 s 指向下一个位置</span>
       s<span class="token operator">--</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><blockquote><p>移动节点的实现思路类似于挂载全新的节点。不同点在于，移动节点是通过 insert 函数来完成的。</p></blockquote> <p>​	接着，进行下一轮的循环。此时索引 i 指向节点 p-4：</p> <p><img src="/vivien-blog/assets/img/image-20240911134444541.37e5dec8.png" alt="节点以及索引的当前状态"></p> <blockquote><p>​	更新过程仍然分为三个步骤：</p> <p>1、判断表达式 source[i] 的值是否等于 -1？很明显，此时索引 i 的值为 1，表达式 source[1] 的值等于 3，条件不成立。所以节点 p-4 不是全新的节点，不需要挂载它。接着进行下一步判断。</p> <p>2、判断表达式 i !== seq[s] 是否成立？此时索引 i 的值为 1，索引 s 的值为1。这时表达式 1 === seq[1] 为真，所以条件 i !== seq[s] 也不成立。</p> <p>3、由于第一步和第二步中的条件都不成立，所以代码会执行最终的 else 分支。这意味着，节点 p-4 所对应的真实 DOM 不需要移动，但我们仍然需要让索引 s的值递减，即 s--。</p> <p>​	经过三步判断之后，我们得出结论：节点 p-4 不需要移动。</p></blockquote> <p>​	于是进行下一轮循环，此时的状态如下：</p> <p><img src="/vivien-blog/assets/img/image-20240911134645284.9496bc25.png" alt="节点以及索引的当前状态"></p> <blockquote><p>​	此时索引 i 指向节点 p-3。我们继续进行三个步骤的判断：</p> <p>1、判断表达式 source[i] 的值是否等于 -1？很明显，此时索引 i 的值为 0，表 达式 source[0] 的值等于 2，所以节点 p-3 不是全新的节点，不需要挂载它，接着进行下一步判断。</p> <p>2、第二步：判断表达式 i !== seq[s] 是否成立？此时索引 i 的值为 0，索引 s 的值也为0。这时表达式 0 === seq[0] 为真，因此条件也不成立，最终将执行 else 分支的代码，也就是第三步。</p> <p>3、到了这里，意味着节点 p-3 所对应的真实 DOM 也不需要移动。</p> <p>​	在这一轮更新完成之后，循环将会停止，更新完成。</p></blockquote> <h3 id="求解给定序列的最长递增子序列"><a href="#求解给定序列的最长递增子序列" class="header-anchor">#</a> 求解给定序列的最长递增子序列</h3> <p>​	如下是用于求解给定序列的最长递增子序列的代码，取自 Vue.js 3：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">getSequence</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> p <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
   <span class="token keyword">let</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> c
   <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> arrI <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>arrI <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       j <span class="token operator">=</span> result<span class="token punctuation">[</span>result<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrI<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j
         result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
         <span class="token keyword">continue</span>
       <span class="token punctuation">}</span>
       u <span class="token operator">=</span> <span class="token number">0</span>
       v <span class="token operator">=</span> result<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>u <span class="token operator">&lt;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>u <span class="token operator">+</span> v<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>result<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrI<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           u <span class="token operator">=</span> c <span class="token operator">+</span> <span class="token number">1</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           v <span class="token operator">=</span> c
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>arrI <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>result<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">[</span>u <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
         <span class="token punctuation">}</span>
         result<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> i
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   u <span class="token operator">=</span> result<span class="token punctuation">.</span>length
   v <span class="token operator">=</span> result<span class="token punctuation">[</span>u <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>u<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     result<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> v
     v <span class="token operator">=</span> p<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> result
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><blockquote><p>注意,源码中 0 表示新增节点，所以上面代码是 !==0 表示跳过。前面的示例中是用 -1 表示新增节点。</p></blockquote> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>快速 Diff 算法在实测中性能最优。它借鉴了文本 Diff 中的预处理思路，先处理新旧两组子节点中相同的前置节点和相同的后置节点。</li> <li>当前置节点和后置节点全部处理完毕后，如果无法简单地通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构造出一个最长递增子序列。</li> <li>最长递增子序列所指向的节点即为不需要移动的节点。</li></ul> <table><thead><tr><th>算法</th> <th>描述</th></tr></thead> <tbody><tr><td>简单 Diff 算法</td> <td>当索引大于最大索引值，说明需要移动</td></tr> <tr><td>双端 Diff 算法</td> <td>两端指针双双比较，key 相同时需要移动，或者 patch</td></tr> <tr><td>快速 Diff 算法</td> <td>在简单 Diff 的基础上，先处理相同的前置和后置节点，对于中间的节点得到最长递增子序列，子序列指向的节点即为不需要移动的节点。</td></tr></tbody></table> <blockquote><p>核心概念都是，先找到需要移动的节点，再解决怎样移动的问题，最后再处理新增删除，或其他边界情况。</p> <p>Vue2：双端 Diff 算法，新旧虚拟 DOM 进行头头、尾尾、旧头新尾、新头旧尾循环对比。</p> <p>Vue3：快速 Diff 算法，先预处理相同头尾，再计算中间部分的最长递增子序列用于 DOM 移动与修改。</p></blockquote></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/11 06:21:35</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="prev">
          10.双端Diff算法
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html">
          12.组件的实现原理
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#相同的前置元素和后置元素" class="sidebar-link reco-side-相同的前置元素和后置元素" data-v-9f22dc18>相同的前置元素和后置元素</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#前置节点" class="sidebar-link reco-side-前置节点" data-v-9f22dc18>前置节点</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#后置节点" class="sidebar-link reco-side-后置节点" data-v-9f22dc18>后置节点</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#新增节点" class="sidebar-link reco-side-新增节点" data-v-9f22dc18>新增节点</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#删除节点" class="sidebar-link reco-side-删除节点" data-v-9f22dc18>删除节点</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#判断是否需要进行-dom-移动操作" class="sidebar-link reco-side-判断是否需要进行-dom-移动操作" data-v-9f22dc18>判断是否需要进行 DOM 移动操作</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#如何移动元素" class="sidebar-link reco-side-如何移动元素" data-v-9f22dc18>如何移动元素</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#求解给定序列的最长递增子序列" class="sidebar-link reco-side-求解给定序列的最长递增子序列" data-v-9f22dc18>求解给定序列的最长递增子序列</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/11.%E5%BF%AB%E9%80%9FDiff%E7%AE%97%E6%B3%95.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.1b7b4fd5.js" defer></script><script src="/vivien-blog/assets/js/7.210383a7.js" defer></script><script src="/vivien-blog/assets/js/2.00d63d32.js" defer></script><script src="/vivien-blog/assets/js/1.96251043.js" defer></script><script src="/vivien-blog/assets/js/16.0fcf1058.js" defer></script>
  </body>
</html>
