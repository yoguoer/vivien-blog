<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>12.组件的实现原理 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.7738f530.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.464cc3ea.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.db1c35d8.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.88465532.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/121.fa7bfc4d.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.b772a431.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.62f13f40.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.262eebca.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.d15aec8d.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.3a4e8685.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.d8ef8d42.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.9c62ca3a.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.79799973.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3d688fa2.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.189a67fe.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.815085b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.d29dfabd.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.2ea8565d.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.3253031a.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.5feade57.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.819e6082.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.55297748.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.44b80f99.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.36461d4e.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.99af4d82.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.153f661c.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.df0b310d.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.4edb84f7.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.f1a5a11a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.1580535f.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.d2a29b85.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.b5be33e2.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.52480968.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.94af5ec3.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.8dca7f6c.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.c753d508.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.bf5216d1.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.9bb718ff.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.dd72318d.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.025cbb0a.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.7cbb5ff9.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.099aee64.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.c1d6e501.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.2b108764.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.e9bcad68.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.4582846d.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.169fb77c.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.aea2c93b.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.1866cbba.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.9ab9834f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.d71bb6eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.383ae212.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.f47e5265.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.d6652043.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.542b86e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.d25326b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e55f1610.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.2fd2d217.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.0d01bb51.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.18330ce2.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.f63999dd.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.9c63570f.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.7e649a94.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.5cd0ff12.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.1380315b.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.9a8bc83a.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.dfc3dc84.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.9f0491a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.56c7442b.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.572118ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.a2889e9a.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.94b92181.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.546a376b.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.6e1296f2.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.294c2556.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.5c64fcbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.f38ecb23.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.a7eaecbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.566ea0ad.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.03726d99.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.44e0a209.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.196020b0.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.cb2a2b01.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.018c7e56.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.0b005dfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.7a746c54.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.9e0d4857.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.16f48649.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.54c9caee.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.932acfca.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.a26eda75.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.d6106a7d.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.0e84a519.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.04cd2610.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f99c6d3c.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.72422da4.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.31dada36.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.d8b153a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.ddda63c0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.6966e143.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.a2fbe5d8.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.48bb5c9c.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.debb65a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.0066da58.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.43f489ac.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.95333a2b.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.51dafac2.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6fe5ff10.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.03ddba74.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.1baba6a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.2f8bb846.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.b5976902.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.f64041b6.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.64d19acb.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.f89c690f.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.192fa399.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.ddf16957.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.25fbc2b8.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.4fea84f6.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.e5c8d0d5.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.201c7a26.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.4accbe01.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.a921fb5d.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.c4b024d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.872418d3.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.ae5ba79d.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.043c5690.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.fd1da6ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.a0dec3a9.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.15551b0c.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="active sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>12.组件的实现原理</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">12.组件的实现原理</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/12</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><p>​	渲染器主要负责将虚拟 DOM渲染为真实 DOM，我们只需要使用虚拟 DOM 来描述最终呈现的内容即可。但当我们编写比较复杂的页面时，用来描述页面结构的虚拟 DOM 的代码量会变得越来越多，或者说页面模板会变得越来越大。这时，我们就需要组件化的能力。</p> <p>​	有了组件，我们就可以将一个大的页面拆分为多个部分，每一个部分都可以作为单独的组件，这些组件共同组成完整的页面。组件化的实现同样需要渲染器的支持。</p> <h2 id="渲染组件"><a href="#渲染组件" class="header-anchor">#</a> 渲染组件</h2> <p>​	从用户的角度来看，一个有状态组件就是一个选项对象：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// MyComponent 是一个组件，它的值是一个选项对象</span>
 <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   name<span class="token operator">:</span> <span class="token string">'MyComponent'</span><span class="token punctuation">,</span>
   <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	但是，如果从渲染器的内部实现来看，一个组件则是一个特殊类型的虚拟 DOM 节点。例如，为了描述普通标签，我们用虚拟节点的 vnode.type 属性来存储标签名称：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 该 vnode 用来描述普通标签</span>
 <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'div'</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	为了描述片段，我们让虚拟节点的 vnode.type 属性的值为 Fragment，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 该 vnode 用来描述片段</span>
 <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> Fragment
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	为了描述文本，我们让虚拟节点的 vnode.type 属性的值为 Text，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 该 vnode 用来描述文本节点</span>
 <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> Text
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	渲染器的 patch 函数证明了上述内容，如下是我们在第三篇中实现的 patch 函数的代码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">&amp;&amp;</span> n1<span class="token punctuation">.</span>type <span class="token operator">!==</span> n2<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">unmount</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>
     n1 <span class="token operator">=</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> n2

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 作为普通元素处理</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 作为文本节点处理</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 作为片段处理</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><blockquote><p>可以看到，渲染器会使用虚拟节点的 <strong>type 属性</strong>来区分其类型。对于不同类型的节点，需要采用不同的处理方法来完成挂载和更新。</p></blockquote> <p>​	实际上，对于组件来说也是一样的。为了使用虚拟节点来描述组件，我们可以用虚拟节点的 vnode.type 属性来存储组件的选项对象，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 该 vnode 用来描述组件，type 属性存储组件的选项对象</span>
 <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	为了让渲染器能够处理组件类型的虚拟节点，我们还需要在 patch 函数中对组件类型的虚拟节点进行处理：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">&amp;&amp;</span> n1<span class="token punctuation">.</span>type <span class="token operator">!==</span> n2<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">unmount</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>
     n1 <span class="token operator">=</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>
     
   <span class="token keyword">const</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> n2

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 作为普通元素处理</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 作为文本节点处理</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 作为片段处理</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// vnode.type 的值是选项对象，作为组件来处理</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 挂载组件</span>
       <span class="token function">mountComponent</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 更新组件</span>
       <span class="token function">patchComponent</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><blockquote><p>新增了一个 else if 分支，用来处理虚拟节点的 <strong>vnode.type 属性值为对象</strong>的情况，即将该虚拟节点<strong>作为组件的描述来看待</strong>，并调用 mountComponent 和 patchComponent 函数来完成组件的挂载和更新。</p></blockquote> <p>​	渲染器有能力处理组件后，下一步我们要做的是，<strong>设计组件在用户层面的接口</strong>。这包括：用户应该如何编写组件？组件的选项对象必须包含哪些内容？以及组件拥有哪些能力？等等。</p> <p>​	实际上，<strong>组件本身是对页面内容的封装，它用来描述页面内容的一部分</strong>。因此，一个组件<strong>必须包含</strong>一个渲染函数，即 <strong>render 函数</strong>，并且渲染函数的返回值应该是虚拟 DOM。换句话说，组件的渲染函数就是用来描述组件所渲染内容的接口。例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token comment">// 组件名称，可选</span>
   name<span class="token operator">:</span> <span class="token string">'MyComponent'</span><span class="token punctuation">,</span>
   <span class="token comment">// 组件的渲染函数，其返回值必须为虚拟 DOM</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 返回虚拟 DOM</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">我是文本内容</span><span class="token template-punctuation string">`</span></span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​	这是一个最简单的组件示例。有了基本的组件结构之后，渲染器就可以完成组件的渲染：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用来描述组件的 VNode 对象，type 属性值为组件的选项对象</span>
 <span class="token keyword">const</span> CompVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent
 <span class="token punctuation">}</span>
 <span class="token comment">// 调用渲染器来渲染组件</span>
 renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>CompVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	渲染器中真正完成组件渲染任务的是 mountComponent 函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 通过 vnode 获取组件的选项对象，即 vnode.type</span>
   <span class="token class-name"><span class="token keyword">const</span></span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token comment">// 获取组件的渲染函数 render</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions
   <span class="token comment">// 执行渲染函数，获取组件要渲染的内容，即 render 函数返回的虚拟 DOM</span>
   <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 最后调用 patch 函数来挂载组件所描述的内容，即 subTree</span>
   <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这样，我们就实现了最基本的组件化方案。</p> <div class="custom-block tip"><p class="title"></p><p>以对象来描述组件，组件对象要渲染的内容写在 render 方法里，render 方法返回虚拟 DOM 给 renderer 渲染器渲染。</p> <p>利用 mountComponent 和 patchComponent 来更新组件。</p></div><h2 id="组件状态与自更新"><a href="#组件状态与自更新" class="header-anchor">#</a> 组件状态与自更新</h2> <p>​	前面我们完成了组件的初始渲染。接下来，我们尝试为组件设计自身的状态：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   name<span class="token operator">:</span> <span class="token string">'MyComponent'</span><span class="token punctuation">,</span>
   <span class="token comment">// 用 data 函数来定义组件自身的状态</span>
   <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span>
       foo<span class="token operator">:</span> <span class="token string">'hello world'</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">foo 的值是: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token comment">// 在渲染函数内使用组件状态</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>约定用户必须使用 data 函数来定义组件自身的状态，同时可以在渲染函数中通过 this 访问由 data 函数返回的状态数据。（数据是组件的状态）</p></blockquote> <p>​	下面的代码实现了组件自身状态的初始化：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token class-name"><span class="token keyword">const</span></span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   <span class="token comment">// 调用 data 函数得到原始数据，并调用 reactive 函数将其包装为响应式数据</span>
   <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 render 函数时，将其 this 设置为 state，</span>
   <span class="token comment">// 从而 render 函数内部可以通过 this 访问组件自身状态数据</span>
   <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
   <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>​	实现组件自身状态的初始化需要两个步骤：</p> <ul><li>通过组件的选项对象取得 data 函数并执行，然后调用 reactive 函数将 data 函数返回的状态包装为响应式数据；（实现数据的响应式状态）</li> <li>在调用 render 函数时，将其 this 的指向设置为响应式数据 state，同时将 state 作为 render 函数的第一个参数传递。（用 call 将 this 设为响应处理过后的 data，所以我们才可以在 <code>&lt;template&gt;</code> 中用 this.xxx 取得 data 中的数据。）</li></ul> <p>经过上述两步工作后，我们就实现了对组件自身状态的支持，以及在渲染函数内访问组件自身状态的能力。</p></blockquote> <p>​	当组件自身状态发生变化时，我们需要有能力触发组件更新，即<strong>组件的自更新</strong>。为此，我们需要将整个渲染任务包装到一个 effect 中：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token class-name"><span class="token keyword">const</span></span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token comment">// 将组件的 render 函数调用包装到 effect 内</span>
   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
     <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>这样，一旦组件自身的响应式数据发生变化，组件就会自动重新执行渲染函数，从而完成更新。</p></blockquote> <p>​	但是，由于 effect 的执行是同步的，因此当响应式数据发生变化时，与之关联的副作用函数会同步执行。换句话说，如果<strong>多次修改</strong>响应式数据的值，将会导致渲染函数<strong>执行多次</strong>，这实际上是没有必要的。</p> <p>​	因此，我们需要设计一个机制，以使得无论对响应式数据进行<strong>多少次修改</strong>，副作用函数都只会重新<strong>执行一次</strong>。</p> <p>​	为此，我们需要实现一个<strong>调度器</strong>，当副作用函数需要重新执行时，我们不会立即执行它，而是将它<strong>缓冲</strong>到一个微任务队列中，等到执行栈清空后，再将它从微任务队列中取出并执行。</p> <p>​	有了<strong>缓存机制</strong>，我们就有机会对任务进行去重，从而<strong>避免多次执行</strong>副作用函数带来的性能开销。</p> <p>​	具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 任务缓存队列，用一个 Set 数据结构来表示，这样就可以自动对任务进行去重</span>
 <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token comment">// 一个标志，代表是否正在刷新任务队列</span>
 <span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
 <span class="token comment">// 创建一个立即 resolve 的 Promise 实例</span>
 <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

 <span class="token comment">// 调度器的主要函数，用来将一个任务添加到缓冲队列中，并开始刷新队列</span>
 <span class="token keyword">function</span> <span class="token function">queueJob</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 将 job 添加到任务队列 queue 中</span>
   queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
   <span class="token comment">// 如果还没有开始刷新队列，则刷新之</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFlushing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将该标志设置为 true 以避免重复刷新</span>
     isFlushing <span class="token operator">=</span> <span class="token boolean">true</span>
     <span class="token comment">// 在微任务中刷新缓冲队列</span>
     p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token keyword">try</span> <span class="token punctuation">{</span>
         <span class="token comment">// 执行任务队列中的任务</span>
         queue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>job <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
         <span class="token comment">// 重置状态</span>
         isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
         queue<span class="token punctuation">.</span>clear <span class="token operator">=</span> <span class="token number">0</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>上面是调度器的最小实现，<strong>本质上利用了微任务的异步执行机制，实现对副作用函数的缓冲</strong>。其中 queueJob 函数是调度器最主要的函数，用来将一个任务或副作用函数添加到缓冲队列中，并开始刷新队列。</p> <p>解析：因为 effect 的执行是同步的，queueJob 作为调度器函数时，会收集副作用函数，一开始因为 isFlushing 是 false，所以会先将 p.then 放进微任务队列中，在栈被清空前，如果期间都有触发副作用函数 effect，那么都会被收集到 queue 中，之后等到所有的同步任务执行完后，再将 p.then 从微任务中取出执行。</p> <p>（Vue 对响应式数据使用异步队列来实现只执行一次，优化性能。）</p></blockquote> <p>​	有了 queueJob 函数之后，我们可以在创建渲染副作用时使用它：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token class-name"><span class="token keyword">const</span></span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
     <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token comment">// 指定该副作用函数的调度器为 queueJob 即可</span>
     scheduler<span class="token operator">:</span> queueJob
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>这样，当响应式数据发生变化时，副作用函数不会立即同步执行，而是会被 queueJob 函数调度，最后在一个微任务中执行。</p> <p>调度函数也就是利用微任务异步执行，实现对副作用函数的缓冲，等待栈清空，取出执行。</p></blockquote> <p>​	不过，上面这段代码存在缺陷。可以看到，我们在 effect 函数内调用 patch 函数完成渲染时，第一个参数总是 null。这意味着，每次更新发生时都会进行全新的挂载，而不会打补丁，这是不正确的。</p> <p>​	正确的做法是：<strong>每次更新时，都拿新的 subTree 与上一次组件所渲染的 subTree 进行打补丁</strong>。为此，我们需要实现组件实例，用它来维护组件整个生命周期的状态，这样渲染器才能够在正确的时机执行合适的操作。</p> <h2 id="组件实例与组件的生命周期"><a href="#组件实例与组件的生命周期" class="header-anchor">#</a> 组件实例与组件的生命周期</h2> <p>​	<strong>组件实例本质上就是一个状态集合（或一个对象）</strong>，它维护着组件运行过程中的所有信息，例如注册到组件的生命周期函数、组件渲染的子树（subTree）、组件是否已经被挂载、组件自身的状态（data），等等。</p> <p>​	为了解决前面关于组件更新的问题，我们需要引入组件实例的概念，以及与之相关的状态信息：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token class-name"><span class="token keyword">const</span></span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token comment">// 定义组件实例，一个组件实例本质上就是一个对象，它包含与组件有关的状态信息</span>
   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 组件自身的状态数据，即 data</span>
     state<span class="token punctuation">,</span>
     <span class="token comment">// 一个布尔值，用来表示组件是否已经被挂载，初始值为 false</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     <span class="token comment">// 组件所渲染的内容，即子树（subTree）</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 将组件实例设置到 vnode 上，用于后续更新</span>
   vnode<span class="token punctuation">.</span>component <span class="token operator">=</span> instance

   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用组件的渲染函数，获得子树</span>
     <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
     <span class="token comment">// 检查组件是否已经被挂载</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">.</span>isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 初次挂载，调用 patch 函数第一个参数传递 null</span>
       <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
       <span class="token comment">// 重点：将组件实例的 isMounted 设置为 true，这样当更新发生时就不会再次进行挂载操作，</span>
       <span class="token comment">// 而是会执行更新</span>
       instance<span class="token punctuation">.</span>isMounted <span class="token operator">=</span> <span class="token boolean">true</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 当 isMounted 为 true 时，说明组件已经被挂载，只需要完成自更新即可，</span>
       <span class="token comment">// 所以在调用 patch 函数时，第一个参数为组件上一次渲染的子树，</span>
       <span class="token comment">// 意思是，使用新的子树与上一次渲染的子树进行打补丁操作</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>subTree<span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 更新组件实例的子树</span>
     instance<span class="token punctuation">.</span>subTree <span class="token operator">=</span> subTree
   <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> scheduler<span class="token operator">:</span> queueJob <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><blockquote><p>使用一个对象来表示组件实例，该对象有三个属性：</p> <ul><li>state：组件自身的状态数据，即 data。</li> <li>isMounted：一个布尔值，用来表示组件是否被挂载。</li> <li>subTree：存储组件的渲染函数返回的虚拟 DOM，即组件的子树（subTree）。</li></ul></blockquote> <p>​	实际上，我们可以在需要的时候，任意地在组件实例 instance 上<strong>添加需要的属性</strong>。但需要注意的是，我们应该尽可能保持组件实例轻量，以减少内存占用。</p> <p>​	在上面的实现中，组件实例的 instance.isMounted 属性可以用来区分组件的挂载和更新。因此，我们可以在合适的时机调用组件对应的生命周期钩子：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token comment">// 从组件选项对象中取得组件的生命周期函数</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data<span class="token punctuation">,</span> beforeCreate<span class="token punctuation">,</span> created<span class="token punctuation">,</span> beforeMount<span class="token punctuation">,</span> mounted<span class="token punctuation">,</span> beforeUpdate<span class="token punctuation">,</span> updated <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   <span class="token comment">// 在这里调用 beforeCreate 钩子</span>
   beforeCreate <span class="token operator">&amp;&amp;</span> <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>
   vnode<span class="token punctuation">.</span>component <span class="token operator">=</span> instance

   <span class="token comment">// 在这里调用 created 钩子</span>
   created <span class="token operator">&amp;&amp;</span> <span class="token function">created</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>

   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> state<span class="token punctuation">)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">.</span>isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 在这里调用 beforeMount 钩子</span>
       beforeMount <span class="token operator">&amp;&amp;</span> <span class="token function">beforeMount</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
       <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
       instance<span class="token punctuation">.</span>isMounted <span class="token operator">=</span> <span class="token boolean">true</span>
       <span class="token comment">// 在这里调用 mounted 钩子</span>
       mounted <span class="token operator">&amp;&amp;</span> <span class="token function">mounted</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 在这里调用 beforeUpdate 钩子</span>
       beforeUpdate <span class="token operator">&amp;&amp;</span> <span class="token function">beforeUpdate</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>subTree<span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
       <span class="token comment">// 在这里调用 updated 钩子</span>
       updated <span class="token operator">&amp;&amp;</span> <span class="token function">updated</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     instance<span class="token punctuation">.</span>subTree <span class="token operator">=</span> subTree
   <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> scheduler<span class="token operator">:</span> queueJob <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>​	首先从组件的选项对象中取得注册到组件上的生命周期函数，然后在合适的时机调用它们，这其实就是组件生命周期的实现原理。</p> <p>​	但实际上，由于可能存在多个同样的组件生命周期钩子，例如来自 mixins 中的生命周期钩子函数，因此我们通常需要将组件生命周期钩子序列化为一个数组，但核心原理不变。</p> <blockquote><p>1、beforeCreate -&gt;将 data 变成响应式数据、新建组件实例 instance -&gt; created -&gt;进入2 或 3</p> <p>2、如果是首次挂载 -&gt;beforeMount -&gt;挂载节点 -&gt;mounted</p> <p>3、如果不是首次挂载 -&gt;beforeUpdate&gt;更新节点 -&gt;updated</p> <p>mountComponent 函数内部代码就是一个组件的执行流程：</p> <p>1、获取组件选项；</p> <p>2、从组件选项获取个选项：</p> <p>3、执行 beforeCreate 生命周期；</p> <p>4、reactive() 初始化 data 和 props；</p> <p>5、创建实例化；</p> <p>6、执行 created 生命周期；</p> <p>7、挂载，执行 beforeMount 生命周期；</p> <p>8、执行 patch 挂载 DOM；</p> <p>9、执行 mounted 生命周期；</p> <p>10、更新，执行 beforeUpdate 生命周期；</p> <p>11、执行 patch 更新 DOM，执行 updated 生命周期。</p></blockquote> <h2 id="props-与组件的被动更新"><a href="#props-与组件的被动更新" class="header-anchor">#</a> props 与组件的被动更新</h2> <blockquote><p>组件对象的 props 转换成虚拟 DOM 之后也是 VNode 对象的 props 属性，跟 HTML 标签的属性或 DOM 的 property 属性一样，转换成 VNode 之后都会被存储到 VNode 的 props 属性中。</p></blockquote> <p>​	在虚拟 DOM 层面，组件的 props 与普通 HTML 标签的属性差别不大。假设我们有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>A Big Title<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:other</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>val<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这段模板对应的虚拟 DOM 是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     title<span class="token operator">:</span> <span class="token string">'A big Title'</span><span class="token punctuation">,</span>
     other<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	可以看到，模板与虚拟 DOM 几乎是“同构”的。另外，在编写组件时，我们需要显式地指定组件会接收哪些 props 数据：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   name<span class="token operator">:</span> <span class="token string">'MyComponent'</span><span class="token punctuation">,</span>
   <span class="token comment">// 组件接收名为 title 的 props，并且该 props 的类型为 String</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     title<span class="token operator">:</span> String
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>title<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token comment">// 访问 props 数据</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>所以，对于一个组件来说，有两部分关于 props 的内容我们需要关心：</p> <ul><li>为组件<strong>传递的</strong> props 数据，即组件的 vnode.props 对象；（实参）</li> <li>组件选项对象中<strong>定义的</strong> props 选项，即 MyComponent.props 对象。（形参）</li></ul></blockquote> <p>​	我们需要结合这两个选项来解析出组件在渲染时需要用到的 props 数据:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token comment">// 从组件选项对象中取出 props 定义，即 propsOption</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data<span class="token punctuation">,</span> props<span class="token operator">:</span> propsOption <span class="token comment">/* 其他省略 */</span> <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   beforeCreate <span class="token operator">&amp;&amp;</span> <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
   <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 resolveProps 函数解析出最终的 props 数据与 attrs 数据</span>
   <span class="token keyword">const</span> <span class="token punctuation">[</span>props<span class="token punctuation">,</span> attrs<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">resolveProps</span><span class="token punctuation">(</span>propsOption<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     <span class="token comment">// 将解析出的 props 数据包装为 shallowReactive 并定义到组件实例上</span>
     props<span class="token operator">:</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>
   vnode<span class="token punctuation">.</span>component <span class="token operator">=</span> instance

   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>

 <span class="token comment">// resolveProps 函数用于解析组件 props 和 attrs 数据</span>
 <span class="token keyword">function</span> <span class="token function">resolveProps</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> propsData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">const</span> attrs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token comment">// 遍历为组件传递的 props 数据</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> propsData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果为组件传递的 props 数据在组件自身的 props 选项中有定义，则将其视为合法的 props</span>
       props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 否则将其作为 attrs</span>
       attrs<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 最后返回 props 与 attrs 数据</span>
   <span class="token keyword">return</span> <span class="token punctuation">[</span> props<span class="token punctuation">,</span> attrs <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><blockquote><p>​	将组件选项中定义的 MyComponent.props 对象和为组件传递的 vnode.props 对象相结合，最终解析出组件在渲染时需要使用的 props 和 attrs数据。这里需要注意两点:</p> <ul><li>在 Vue.js 3 中，没有定义在 MyComponent.props 选项中的 props 数据将存储到attrs 对象中。（Vue3 中子组件未定义的 props 存放在 $attrs 中）</li> <li>上述实现中没有包含默认值、类型校验等内容的处理。实际上，这些内容也都是围绕MyComponent.props 以及 vnode.props 这两个对象展开的，实现起来并不复杂。</li></ul></blockquote> <p>​	处理完 props 数据后，我们再来看关于 props 数据变化的问题。props 本质上是父组件的数据，当 props 发生变化时，会触发父组件重新渲染。假设父组件的模板如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>title<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	其中，响应式数据 title 的初始值为字符串 &quot;A big Title&quot;，因此首次渲染时，父组件的虚拟 DOM 为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 父组件要渲染的内容</span>
 <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     title<span class="token operator">:</span> <span class="token string">'A Big Title'</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>当响应式数据 title 发生变化时，父组件的渲染函数会重新执行。</p></blockquote> <p>​	假设 title 的值变为字符串 &quot;A Small Title&quot;，那么新产生的虚拟 DOM 为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 父组件要渲染的内容</span>
 <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     title<span class="token operator">:</span> <span class="token string">'A Small Title'</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	接着，父组件会进行自更新。在更新过程中，渲染器发现父组件的 subTree 包含组件类型的虚拟节点，所以会调用 patchComponent 函数完成子组件的更新：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">&amp;&amp;</span> n1<span class="token punctuation">.</span>type <span class="token operator">!==</span> n2<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">unmount</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span>
     n1 <span class="token operator">=</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> n2

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// vnode.type 的值是选项对象，作为组件来处理</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">mountComponent</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 更新组件</span>
       <span class="token function">patchComponent</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p>其中，patchComponent 函数用来完成子组件的更新。我们把由父组件自更新所引起的子组件更新叫作子组件的被动更新。</p></blockquote> <p>​	当子组件发生被动更新时，我们需要做的是：</p> <ul><li>检测子组件是否真的需要更新，因为子组件的 props 可能是不变的；</li> <li>如果需要更新，则更新子组件的 props、slots 等内容。</li></ul> <p>​	patchComponent 函数的具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchComponent</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 获取组件实例，即 n1.component，同时让新的组件虚拟节点 n2.component 也指向组件实例</span>
   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>component <span class="token operator">=</span> n1<span class="token punctuation">.</span>component<span class="token punctuation">)</span>
   <span class="token comment">// 获取当前的 props 数据</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> instance
   <span class="token comment">// 调用 hasPropsChanged 检测为子组件传递的 props 是否发生变化，如果没有变化，则不需要更新</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasPropsChanged</span><span class="token punctuation">(</span>n1<span class="token punctuation">.</span>props<span class="token punctuation">,</span> n2<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用 resolveProps 函数重新获取 props 数据</span>
     <span class="token keyword">const</span> <span class="token punctuation">[</span> nextProps <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">resolveProps</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>type<span class="token punctuation">.</span>props<span class="token punctuation">,</span> n2<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
     <span class="token comment">// 更新 props</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> nextProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       props<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nextProps<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 删除不存在的 props</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>k <span class="token keyword">in</span> nextProps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">delete</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">hasPropsChanged</span><span class="token punctuation">(</span>
   prevProps<span class="token punctuation">,</span>
   nextProps
 <span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> nextKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">)</span>
   <span class="token comment">// 如果新旧 props 的数量变了，则说明有变化</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>nextKeys<span class="token punctuation">.</span>length <span class="token operator">!==</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
     <span class="token comment">// 只有</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nextKeys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> key <span class="token operator">=</span> nextKeys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token comment">// 有不相等的 props，则说明有变化</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> prevProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token boolean">false</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><blockquote><p>​	上面是组件被动更新的最小实现，有两点需要注意：</p> <ul><li>需要将组件实例<strong>添加到新的组件 vnode 对象上</strong>，即 n2.component = n1.component，否则下次更新时将无法取得组件实例；</li> <li>instance.props 对象本身是<strong>浅响应</strong>的（即 shallowReactive）。因此，在更新组件的props 时，只需要设置 instance.props 对象下的属性值即可触发组件重新渲染。</li></ul></blockquote> <p>​	在上面的实现中，我们没有处理 attrs 与 slots 的更新。attrs 的更新本质上与更新props 的原理相似。实际上，要完善地实现 Vue.js 中的 props 机制，需要编写大量边界代码。但本质上来说，其原理都是根据组件的 props 选项定义以及为组件传递的 props 数据来处理的。</p> <p>​	由于 props 数据与组件自身的状态数据都需要暴露到渲染函数中，并使得渲染函数能够通过 this 访问它们，因此我们需要封装一个渲染上下文对象（使得可以通过 this 寻找它们）：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     props<span class="token operator">:</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   vnode<span class="token punctuation">.</span>component <span class="token operator">=</span> instance

   <span class="token comment">// 创建渲染上下文对象，本质上是组件实例的代理</span>
   <span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 取得组件自身状态与 props 数据</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> t
       <span class="token comment">// 先尝试读取自身状态数据</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> state<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果组件自身没有该数据，则尝试从 props 中读取</span>
         <span class="token keyword">return</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'不存在'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token function">set</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> t
       <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         state<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Attempting to mutate prop &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;. Props are readonly.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'不存在'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token comment">// 生命周期函数调用时要绑定渲染上下文对象</span>
   created <span class="token operator">&amp;&amp;</span> <span class="token function">created</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span>

   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><blockquote><p>为组件实例创建了一个代理对象，该对象即渲染上下文对象。它的意义在于拦截数据状态的读取和设置操作，每当在渲染函数或生命周期钩子中通过 this 来读取数据时，都会优先从组件的自身状态中读取，如果组件本身并没有对应的数据，则再从 props 数据中读取。最后我们将渲染上下文作为渲染函数以及生命周期钩子的 this 值即可。</p> <p>proxy 代理组件实例，优先尝试读取 state，如果找不到，再从 props 中读取。</p></blockquote> <p>​	实际上，除了组件自身的数据以及 props 数据之外，完整的组件还包含 methods、computed 等选项中定义的数据和方法，这些内容都应该在渲染上下文对象中处理。</p> <h2 id="setup-函数的作用与实现"><a href="#setup-函数的作用与实现" class="header-anchor">#</a> setup 函数的作用与实现</h2> <p>​	组件的 setup 函数是 Vue.js 3 新增的组件选项，它有别于 Vue.js 2 中存在的其他组件选项。这是因为 <strong>setup 函数主要用于配合组合式 API</strong>，为用户提供一个地方，用于建立组合逻辑、创建响应式数据、创建通用函数、注册生命周期钩子等能力。</p> <p>​	在组件的整个生命周期中，setup 函数<strong>只会在被挂载时执行一次</strong>，它的返回值可以有两种情况。</p> <p>1、返回一个函数，该函数将作为组件的 render 函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> Comp <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// setup 函数可以返回一个函数，该函数将作为组件的渲染函数</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>这种方式常用于组件不是以模板来表达其渲染内容的情况。如果组件以模板来表达其渲染的内容，那么 setup 函数不可以再返回函数，否则会与模板编译生成的渲染函数产生冲突。</p></blockquote> <p>2、返回一个对象，该对象中包含的数据将暴露给模板使用：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> Comp <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
     <span class="token comment">// 返回一个对象，对象中的数据会暴露到渲染函数中</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span>
       count
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 通过 this 可以访问 setup 暴露出来的响应式数据</span>
     <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>可以看到，setup 函数暴露的数据可以在渲染函数中通过 this 来访问。</p></blockquote> <p>​	另外，setup 函数接收两个参数。第一个参数是 props 数据对象，第二个参数也是一个对象，通常称为 setupContext：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> Comp <span class="token operator">=</span> <span class="token punctuation">{</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     foo<span class="token operator">:</span> String
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token function">setup</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> setupContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     props<span class="token punctuation">.</span>foo <span class="token comment">// 访问传入的 props 数据</span>
     <span class="token comment">// setupContext 中包含与组件接口相关的重要数据</span>
     <span class="token keyword">const</span> <span class="token punctuation">{</span> slots<span class="token punctuation">,</span> emit<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> expose <span class="token punctuation">}</span> <span class="token operator">=</span> setupContext
     <span class="token comment">// ...</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>我们可以通过 setup 函数的第一个参数取得外部为组件传递的 props 数据对象。同时，setup 函数还接收第二个参数 setupContext 对象，其中保存着与组件接口相关的数据和方法：</p> <ul><li>slots：组件接收到的插槽。</li> <li>emit：一个函数，用来发射自定义事件。</li> <li>attrs：当为组件传递 props 时，那些没有显式地声明为 props 的属性会存储到 attrs 对象中。</li> <li>expose：一个函数，用来显式地对外暴露组件数据。</li></ul></blockquote> <p>​	通常情况下，不建议将 setup 与 Vue.js 2 中其他组件选项混合使用，这样会带来语义和理解上的负担和维护困难。例如 data、watch、methods 等选项，我们称之为 “传统”组件选项。这是因为<strong>在 Vue.js 3 的场景下，更加提倡组合式 API，setup 函数就是为组合式 API 而生的</strong>。混用组合式 API的 setup 选项与“传统”组件选项并不是明智的选择，因为这样会带来语义和理解上的负担。</p> <p>​	接下来，我们就围绕上述这些能力来尝试实现 setup 组件选项：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token comment">// 从组件选项中取出 setup 函数</span>
   <span class="token keyword">let</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data<span class="token punctuation">,</span> setup<span class="token punctuation">,</span> <span class="token comment">/* 省略其他选项 */</span> <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   beforeCreate <span class="token operator">&amp;&amp;</span> <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> state <span class="token operator">=</span> data <span class="token operator">?</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token keyword">const</span> <span class="token punctuation">[</span>props<span class="token punctuation">,</span> attrs<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">resolveProps</span><span class="token punctuation">(</span>propsOption<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     props<span class="token operator">:</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
       subTree<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// setupContext，由于我们还没有讲解 emit 和 slots，所以暂时只需要 attrs</span>
   <span class="token keyword">const</span> setupContext <span class="token operator">=</span> <span class="token punctuation">{</span> attrs <span class="token punctuation">}</span>
   <span class="token comment">// 调用 setup 函数，将只读版本的 props 作为第一个参数传递，避免用户意外地修改 props 的值，</span>
   <span class="token comment">// 将 setupContext 作为第二个参数传递</span>
   <span class="token keyword">const</span> setupResult <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token function">shallowReadonly</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span> setupContext<span class="token punctuation">)</span>
   <span class="token comment">// setupState 用来存储由 setup 返回的数据</span>
   <span class="token keyword">let</span> setupState <span class="token operator">=</span> <span class="token keyword">null</span>
   <span class="token comment">// 如果 setup 函数的返回值是函数，则将其作为渲染函数</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setupResult <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 报告冲突</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>render<span class="token punctuation">)</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'setup 函数返回渲染函数，render 选项将被忽略'</span><span class="token punctuation">)</span>
     <span class="token comment">// 将 setupResult 作为渲染函数</span>
     render <span class="token operator">=</span> setupResult
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果 setup 的返回值不是函数，则作为数据状态赋值给 setupState</span>
     setupState <span class="token operator">=</span> setupResult
   <span class="token punctuation">}</span>

   vnode<span class="token punctuation">.</span>component <span class="token operator">=</span> instance

   <span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> t
       <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> state<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>setupState <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> setupState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 渲染上下文需要增加对 setupState 的支持</span>
         <span class="token keyword">return</span> setupState<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'不存在'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token function">set</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> t
       <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         state<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Attempting to mutate prop &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;. Props are readonly.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>setupState <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> setupState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 渲染上下文需要增加对 setupState 的支持</span>
         setupState<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'不存在'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><blockquote><p>上面是 setup 函数的最小实现，这里有以下几点需要注意：</p> <ul><li>setupContext 是一个对象，包含 attrs 等内容。</li> <li>通过检测 setup 函数的返回值类型来决定应该如何处理它。如果它的返回值为函数，则直接将其作为组件的渲染函数。注意，为了避免产生歧义，我们需要检查组件选项中是否已经存在 render 选项，如果存在，则需要打印警告信息。</li> <li>渲染上下文 renderContext 应该正确地处理 setupState，因为 setup 函数返回的数据状态也应该暴露到渲染环境。</li></ul></blockquote> <h2 id="组件事件与-emit-的实现"><a href="#组件事件与-emit-的实现" class="header-anchor">#</a> 组件事件与 emit 的实现</h2> <p>​	emit 用来发射组件的<strong>自定义事件</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   name<span class="token operator">:</span> <span class="token string">'MyComponent'</span><span class="token punctuation">,</span>
   <span class="token function">setup</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token punctuation">{</span> emit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 发射 change 事件，并传递给事件处理函数两个参数</span>
     <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'change'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token comment">// ...</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​	当使用该组件时，我们可以监听由 emit 函数发射的自定义事件：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handler<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这段模板对应的虚拟 DOM 是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> CompVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     onChange<span class="token operator">:</span> handler
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>自定义事件 change 被编译成名为 onChange 的属性，并存储在 props 数据对象中。这实际上是一种约定。作为框架设计者，也可以按照自己期望的方式来设计事件的编译结果。</p> <p>将函数作为属性传递和监听自定义事件无本质区别，但自定义事件需要预先声明 emits。</p></blockquote> <p>​	在具体的实现上，发射自定义事件的本质就是根据事件名称<strong>去 props 数据对象中寻找对应的事件处理函数</strong>并执行：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     props<span class="token operator">:</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 定义 emit 函数，它接收两个参数</span>
   <span class="token comment">// event: 事件名称</span>
   <span class="token comment">// payload: 传递给事件处理函数的参数</span>
   <span class="token keyword">function</span> <span class="token function">emit</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token operator">...</span>payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 根据约定对事件名称进行处理，例如 change --&gt; onChange</span>
     <span class="token keyword">const</span> eventName <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">on</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>event<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
     <span class="token comment">// 根据处理后的事件名称去 props 中寻找对应的事件处理函数</span>
     <span class="token keyword">const</span> handler <span class="token operator">=</span> instance<span class="token punctuation">.</span>props<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 调用事件处理函数并传递参数</span>
       <span class="token function">handler</span><span class="token punctuation">(</span><span class="token operator">...</span>payload<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'事件不存在'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 将 emit 函数添加到 setupContext 中，用户可以通过 setupContext 取得 emit 函数</span>
   <span class="token keyword">const</span> setupContext <span class="token operator">=</span> <span class="token punctuation">{</span> attrs<span class="token punctuation">,</span> emit <span class="token punctuation">}</span>

   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>整体实现并不复杂，只需要<strong>实现一个 emit 函数并将其添加到 setupContext 对象中</strong>，这样用户就可以通过 setupContext 取得 emit 函数了。</p> <p>另外，当 emit 函数被调用时，我们会根据约定对事件名称进行转换，以便能够在 props 数据对象中找到对应的事件处理函数。</p> <p>最后，调用事件处理函数并透传参数即可。</p></blockquote> <p>​	注意，前面提到，任何没有显式地声明为 props 的属性都会存储到 attrs 中。换句话说，任何事件类型的 props，即 onXxx 类的属性，都不会出现在 props 中。</p> <p>​	这导致我们无法根据事件名称在 instance.props 中找到对应的事件处理函数。为了解决这个问题，我们需要在解析 props 数据的时候对事件类型的 props 做特殊处理：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">resolveProps</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> propsData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">const</span> attrs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> propsData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 以字符串 on 开头的 props，无论是否显式地声明，都将其添加到 props 数据中，而不是添加到 attrs 中</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> options <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'on'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       props<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       attrs<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> propsData<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> <span class="token punctuation">[</span> props<span class="token punctuation">,</span> attrs <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>处理方式很简单，通过检测 propsData 的 key 值来判断它是否以字符串 'on' 开头，如果是，则认为该属性是组件的自定义事件。这时，即使组件没有显式地将其声明为props，我们也将它添加到最终解析的 props 数据对象中，而不是添加到 attrs 对象中。</p></blockquote> <h2 id="插槽的工作原理与实现"><a href="#插槽的工作原理与实现" class="header-anchor">#</a> 插槽的工作原理与实现</h2> <p>​	顾名思义，组件的插槽指组件会<strong>预留一个槽位</strong>，该槽位具体要渲染的内容<strong>由用户插入</strong>，如下面给出的 MyComponent 组件的模板所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>header<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>body<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>footer<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	当在父组件中使用 <code>&lt;MyComponent&gt;</code> 组件时，可以根据插槽的名字来插入自定义的内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token operator">&lt;</span>MyComponent<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>template #header<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>我是标题<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>template #body<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>section<span class="token operator">&gt;</span>我是内容<span class="token operator">&lt;</span><span class="token operator">/</span>section<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span>template #footer<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>我是注脚<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>MyComponent<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​	上面这段父组件的模板会被编译成如下渲染函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 父组件的渲染函数</span>
 <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
     <span class="token comment">// 组件的 children 会被编译成一个对象</span>
     children<span class="token operator">:</span> <span class="token punctuation">{</span>
       <span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'我是标题'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'section'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'我是内容'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token function">footer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'我是注脚'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>可以看到，组件模板中的插槽内容会被编译为<strong>插槽函数</strong>，而插槽函数的返回值就是具体的<strong>插槽内容</strong>。</p> <p>解析：这是在父组件的 render 方法中，VNode 的 type 类型是组件对象 MyComponent，VNode 的 children 是父组件的插槽内容。</p></blockquote> <p>​	组件 MyComponent 的模板则会被编译为如下渲染函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// MyComponent 组件模板的编译结果</span>
 <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'header'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'body'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'footer'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span><span class="token function">footer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><p>可以看到，渲染插槽内容的过程，就是调用插槽函数并渲染由其返回的内容的过程。这与 React 中 render props 的概念非常相似。</p></blockquote> <p>​	在运行时的实现上，插槽则依赖于 setupContext 中的 slots 对象:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// 直接使用编译好的 vnode.children 对象作为 slots 对象即可</span>
   <span class="token keyword">const</span> slots <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

   <span class="token comment">// 将 slots 对象添加到 setupContext 中</span>
   <span class="token keyword">const</span> setupContext <span class="token operator">=</span> <span class="token punctuation">{</span> attrs<span class="token punctuation">,</span> emit<span class="token punctuation">,</span> slots <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>可以看到，最基本的 slots 的实现非常简单。只需要将编译好的 vnode.children 作为slots 对象，然后将 slots 对象添加到 setupContext 对象中。</p></blockquote> <p>​	为了在 render 函数内和生命周期钩子函数内能够通过 this.$slots 来访问插槽内容，我们还需要在 renderContext 中特殊对待 $slots 属性：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">const</span> slots <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     props<span class="token operator">:</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     <span class="token comment">// 将插槽添加到组件实例上</span>
     slots
   <span class="token punctuation">}</span>

   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props<span class="token punctuation">,</span> slots <span class="token punctuation">}</span> <span class="token operator">=</span> t
       <span class="token comment">// 当 k 的值为 $slots 时，直接返回组件实例上的 slots</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">===</span> <span class="token string">'$slots'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> slots

       <span class="token comment">// 省略部分代码</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token function">set</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 省略部分代码</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>对渲染上下文 renderContext 代理对象的 get 拦截函数做了特殊处理，当读取的键是 $slots 时，直接返回组件实例上的 slots 对象，这样用户就可以通过 this.$slots 来访问插槽内容了。</p></blockquote> <h2 id="注册生命周期"><a href="#注册生命周期" class="header-anchor">#</a> 注册生命周期</h2> <p>​	在 Vue.js 3 中，有一部分组合式 API 是用来注册生命周期钩子函数的，例如onMounted、onUpdated 等:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

 <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mounted 1'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token comment">// 可以注册多个</span>
     <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'mounted 2'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token comment">// ...</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>在 setup 函数中调用 onMounted 函数即可注册 mounted 生命周期钩子函数，并且可以通过多次调用 onMounted 函数来注册多个钩子函数，这些函数会在组件被挂载之后再执行。</p></blockquote> <p>​	这里的疑问在于，在 A 组件的 setup 函数中调用 onMounted 函数会将该钩子函数注册到 A 组件上；而在 B 组件的 setup 函数中调用 onMounted 函数会将钩子函数注册到 B 组件上，这是如何实现的呢？</p> <p>​	实际上，我们需要维护一个变量currentInstance，用它来存储当前组件实例，每当初始化组件并执行组件的 setup 函数之前，先将 currentInstance 设置为当前组件实例，再执行组件的 setup 函数，这样我们就可以通过 currentInstance 来获取当前正在被初始化的组件实例，从而将那些通过 onMounted 函数注册的钩子函数与组件实例进行关联。</p> <p>​	接下来我们着手实现。首先需要设计一个当前实例的维护方法:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 全局变量，存储当前正在被初始化的组件实例</span>
 <span class="token keyword">let</span> currentInstance <span class="token operator">=</span> <span class="token keyword">null</span>
 <span class="token comment">// 该方法接收组件实例作为参数，并将该实例设置为 currentInstance</span>
 <span class="token keyword">function</span> <span class="token function">setCurrentInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   currentInstance <span class="token operator">=</span> instance
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	有了 currentInstance 变量，以及用来设置该变量的 setCurrentInstance 函数之后，我们就可以着手修改 mounteComponent 函数了:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     props<span class="token operator">:</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     slots<span class="token punctuation">,</span>
     <span class="token comment">// 在组件实例中添加 mounted 数组，用来存储通过 onMounted 函数注册的生命周期钩子函数</span>
     mounted<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// setup</span>
   <span class="token keyword">const</span> setupContext <span class="token operator">=</span> <span class="token punctuation">{</span> attrs<span class="token punctuation">,</span> emit<span class="token punctuation">,</span> slots <span class="token punctuation">}</span>

   <span class="token comment">// 在调用 setup 函数之前，设置当前组件实例</span>
   <span class="token function">setCurrentInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
   <span class="token comment">// 执行 setup 函数</span>
   <span class="token keyword">const</span> setupResult <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token function">shallowReadonly</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span> setupContext<span class="token punctuation">)</span>
   <span class="token comment">// 在 setup 函数执行完毕之后，重置当前组件实例</span>
   <span class="token function">setCurrentInstance</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><blockquote><p>为了存储由 onMounted 函数注册的生命周期钩子，我们需要在组件实例对象上添加 instance.mounted 数组。</p> <p>之所以 instance.mounted 的数据类型是数组，是因为在 setup 函数中，**可以多次调用 **onMounted 函数来注册不同的生命周期函数，这些生命周期函数都会存储在 instance.mounted 数组中。</p></blockquote> <p>​	现在，组件实例的维护已经搞定了。接下来考虑 onMounted 函数本身的实现:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">onMounted</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>currentInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将生命周期函数添加到 instance.mounted 数组中</span>
     currentInstance<span class="token punctuation">.</span>mounted<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'onMounted 函数只能在 setup 中调用'</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>整体实现非常简单直观。只需要通过 currentInstance 取得当前组件实例，并将生命周期钩子函数添加到当前实例对象的 instance.mounted 数组中即可。</p> <p>另外，如果当前实例不存在，则说明用户没有在 setup 函数内调用 onMounted 函数，这是错误的用法，因此我们应该抛出错误及其原因。</p> <p>附：</p> <p>在 setup 中注册 hook，必须是同步的，因为注册的 compositionAPl 是注册到当前执行 setup 的组件对象实例中的，如果是异步的，那么异步任务会等到 setup 这个同步任务执行完毕之后才执行，这时候 currentInstance 已经被置为 null 了。</p> <p>而这时候执行再执行 onMounted 等 hook 时，在 hook 中需要使用到当前实例 currentInstance 来注册 hook，这时候 currentInstance 为 null 就会出现问题了。</p> <p>所以不能异步注册 hook，Vue 会发出警告。</p> <p>结论：无论是微任务还是定时器宏任务，异步注册 hook 都不行，微任务是在当前宏任务结束之前的时候执行，setup 已经执行完毕，currentInstance  为 null，已经不能给当前的组件实例注册 hook，定时器更加不行，是在下一次循环，当前栈清空之后才处理，所以等到执行 hook 的时候，currentInstance 也为 null，所以也注册不了 hook。</p></blockquote> <p>​	最后一步需要做的是，在合适的时机调用这些注册到 instance.mounted 数组中的生命周期钩子函数:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>

     <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">.</span>isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 省略部分代码</span>

         <span class="token comment">// 遍历 instance.mounted 数组并逐个执行即可</span>
         instance<span class="token punctuation">.</span>mounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span>mounted<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>hook <span class="token operator">=&gt;</span> <span class="token function">hook</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 省略部分代码</span>
       <span class="token punctuation">}</span>
       instance<span class="token punctuation">.</span>subTree <span class="token operator">=</span> subTree
     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
       scheduler<span class="token operator">:</span> queueJob
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>可以看到，我们只需要在合适的时机遍历 instance.mounted 数组，并逐个执行该数组内的生命周期钩子函数即可。</p></blockquote> <p>对于除 mounted 以外的生命周期钩子函数，其原理同上。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>使用虚拟节点的 vnode.type 属性来存储组件对象，渲染器根据虚拟节点的该属性的类型来判断它是否是组件。如果是组件，则渲染器会使用 mountComponent 和 patchComponent 来完成组件的挂载和更新。</li> <li>在组件挂载阶段，会为组件创建一个用于渲染其内容的副作用函数。该副作用函数会与组件自身的响应式数据建立响应联系。当组件自身的响应式数据发生变化时，会触发渲染副作用函数重新执行，即重新渲染。</li> <li>但由于默认情况下重新渲染是同步执行的，这导致无法对任务去重，因此在创建渲染副作用函数时，指定了自定义的调用器。该调度器的作用是，当组件自身的响应式数据发生变化时，将渲染副作用函数缓冲到微任务队列中。有了缓冲队列，我们即可实现对渲染任务的去重，从而避免无用的重新渲染所导致的额外性能开销。</li> <li>组件实例本质上是一个对象，包含了组件运行过程中的状态，例如组件是否挂载、组件自身的响应式数据，以及组件所渲染的内容（即 subtree）等。有了组件实例后，在渲染副作用函数内，我们就可以根据组件实例上的状态标识，来决定应该进行全新的挂载，还是应该打补丁。</li> <li>副作用自更新所引起的子组件更新叫作子组件的被动更新。</li> <li>渲染上下文（renderContext）实际上是组件实例的代理对象。在渲染函数内访问组件实例所暴露的数据都是通过该代理对象实现的。</li> <li>setup 函数是为了组合式 API 而生的，所以我们要避免将其与 Vue.js 2 中的“传统”组件选项混合使用。setup 函数的返回值可以是两种类型，如果返回函数，则将该函数作为组件的渲染函数；如果返回数据对象，则将该对象暴露到渲染上下文中。</li> <li>emit 函数包含在 setupContext 对象中，可以通过 emit 函数发射组件的自定义事件。通过 v-on 指令为组件绑定的事件在经过编译后，会以 onXxx 的形式存储到 props 对象中。当 emit 函数执行时，会在 props 对象中寻找对应的事件处理函数并执行它。</li> <li>组件的插槽借鉴了 Web Component 中 <code>&lt;slot&gt;</code> 标签的概念。插槽内容会被编译为插槽函数，插槽函数的返回值就是向槽位填充的内容。<code>&lt;slot&gt;</code> 标签则会被编译为插槽函数的调用，通过执行对应的插槽函数，得到外部向槽位填充的内容（即虚拟 DOM），最后将该内容渲染到槽位中。</li> <li>onMounted 等用于注册生命周期钩子函数的方法的实现：通过 onMounted 注册的生命周期函数会被注册到当前组件实例的 instance.mounted 数组中。为了维护当前正在初始化的组件实例，我们定义了全局变量 currentInstance，以及用来设置该变量的 setCurrentInstance 函数。</li></ul> <blockquote><p>执行自己的 render 方法即渲染组件内容，在执行 render 方法的时候包裹一层 effect 副作用函数，这样 render 方法中使用到的响应式变量发生了变化就会触发当前 effect 的执行，又因为加入了调度器，所以在响应式变量发生变化时，执行调度器函数，在调度器里执行 effect 回调。</p> <p>为什么要这么做呢？</p> <p>假如现在在组件内的 setup 中 for 循环修改 100 次响应式变量，此时不使用调度器的话那就会触发 effect 100次，而我们只需要最后一次更新即可，没必要更新100 次，所以我们使用调度器就可以将 for 循环 100 次修改触发执行的 effect 回调添加到微任务中去处理，用 set 集合来存储有去重作用，这样等当前宏任务 for 循环 100 次执行完成后执行微任务，此时只触发更新一次 effect。</p></blockquote></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/12 01:29:11</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="prev">
          11.快速Diff算法
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html">
          13.异步组件和函数式组件
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#渲染组件" class="sidebar-link reco-side-渲染组件" data-v-9f22dc18>渲染组件</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#组件状态与自更新" class="sidebar-link reco-side-组件状态与自更新" data-v-9f22dc18>组件状态与自更新</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#组件实例与组件的生命周期" class="sidebar-link reco-side-组件实例与组件的生命周期" data-v-9f22dc18>组件实例与组件的生命周期</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#props-与组件的被动更新" class="sidebar-link reco-side-props-与组件的被动更新" data-v-9f22dc18>props 与组件的被动更新</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#setup-函数的作用与实现" class="sidebar-link reco-side-setup-函数的作用与实现" data-v-9f22dc18>setup 函数的作用与实现</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#组件事件与-emit-的实现" class="sidebar-link reco-side-组件事件与-emit-的实现" data-v-9f22dc18>组件事件与 emit 的实现</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#插槽的工作原理与实现" class="sidebar-link reco-side-插槽的工作原理与实现" data-v-9f22dc18>插槽的工作原理与实现</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#注册生命周期" class="sidebar-link reco-side-注册生命周期" data-v-9f22dc18>注册生命周期</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/12.%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.7738f530.js" defer></script><script src="/vivien-blog/assets/js/7.464cc3ea.js" defer></script><script src="/vivien-blog/assets/js/2.db1c35d8.js" defer></script><script src="/vivien-blog/assets/js/1.88465532.js" defer></script><script src="/vivien-blog/assets/js/121.fa7bfc4d.js" defer></script>
  </body>
</html>
