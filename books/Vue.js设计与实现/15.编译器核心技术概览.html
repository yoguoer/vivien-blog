<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>15.编译器核心技术概览 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.7738f530.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.464cc3ea.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.db1c35d8.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.88465532.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/19.2b108764.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.b772a431.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.62f13f40.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.262eebca.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.d15aec8d.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.3a4e8685.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.d8ef8d42.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.9c62ca3a.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.79799973.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3d688fa2.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.189a67fe.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.815085b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.d29dfabd.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.2ea8565d.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.3253031a.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.5feade57.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.819e6082.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.55297748.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.44b80f99.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.36461d4e.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.99af4d82.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.153f661c.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.df0b310d.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.4edb84f7.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.fa7bfc4d.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.f1a5a11a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.1580535f.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.d2a29b85.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.b5be33e2.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.52480968.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.94af5ec3.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.8dca7f6c.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.c753d508.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.bf5216d1.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.9bb718ff.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.dd72318d.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.025cbb0a.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.7cbb5ff9.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.099aee64.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.c1d6e501.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.e9bcad68.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.4582846d.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.169fb77c.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.aea2c93b.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.1866cbba.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.9ab9834f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.d71bb6eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.383ae212.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.f47e5265.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.d6652043.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.542b86e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.d25326b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e55f1610.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.2fd2d217.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.0d01bb51.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.18330ce2.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.f63999dd.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.9c63570f.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.7e649a94.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.5cd0ff12.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.1380315b.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.9a8bc83a.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.dfc3dc84.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.9f0491a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.56c7442b.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.572118ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.a2889e9a.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.94b92181.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.546a376b.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.6e1296f2.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.294c2556.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.5c64fcbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.f38ecb23.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.a7eaecbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.566ea0ad.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.03726d99.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.44e0a209.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.196020b0.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.cb2a2b01.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.018c7e56.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.0b005dfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.7a746c54.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.9e0d4857.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.16f48649.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.54c9caee.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.932acfca.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.a26eda75.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.d6106a7d.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.0e84a519.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.04cd2610.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f99c6d3c.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.72422da4.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.31dada36.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.d8b153a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.ddda63c0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.6966e143.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.a2fbe5d8.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.48bb5c9c.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.debb65a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.0066da58.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.43f489ac.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.95333a2b.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.51dafac2.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6fe5ff10.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.03ddba74.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.1baba6a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.2f8bb846.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.b5976902.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.f64041b6.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.64d19acb.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.f89c690f.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.192fa399.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.ddf16957.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.25fbc2b8.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.4fea84f6.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.e5c8d0d5.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.201c7a26.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.4accbe01.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.a921fb5d.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.c4b024d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.872418d3.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.ae5ba79d.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.043c5690.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.fd1da6ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.a0dec3a9.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.15551b0c.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="active sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>15.编译器核心技术概览</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">15.编译器核心技术概览</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/18</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><p>​	作为前端工程师，我们应用编译技术的场景通常是：表格、报表中的自定义公式计算器，设计一种领域特定语言（DSL）等。其中，实现公式计算器甚至只涉及编译前端技术，而领域特定语言根据其具体使用场景和目标平台不同，难度会有所不同。Vue.js 的模板和 JSX 都属于特定语言，它们实现难度属于中、低级别，只要掌握基本的编译技术理论即可实现这些功能。</p> <h2 id="模板-dsl-的编译器"><a href="#模板-dsl-的编译器" class="header-anchor">#</a> 模板 DSL 的编译器</h2> <p>​	编译器其实只是一段程序，它用来将“一种语言 A”翻译成“另外一种语言 B”。其中，语言 A 通常叫作<strong>源代码</strong>（source code），语言 B 通常叫作<strong>目标代码</strong>（object code 或 target code）。编译器将源代码翻译为目标代码的过程叫作<strong>编译</strong>（compile）。</p> <p>​	完整的编译过程通常包含词法分析、语法分析、语义分析、中间代码生成、优化、目标代码生成等步骤：</p> <p><img src="/vivien-blog/assets/img/15-1.c545d1a7.png" alt="完整的编译过程"></p> <blockquote><p>整个编译过程分为编译前端和编译后端。</p> <p>编译前端包含词法分析、语法分析和语义分析，它通常与目标平台无关，仅<strong>负责分析源代码</strong>。</p> <p>编译后端则通常与目标平台有关，编译后端<strong>涉及中间代码生成和优化以及目标代码生成</strong>。但是，编译后端并不一定会包含中间代码生成和优化这两个环节，这取决于具体的场景和实现。中间代码生成和优化这两个环节有时也叫“<strong>中端</strong>”。</p></blockquote> <p>​	上图展示了“教科书”式的编译模型，但 Vue.js 的模板作为 DSL，其编译流程会有所不同。<strong>对于 Vue.js 模板编译器来说，源代码就是组件的模板，而目标代码是能够在浏览器平台上运行的 JavaScript 代码，或其他拥有 JavaScript 运行时的平台代码</strong>：</p> <p><img src="/vivien-blog/assets/img/15-2.729af1a2.png" alt="Vue.js模板编译器的目标代码是JavaScript代码"></p> <blockquote><p><strong>Vue.js 模板编译器的目标代码其实就是渲染函数</strong>。详细而言，Vue.js模板编译器会首先对模板进行<strong>词法分析和语法分析</strong>，得到模板 AST。接着，将模板 AST <strong>转换</strong>（transform）成 JavaScript AST。最后，根据 JavaScript AST <strong>生成</strong> JavaScript 代码，即渲染函数代码。</p></blockquote> <p>​	下图给出了 Vue.js 模板编译器的工作流程：</p> <p><img src="/vivien-blog/assets/img/15-3.7190ad1f.png" alt="Vue.js模板编译器的工作流程"></p> <blockquote><p>AST 是 abstract syntax tree 的首字母缩写，即<strong>抽象语法树</strong>。所谓模板 AST，其实就是<strong>用来描述模板的抽象语法树</strong>。</p></blockquote> <p>​	举个例子，假设我们有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ok<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Vue Template<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	这段模板会被编译为如下所示的 AST：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token comment">// 逻辑根节点</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token comment">// div 标签节点</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token comment">// h1 标签节点</span>
         <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
           tag<span class="token operator">:</span> <span class="token string">'h1'</span><span class="token punctuation">,</span>
           props<span class="token operator">:</span> <span class="token punctuation">[</span>
             <span class="token comment">// v-if 指令节点</span>
             <span class="token punctuation">{</span>
               type<span class="token operator">:</span> <span class="token string">'Directive'</span><span class="token punctuation">,</span> <span class="token comment">// 类型为 Directive 代表指令</span>
               name<span class="token operator">:</span> <span class="token string">'if'</span>，       <span class="token comment">// 指令名称为 if，不带有前缀 v-</span>
               exp<span class="token operator">:</span> <span class="token punctuation">{</span>
                 <span class="token comment">// 表达式节点</span>
                 type<span class="token operator">:</span> <span class="token string">'Expression'</span><span class="token punctuation">,</span>
                 content<span class="token operator">:</span> <span class="token string">'ok'</span>
               <span class="token punctuation">}</span>
             <span class="token punctuation">}</span>
           <span class="token punctuation">]</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><blockquote><p>AST 其实就是一个<strong>具有层级结构的对象</strong>。模板 AST 具有与模板同构的嵌套结构。<strong>每一棵 AST 都有一个逻辑上的根节点</strong>，其类型为 Root。模板中真正的根节点则作为 Root 节点的 children 存在。</p></blockquote> <p>​	观察上面的 AST，我们可以得出如下结论：</p> <ul><li>不同类型的节点是<strong>通过节点的 type 属性进行区分</strong>的。例如标签节点的 type 值为 'Element'。</li> <li>标签节点的<strong>子节点存储在其 children 数组中</strong>。</li> <li>标签节点的<strong>属性节点和指令节点会存储在 props 数组中</strong>。</li> <li>不同类型的节点会<strong>使用不同的对象属性进行描述</strong>。例如指令节点拥有 name 属性，用来表达指令的名称，而表达式节点拥有 content 属性，用来描述表达式的内容。</li></ul> <p>​	我们可以通过封装 parse 函数来完成对模板的词法分析和语法分析，得到模板 AST：</p> <p><img src="/vivien-blog/assets/img/15-4.f01360c7.png" alt="parse函数的作用"></p> <p>​	我们也可以用下面的代码来表达模板解析的过程：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
   &lt;div&gt;
     &lt;h1 v-if=&quot;ok&quot;&gt;Vue Template&lt;/h1&gt;
   &lt;/div&gt;
 </span><span class="token template-punctuation string">`</span></span>

 <span class="token keyword">const</span> templateAST <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>​	可以看到，parse 函数接收字符串模板作为参数，并将解析后得到的 AST 作为返回值返回。有了模板 AST 后，我们就可以对其进行语义分析，并对模板 AST 进行转换了。什么是语义分析呢？举几个例子。</p> <ul><li>检查 v-else 指令是否存在相符的 v-if 指令。</li> <li>分析属性值是否是静态的，是否是常量等。</li> <li>插槽是否会引用上层作用域的变量。</li> <li>……</li></ul></blockquote> <p>​	在语义分析的基础上，我们即可得到模板 AST。接着，我们还需要将模板 AST 转换为 JavaScript AST。因为 Vue.js 模板编译器的最终目标是生成渲染函数，而渲染函数本质上是 JavaScript 代码，所以我们需要<strong>将模板 AST 转换成用于描述渲染函数的 JavaScript AST</strong>。</p> <p>​	们可以封装 transform 函数来完成模板 AST 到 JavaScript AST 的转换工作：</p> <p><img src="/vivien-blog/assets/img/15-5.898d7f5a.png" alt="transform 函数的作用"></p> <p>​	同样，我们也可以用下面的代码来表达：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> templateAST <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>
 <span class="token keyword">const</span> jsAST <span class="token operator">=</span> <span class="token function">transform</span><span class="token punctuation">(</span>templateAST<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	有了 JavaScript AST 后，我们就可以<strong>根据它生成渲染函数</strong>了，这一步可以通过封装 generate 函数来完成：</p> <p><img src="/vivien-blog/assets/img/15-6.9e3b759b.png" alt="generate函数的作用"></p> <p>​	我们也可以用下面的代码来表达代码生成的过程：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> templateAST <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>
 <span class="token keyword">const</span> jsAST <span class="token operator">=</span> <span class="token function">transform</span><span class="token punctuation">(</span>templateAST<span class="token punctuation">)</span>
 <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>jsAST<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	generate 函数会将渲染函数的代码以字符串的形式返回，并存储在 code 常量中。完整的流程如下：</p> <p><img src="/vivien-blog/assets/img/15-7.f03894d1.png" alt="将Vue.js模板编译为渲染函数的完整流程"></p> <div class="custom-block tip"><p class="title">总结</p><p>Vue 通过封装 parse 函数来完成对模板的词法分析和语法分析，得到模板 AST，然后通过 transform 函数来完成模板 AST 到 javaScript AST，最后通过 generate 函数来把 javaScript AST 生成渲染函数。</p></div><h2 id="parser-的实现原理与状态机"><a href="#parser-的实现原理与状态机" class="header-anchor">#</a> parser 的实现原理与状态机</h2> <p>​	Vue.js 模板编译器的基本结构和工作流程主要由三个部分组成：</p> <ul><li>用来将模板字符串解析为模板 AST 的解析器（parser）；</li> <li>用来将模板 AST 转换为 JavaScript AST 的转换器（transformer）；</li> <li>用来根据 JavaScript AST 生成渲染函数代码的生成器（generator）。</li></ul> <p>​	<strong>解析器的入参是字符串模板，解析器会逐个读取字符串模板中的字符，并根据一定的规则将整个字符串切割为一个个 Token</strong>。这里的 Token 可以视作词法记号，后续我们将使用 Token 一词来代表词法记号进行讲解。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Vue<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>解析器会把这段字符串模板切割为三个 Token。</p> <ul><li>开始标签：<code>&lt;p&gt;</code>。</li> <li>文本节点：Vue。</li> <li>结束标签：<code>&lt;/p&gt;</code>。</li></ul></blockquote> <h3 id="有限状态自动机"><a href="#有限状态自动机" class="header-anchor">#</a> 有限状态自动机</h3> <div class="custom-block tip"><p class="title"></p><p>​	解析器本质上是一个状态机。</p> <p>​	正则表达式其实也是一个状态机。因此在编写parser 的时候，利用正则表达式能够让我们少写不少代码。</p></div><p>​	那么，解析器是如何对模板进行切割的呢？依据什么规则？这就不得不提到<strong>有限状态自动机</strong>。所谓“有限状态”，就是指<strong>有限个状态</strong>，而“自动机”意味着随着字符的输入，<strong>解析器会自动地在不同状态间迁移</strong>。拿上面的模板来说，当我们分析这段模板字符串时，parse 函数会逐个读取字符，状态机会有一个初始状态，我们记为“初始状态 1”。下图给出了状态迁移的过程：</p> <p><img src="/vivien-blog/assets/img/15-8.7c008b03.png" alt="解析器的状态机图"></p> <blockquote><p>我们用自然语言来描述上图给出的状态迁移过程：</p> <ul><li>状态机始于“初始状态 1”。</li> <li>在“初始状态 1”下，读取模板的第一个字符 <code>&lt;</code>，状态机会进入下一个状态，即“标签开始状态 2”。</li> <li>在“标签开始状态 2”下，读取下一个字符 <code>p</code>。由于字符 p 是字母，所以状态机会进入“标签名称状态 3”。</li> <li>在“标签名称状态 3”下，读取下一个字符 <code>&gt;</code>，此时状态机会从“标签名称状态3”迁移回“初始状态 1”，并记录在“标签名称状态”下产生的标签名称 p。</li> <li>在“初始状态 1”下，读取下一个字符 V，此时状态机会进入“文本状态 4”。</li> <li>在“文本状态 4”下，继续读取后续字符，直到遇到字符 <code>&lt;</code> 时，状态机会再次进入“标签开始状态 2”，并记录在“文本状态 4”下产生的文本内容，即字符串“Vue”。</li> <li>在“标签开始状态 2”下，读取下一个字符 <code>/</code>，状态机会进入“结束标签状态5”。</li> <li>在“结束标签状态 5”下，读取下一个字符 <code>p</code>，状态机会进入“结束标签名称状态 6”。</li> <li>在“结束标签名称状态 6”下，读取最后一个字符 <code>&gt;</code>，它是结束标签的闭合字符，于是状态机迁移回“初始状态 1”，并记录在“结束标签名称状态 6”下生成的结束标签名称。</li></ul> <p>经过这样一系列的状态迁移过程之后，我们最终就能够得到相应的 Token 了。观察上图可以发现，有的圆圈是单线的，而有的圆圈是双线的。双线代表此时状态机是一个合法的 Token。</p></blockquote> <p>​	另外，上图给出的状态机并不严谨。</p> <p>​	实际上，解析 HTML 并构造 Token 的过程是有规范可循的。在 WHATWG 发布的关于浏览器解析 HTML 的规范中，详细阐述了状态迁移。下图截取了该规范中定义的在“初始状态”下状态机的状态迁移过程。</p> <p><img src="/vivien-blog/assets/img/15-9.6ae836c3.png" alt="DataState"></p> <blockquote><p>可以看到，在“初始状态”（Data State）下，当遇到字符 <code>&lt;</code> 时，状态机会迁移到 tag open state，即“标签开始状态”。如果遇到字符 <code>&lt;</code> 以外的字符，规范中也都有对应的说明，应该让状态机迁移到怎样的状态。</p> <p>不过 Vue.js 的模板作为一个 DSL，并非必须遵守该规范。但 Vue.js 的模板毕竟是类 HTML 的实现，因此，尽可能按照规范来做，不会有什么坏处。更重要的一点是，规范中已经定义了非常详细的状态迁移过程，这对于我们编写解析器非常有帮助。</p></blockquote> <p>​	按照有限状态自动机的状态迁移过程，我们可以很容易地编写对应的代码实现。因此，<strong>有限状态自动机可以帮助我们完成对模板的标记化</strong>（tokenized），最终我们将得到一系列 Token下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 定义状态机的状态</span>
 <span class="token keyword">const</span> State <span class="token operator">=</span> <span class="token punctuation">{</span>
   initial<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token comment">// 初始状态</span>
   tagOpen<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token comment">// 标签开始状态</span>
   tagName<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token comment">// 标签名称状态</span>
   text<span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>       <span class="token comment">// 文本状态</span>
   tagEnd<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>     <span class="token comment">// 结束标签状态</span>
   tagEndName<span class="token operator">:</span> <span class="token number">6</span>  <span class="token comment">// 结束标签名称状态</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 一个辅助函数，用于判断是否是字母</span>
 <span class="token keyword">function</span> <span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> char <span class="token operator">&gt;=</span> <span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> char <span class="token operator">&lt;=</span> <span class="token string">'z'</span> <span class="token operator">||</span> char <span class="token operator">&gt;=</span> <span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> char <span class="token operator">&lt;=</span> <span class="token string">'Z'</span>
 <span class="token punctuation">}</span>

 <span class="token comment">// 接收模板字符串作为参数，并将模板切割为 Token 返回</span>
 <span class="token keyword">function</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 状态机的当前状态：初始状态</span>
   <span class="token keyword">let</span> currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>initial
   <span class="token comment">// 用于缓存字符</span>
   <span class="token keyword">const</span> chars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回</span>
   <span class="token keyword">const</span> tokens <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 使用 while 循环开启自动机，只要模板字符串没有被消费尽，自动机就会一直运行</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 查看第一个字符，注意，这里只是查看，没有消费该字符</span>
     <span class="token keyword">const</span> char <span class="token operator">=</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
     <span class="token comment">// switch 语句匹配当前状态</span>
     <span class="token keyword">switch</span> <span class="token punctuation">(</span>currentState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 状态机当前处于初始状态</span>
       <span class="token keyword">case</span> State<span class="token punctuation">.</span>initial<span class="token operator">:</span>
         <span class="token comment">// 遇到字符 &lt;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 状态机切换到标签开始状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>tagOpen
           <span class="token comment">// 2. 消费字符 &lt;</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字母，切换到文本状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>text
           <span class="token comment">// 2. 将当前字母缓存到 chars 数组</span>
           chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
           <span class="token comment">// 3. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">break</span>
       <span class="token comment">// 状态机当前处于标签开始状态</span>
       <span class="token keyword">case</span> State<span class="token punctuation">.</span>tagOpen<span class="token operator">:</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字母，切换到标签名称状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>tagName
           <span class="token comment">// 2. 将当前字符缓存到 chars 数组</span>
           chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
           <span class="token comment">// 3. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字符 /，切换到结束标签状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>tagEnd
           <span class="token comment">// 2. 消费字符 /</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">break</span>
       <span class="token comment">// 状态机当前处于标签名称状态</span>
       <span class="token keyword">case</span> State<span class="token punctuation">.</span>tagName<span class="token operator">:</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字母，由于当前处于标签名称状态，所以不需要切换状态，</span>
           <span class="token comment">// 但需要将当前字符缓存到 chars 数组</span>
           chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
           <span class="token comment">// 2. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'&gt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1.遇到字符 &gt;，切换到初始状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>initial
           <span class="token comment">// 2. 同时创建一个标签 Token，并添加到 tokens 数组中</span>
           <span class="token comment">// 注意，此时 chars 数组中缓存的字符就是标签名称</span>
           tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
             type<span class="token operator">:</span> <span class="token string">'tag'</span><span class="token punctuation">,</span>
             name<span class="token operator">:</span> chars<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
           <span class="token punctuation">}</span><span class="token punctuation">)</span>
           <span class="token comment">// 3. chars 数组的内容已经被消费，清空它</span>
           chars<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
           <span class="token comment">// 4. 同时消费当前字符 &gt;</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">break</span>
       <span class="token comment">// 状态机当前处于文本状态</span>
       <span class="token keyword">case</span> State<span class="token punctuation">.</span>text<span class="token operator">:</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字母，保持状态不变，但应该将当前字符缓存到 chars 数组</span>
           chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
           <span class="token comment">// 2. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字符 &lt;，切换到标签开始状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>tagOpen
           <span class="token comment">// 2. 从 文本状态 --&gt; 标签开始状态，此时应该创建文本 Token，并添加到 tokens 数组</span>
           <span class="token comment">// 注意，此时 chars 数组中的字符就是文本内容</span>
           tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
             type<span class="token operator">:</span> <span class="token string">'text'</span><span class="token punctuation">,</span>
             content<span class="token operator">:</span> chars<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
           <span class="token punctuation">}</span><span class="token punctuation">)</span>
           <span class="token comment">// 3. chars 数组的内容已经被消费，清空它</span>
           chars<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
           <span class="token comment">// 4. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">break</span>
       <span class="token comment">// 状态机当前处于标签结束状态</span>
       <span class="token keyword">case</span> State<span class="token punctuation">.</span>tagEnd<span class="token operator">:</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字母，切换到结束标签名称状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>tagEndName
           <span class="token comment">// 2. 将当前字符缓存到 chars 数组</span>
           chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
           <span class="token comment">// 3. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">break</span>
       <span class="token comment">// 状态机当前处于结束标签名称状态</span>
       <span class="token keyword">case</span> State<span class="token punctuation">.</span>tagEndName<span class="token operator">:</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlpha</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字母，不需要切换状态，但需要将当前字符缓存到 chars 数组</span>
           chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
           <span class="token comment">// 2. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>char <span class="token operator">===</span> <span class="token string">'&gt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 1. 遇到字符 &gt;，切换到初始状态</span>
           currentState <span class="token operator">=</span> State<span class="token punctuation">.</span>initial
           <span class="token comment">// 2. 从 结束标签名称状态 --&gt; 初始状态，应该保存结束标签名称 Token</span>
           <span class="token comment">// 注意，此时 chars 数组中缓存的内容就是标签名称</span>
           tokens<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
             type<span class="token operator">:</span> <span class="token string">'tagEnd'</span><span class="token punctuation">,</span>
             name<span class="token operator">:</span> chars<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
           <span class="token punctuation">}</span><span class="token punctuation">)</span>
           <span class="token comment">// 3. chars 数组的内容已经被消费，清空它</span>
           chars<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
           <span class="token comment">// 4. 消费当前字符</span>
           str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">break</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 最后，返回 tokens</span>
   <span class="token keyword">return</span> tokens
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br><span class="line-number">127</span><br><span class="line-number">128</span><br><span class="line-number">129</span><br><span class="line-number">130</span><br><span class="line-number">131</span><br><span class="line-number">132</span><br><span class="line-number">133</span><br><span class="line-number">134</span><br><span class="line-number">135</span><br><span class="line-number">136</span><br><span class="line-number">137</span><br><span class="line-number">138</span><br><span class="line-number">139</span><br><span class="line-number">140</span><br><span class="line-number">141</span><br><span class="line-number">142</span><br><span class="line-number">143</span><br><span class="line-number">144</span><br><span class="line-number">145</span><br></div></div><blockquote><p>上面这段代码看上去比较冗长，可优化的点非常多，它高度还原了上图中展示的状态机，配合代码中的注释会更容易理解。</p></blockquote> <p>​	使用上面给出的 tokenize 函数来解析模板 <code>&lt;p&gt;Vue&lt;/p&gt;</code>，我们将得到三个Token：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> tokens <span class="token operator">=</span> <span class="token function">tokenize</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;p&gt;Vue&lt;/p&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token comment">// [</span>
 <span class="token comment">//   { type: 'tag', name: 'p' },        // 开始标签</span>
 <span class="token comment">//   { type: 'text', content: 'Vue' },  // 文本节点</span>
 <span class="token comment">//   { type: 'tagEnd', name: 'p' }      // 结束标签</span>
 <span class="token comment">// ]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	现在，我们已经明白了状态机的工作原理，以及模板编译器将模板字符串切割为一个个 Token 的过程。但拿上述例子来说，我们并非总是需要所有 Token。例如，在解析模板的过程中，结束标签 Token 可以省略。这时，我们就可以调整 tokenize 函数的代码，并选择性地忽略结束标签 Token。当然，有时我们也可能需要更多的 Token，这都取决于具体的需求，然后据此灵活地调整代码实现。</p> <p>​	总而言之，<strong>通过有限自动机，我们能够将模板解析为一个个 Token，进而可以用它们构建一棵 AST 了。<strong>但在具体构建 AST 之前，我们需要思考能否简化 tokenize 函数的代码。实际上，我们</strong>可以通过正则表达式来精简 tokenize 函数的代码</strong>。上文之所以没有从最开始就采用正则表达式来实现，是因为<strong>正则表达式的本质就是有限自动机</strong>。当你编写正则表达式的时候，其实就是在编写有限自动机。</p> <h2 id="构造-ast"><a href="#构造-ast" class="header-anchor">#</a> 构造 AST</h2> <p>​	 实际上，不同用途的<strong>编译器</strong>之间可能会存在非常大的差异。它们唯一的共同点是，<strong>都会将源代码转换成目标代码</strong>。但如果深入细节即可发现，不同编译器之间的实现思路甚至可能完全不同，其中就包括 AST 的构造方式。</p> <p>​	对于通用用途语言（GPL）来说，例如 JavaScript 这样的脚本语言，想要为其构造 AST，较常用的一种算法叫作<strong>递归下降算法</strong>，这里面需要解决 GPL 层面才会遇到的很多问题，例如最基本的运算符优先级问题。然而，对于像 Vue.js 模板这样的 DSL 来说，首先可以确定的一点是，它不具有运算符，所以也就没有所谓的运算符优先级问题。<strong>DSL 与 GPL 的区别在于，GPL 是图灵完备的，我们可以使用 GPL 来实现 DSL。而 DSL 不要求图灵完备，它只需要满足特定场景下的特定用途即可。</strong></p> <blockquote><p>递归下降解析的基本步骤：</p> <p>1、开始：从语法的开始符号开始。</p> <p>2、函：调用:对于每一个非终端符号，为其创建一个函数。</p> <p>3、替换：在每个函数中，尝试所有可能的产生式（替换规则）。每个产生式都有自己的代码块。</p> <p>4、递归：如果产生式的右边是非终端符号，那么就调用与其对应的函数。</p> <p>5、接受或拒绝：如果到达输入的未尾（所有的输入都被成功解析），那么接受这个输入。如果没有产生式可以应用，那么拒绝这个输入。</p> <p>递归下降解析的优点是实现简单容易理解。但是，它不能处理左递归的语法（一种非终端符号可以直接或间接地引用自身的情况），并且可能导致大量的回溯，这可能在处理大的输入流时效率较低。因此，对于大型和复杂的语法，通常会使用更复杂的解析技术，比如 LR 解析或者 LL 解析。</p></blockquote> <h3 id="ast-的结构"><a href="#ast-的结构" class="header-anchor">#</a> AST 的结构</h3> <p>​	为 Vue.js 的模板构造 AST 是一件很简单的事。HTML 是一种标记语言，它的格式非常固定，标签元素之间天然嵌套，形成父子关系。因此，<strong>一棵用于描述 HTML 的 AST 将拥有与 HTML 标签非常相似的树型结构</strong>。举例来说，假设有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Vue<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Template<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>在上面这段模板中，最外层的根节点是 div 标签，它有两个 p 标签作为子节点。同时，这两个 p 标签都具有一个文本节点作为子节点。</p></blockquote> <p>​	我们可以将这段模板对应的 AST 设计为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token comment">// AST 的逻辑根节点</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token comment">// 模板的 div 根节点</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token comment">// div 节点的第一个子节点 p</span>
         <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
           tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
           <span class="token comment">// p 节点的文本节点</span>
           children<span class="token operator">:</span> <span class="token punctuation">[</span>
             <span class="token punctuation">{</span>
               type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span>
               content<span class="token operator">:</span> <span class="token string">'Vue'</span>
             <span class="token punctuation">}</span>
           <span class="token punctuation">]</span>
         <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token comment">// div 节点的第二个子节点 p</span>
         <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
           tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
           <span class="token comment">// p 节点的文本节点</span>
           children<span class="token operator">:</span> <span class="token punctuation">[</span>
             <span class="token punctuation">{</span>
               type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span>
               content<span class="token operator">:</span> <span class="token string">'Template'</span>
             <span class="token punctuation">}</span>
           <span class="token punctuation">]</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>​	可以看到，AST 在结构上与模板是“同构”的，它们都具有树型结构：</p> <p><img src="/vivien-blog/assets/img/15-10.a9346432.png" alt="AST的结构"></p> <h3 id="使用程序构造-ast"><a href="#使用程序构造-ast" class="header-anchor">#</a> 使用程序构造 AST</h3> <p>​	了解了 AST 的结构，接下来我们的任务是，使用程序根据模板解析后生成的 Token 构造出这样一棵 AST。</p> <p>​	首先，我们使用 tokenize 函数将前面给出的模板进行标记化。解析这段模板得到的 tokens 如下所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> tokens <span class="token operator">=</span> <span class="token function">tokenize</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	执行上面这段代码，我们将得到如下 tokens：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> tokens <span class="token operator">=</span> <span class="token punctuation">[</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token comment">// div 开始标签节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;p&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token comment">// p 开始标签节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;text&quot;</span><span class="token punctuation">,</span> content<span class="token operator">:</span> <span class="token string">&quot;Vue&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment">// 文本节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;tagEnd&quot;</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;p&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment">// p 结束标签节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;p&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token comment">// p 开始标签节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;text&quot;</span><span class="token punctuation">,</span> content<span class="token operator">:</span> <span class="token string">&quot;Template&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 文本节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;tagEnd&quot;</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;p&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token comment">// p 结束标签节点</span>
   <span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">&quot;tagEnd&quot;</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">&quot;div&quot;</span><span class="token punctuation">}</span>        <span class="token comment">// div 结束标签节点</span>
 <span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	<strong>根据 Token 列表构建 AST 的过程，其实就是对 Token 列表进行扫描的过程</strong>。从第一个 Token 开始，顺序地扫描整个 Token 列表，直到列表中的所有 Token 处理完毕。在这个过程中，我们需要维护一个栈 elementStack，这个栈将用于维护元素间的父子关系。每遇到一个<strong>开始</strong>标签节点，我们就<strong>构造</strong>一个 Element 类型的 AST 节点，并将其<strong>压入栈</strong>中。类似地，每当遇到一个<strong>结束</strong>标签节点，我们就将当前栈顶的节点<strong>弹出</strong>。这样，<strong>栈顶的节点将始终充当父节点的角色</strong>。扫描过程中遇到的所有节点，都会作为当前栈顶节点的子节点，并添加到栈顶节点的 children 属性下。</p> <blockquote><p>注意：只有标签节点才会入栈，文本节点不会，因为文本节点没有子节点。</p></blockquote> <p>​	还是拿上例来说，下图给出了在扫描 Token 列表之前，Token 列表、父级元素栈和 AST 三者的状态：</p> <p><img src="/vivien-blog/assets/img/15-11.cb6db166.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>左侧的是 Token 列表，我们将会按照从上到下的顺序扫描 Token列表，中间和右侧分别展示了栈 elementStack 的状态和 AST 的状态。可以看到，它们最初都只有 Root 根节点。</p></blockquote> <p>​	 接着，我们对 Token 列表进行扫描。首先，扫描到第一个 Token，即“开始标签（div）”：</p> <p><img src="/vivien-blog/assets/img/15-12.6fca190d.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>由于当前扫描到的 Token 是一个开始标签节点，因此我们创建一个类型为 Element 的 AST 节点 Element(div)，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点是 Root 根节点，所以我们将新建的 Element(div) 节点作为Root 根节点的子节点添加到 AST 中，最后将新建的 Element(div) 节点压入elementStack 栈。</p></blockquote> <p>​	接着，我们扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-13.290cad64.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>扫描到的第二个 Token 也是一个开始标签节点，于是我们再创建一个类型为 Element 的 AST 节点 Element(p)，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点为 Element(div) 节点，所以我们将新建的 Element(p) 节点作为 Element(div) 节点的子节点添加到 AST 中，最后将新建的 Element(p) 节点压入 elementStack 栈。</p></blockquote> <p>​	接着，我们扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-14.30589e8d.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>扫描到的第三个 Token 是一个文本节点，于是我们创建一个类型为 Text 的 AST节点 Text(Vue)，然后将该节点作为当前栈顶节点的子节点。由于当前栈顶节点为 Element(p) 节点，所以我们将新建的 Text(p) 节点作为 Element(p) 节点的子节点添加到 AST 中。</p></blockquote> <p>​	接着，扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-15.efdfbf1f.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>此时扫描到的 Token 是一个结束标签，所以我们需要将栈顶的 Element(p) 节点从 elementStack 栈中弹出。</p></blockquote> <p>​	接着，扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-16.e66281db.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>此时扫描到的 Token 是一个开始标签。我们为它新建一个 AST 节点Element(p)，并将其作为当前栈顶节点 Element(div) 的子节点。最后，将Element(p) 压入 elementStack 栈中，使其成为新的栈顶节点。</p></blockquote> <p>​	接着，扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-17.c40d6a4f.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>此时扫描到的 Token 是一个文本节点，所以只需要为其创建一个相应的 AST 节点Text(Template) 即可，然后将其作为当前栈顶节点 Element(p) 的子节点添加到AST 中。</p></blockquote> <p>​	接着，扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-18.abd301e7.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>此时扫描到的 Token 是一个结束标签，于是我们将当前的栈顶节点 Element(p)从 elementStack 栈中弹出。</p></blockquote> <p>​	接着，扫描下一个 Token：</p> <p><img src="/vivien-blog/assets/img/15-19.cc27d3b2.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>此时，扫描到了最后一个 Token，它是一个 div 结束标签，所以我们需要再次将当前栈顶节点 Element(div) 从 elementStack 栈中弹出。至此，所有 Token 都被扫描完毕，AST 构建完成。</p></blockquote> <p>​	下图给出了最终状态：</p> <p><img src="/vivien-blog/assets/img/15-20.7ac27666.png" alt="Token列表、父级元素栈和AST三者的当前状态"></p> <blockquote><p>在所有 Token 扫描完毕后，一棵 AST 就构建完成了。</p></blockquote> <p>​	扫描 Token 列表并构建 AST 的具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// parse 函数接收模板作为参数</span>
 <span class="token keyword">function</span> <span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 首先对模板进行标记化，得到 tokens</span>
   <span class="token keyword">const</span> tokens <span class="token operator">=</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
   <span class="token comment">// 创建 Root 根节点</span>
   <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
     children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 创建 elementStack 栈，起初只有 Root 根节点</span>
   <span class="token keyword">const</span> elementStack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>

   <span class="token comment">// 开启一个 while 循环扫描 tokens，直到所有 Token 都被扫描完毕为止</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 获取当前栈顶节点作为父节点 parent</span>
     <span class="token keyword">const</span> parent <span class="token operator">=</span> elementStack<span class="token punctuation">[</span>elementStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
     <span class="token comment">// 当前扫描的 Token</span>
     <span class="token keyword">const</span> t <span class="token operator">=</span> tokens<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
     <span class="token keyword">switch</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">case</span> <span class="token string">'tag'</span><span class="token operator">:</span>
         <span class="token comment">// 如果当前 Token 是开始标签，则创建 Element 类型的 AST 节点</span>
         <span class="token keyword">const</span> elementNode <span class="token operator">=</span> <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
           tag<span class="token operator">:</span> t<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
           children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 将其添加到父级节点的 children 中</span>
         parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>elementNode<span class="token punctuation">)</span>
         <span class="token comment">// 将当前节点压入栈</span>
         elementStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>elementNode<span class="token punctuation">)</span>
         <span class="token keyword">break</span>
       <span class="token keyword">case</span> <span class="token string">'text'</span><span class="token operator">:</span>
         <span class="token comment">// 如果当前 Token 是文本，则创建 Text 类型的 AST 节点</span>
         <span class="token keyword">const</span> textNode <span class="token operator">=</span> <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span>
           content<span class="token operator">:</span> t<span class="token punctuation">.</span>content
         <span class="token punctuation">}</span>
         <span class="token comment">// 将其添加到父节点的 children 中</span>
         parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>textNode<span class="token punctuation">)</span>
         <span class="token keyword">break</span>
       <span class="token keyword">case</span> <span class="token string">'tagEnd'</span><span class="token operator">:</span>
         <span class="token comment">// 遇到结束标签，将栈顶节点弹出</span>
         elementStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token keyword">break</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 消费已经扫描过的 token</span>
     tokens<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 最后返回 AST</span>
   <span class="token keyword">return</span> root
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><p>​	上面这段代码很好地还原了上文中介绍的构建 AST 的思路，我们可以使用如下代码对其进行测试：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>运行这句代码，我们将得到与前面给出的 AST 一致的结果。这里有必要说明一点，当前的实现仍然存在诸多问题，例如无法处理自闭合标签等。</p></blockquote> <h2 id="ast-的转换与插件化架构"><a href="#ast-的转换与插件化架构" class="header-anchor">#</a> AST 的转换与插件化架构</h2> <p>​	所谓 <strong>AST 的转换，指的是对 AST 进行一系列操作，将其转换为新的 AST 的过程</strong>。新的 AST 可以是原语言或原 DSL 的描述，也可以是其他语言或其他 DSL 的描述。例如，我们可以对模板 AST 进行操作，将其转换为 JavaScript AST。转换后的 AST 可以用于代码生成。这其实就是 Vue.js 的模板编译器将模板编译为渲染函数的过程：</p> <p><img src="/vivien-blog/assets/img/15-21.6f5e9efb.png" alt="模板编译器将模板编译为渲染函数的过程"></p> <blockquote><p>其中 transform 函数就是用来完成 AST 转换工作的。</p></blockquote> <h3 id="节点的访问"><a href="#节点的访问" class="header-anchor">#</a> 节点的访问</h3> <p>​	为了对 AST 进行转换，我们需要能访问 AST 的每一个节点，这样才有机会对特定节点进行修改、替换、删除等操作。由于 AST 是树型数据结构，所以我们需要编写一个深度优先的遍历算法，从而实现对 AST 中节点的访问。</p> <p>​	不过，在开始编写转换代码之前，我们有必要编写一个 dump 工具函数，用来打印当前 AST 中节点的信息：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">dump</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> indent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 节点的类型</span>
   <span class="token keyword">const</span> type <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token comment">// 节点的描述，如果是根节点，则没有描述</span>
   <span class="token comment">// 如果是 Element 类型的节点，则使用 node.tag 作为节点的描述</span>
   <span class="token comment">// 如果是 Text 类型的节点，则使用 node.content 作为节点的描述</span>
   <span class="token keyword">const</span> desc <span class="token operator">=</span> node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Root'</span>
     <span class="token operator">?</span> <span class="token string">''</span>
     <span class="token operator">:</span> node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Element'</span>
       <span class="token operator">?</span> node<span class="token punctuation">.</span>tag
       <span class="token operator">:</span> node<span class="token punctuation">.</span>content

   <span class="token comment">// 打印节点的类型和描述信息</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token string">'-'</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>indent<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">type</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>desc<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>

   <span class="token comment">// 递归地打印子节点</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     node<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> <span class="token function">dump</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> indent <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>​	我们沿用前面给出的例子，看看使用 dump 函数会输出怎样的结果：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	运行上面这段代码，将得到如下输出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> p
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> Vue
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> p
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> Template
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>可以看到，dump 函数以清晰的格式来展示 AST 中的节点。在后续编写 AST 的转换代码时，我们将使用 dump 函数来展示转换后的结果。</p></blockquote> <p>​	接下来，我们将着手实现对 AST 中节点的访问。访问节点的方式是，<strong>从 AST 根节点开始，进行深度优先遍历</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 当前节点，ast 本身就是 Root 节点</span>
   <span class="token keyword">const</span> currentNode <span class="token operator">=</span> ast
   <span class="token comment">// 如果有子节点，则递归地调用 traverseNode 函数进行遍历</span>
   <span class="token keyword">const</span> children <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>traverseNode 函数用来以深度优先的方式遍历 AST，它的实现与 dump 函数几乎相同。</p></blockquote> <p>​	有了 traverseNdoe 函数之后，我们即可实现对 AST 中节点的访问。例如，我们可以实现一个转换功能，将 AST 中所有 p 标签转换为 h1 标签：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 当前节点，ast 本身就是 Root 节点</span>
   <span class="token keyword">const</span> currentNode <span class="token operator">=</span> ast
   <span class="token comment">// 如果有子节点，则递归地调用 traverseNode 函数进行遍历</span>
   <span class="token keyword">const</span> children <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>通过检查当前节点的 type 属性和 tag 属性，来确保被操作的节点是 p 标签。</p></blockquote> <p>​	接着，我们将符合条件的节点的 tag 属性值修改为 'h1'，从而实现 p 标签到 h1 标签的转换。我们可以使用 dump 函数打印转换后的 AST 的信息：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 封装 transform 函数，用来对 AST 进行转换</span>
 <span class="token keyword">function</span> <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 调用 traverseNode 完成转换</span>
   <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
   <span class="token comment">// 打印 AST 信息</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	运行上面这段代码，我们将得到如下输出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> Vue
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> Template
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>可以看到，所有 p 标签都已经变成了 h1 标签。</p></blockquote> <p>​	我们还可以对 AST 进行其他转换。例如，实现一个转换，将文本节点的内容重复两次：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 当前节点，ast 本身就是 Root 节点</span>
   <span class="token keyword">const</span> currentNode <span class="token operator">=</span> ast

   <span class="token comment">// 对当前节点进行操作</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Element'</span> <span class="token operator">&amp;&amp;</span> currentNode<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'p'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将所有 p 标签转换为 h1 标签</span>
     currentNode<span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token string">'h1'</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 如果节点的类型为 Text</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 重复其内容两次，这里我们使用了字符串的 repeat() 方法</span>
     currentNode<span class="token punctuation">.</span>content <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>content<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 如果有子节点，则递归地调用 traverseNode 函数进行遍历</span>
   <span class="token keyword">const</span> children <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p>增加了对文本类型节点的处理代码。一旦检查到当前节点的类型为 Text，则调用 repeat(2) 方法将文本节点的内容重复两次。</p></blockquote> <p>​	最终，我们将得到如下输出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> VueVue
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> TemplateTemplate
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>可以看到，文本节点的内容全部重复了两次。</p></blockquote> <p>​	不过，随着功能的不断增加，traverseNode 函数将会变得越来越“臃肿”。这时，我们很自然地想到，能否对节点的操作和访问进行解耦呢？答案是“当然可以”，我们可以<strong>使用回调函数的机制来实现解耦</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 接收第二个参数 context</span>
 <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> currentNode <span class="token operator">=</span> ast

   <span class="token comment">// context.nodeTransforms 是一个数组，其中每一个元素都是一个函数</span>
   <span class="token keyword">const</span> transforms <span class="token operator">=</span> context<span class="token punctuation">.</span>nodeTransforms
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> transforms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将当前节点 currentNode 和 context 都传递给 nodeTransforms 中注册的回调函数</span>
     transforms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> children <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>首先为 traverseNode 函数增加了第二个参数 context。接着，我们**把回调函数存储到 transforms 数组中，然后遍历该数组，并逐个调用注册在其中的回调函数。**最后，我们将当前节点 currentNode 和 context 对象分别作为参数传递给回调函数。</p> <p>函数式编程思想在这里得到了应用，当函数功能越加越多时，可以考虑对操作进行解耦，解耦的方式就是注册回调函数，将特定元素的特定处理方法剥离出去。</p></blockquote> <p>​	有了修改后的 traverseNode 函数，我们就可以如下所示使用它了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 在 transform 函数内创建 context 对象</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 注册 nodeTransforms 数组</span>
     nodeTransforms<span class="token operator">:</span> <span class="token punctuation">[</span>
       transformElement<span class="token punctuation">,</span> <span class="token comment">// transformElement 函数用来转换标签节点</span>
       transformText     <span class="token comment">// transformText 函数用来转换文本节点</span>
     <span class="token punctuation">]</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 调用 traverseNode 完成转换</span>
   <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token comment">// 打印 AST 信息</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​	其中，transformElement 函数和 transformText 函数的实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transformElement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Element'</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'p'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     node<span class="token punctuation">.</span>tag <span class="token operator">=</span> <span class="token string">'h1'</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">transformText</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     node<span class="token punctuation">.</span>content <span class="token operator">=</span> node<span class="token punctuation">.</span>content<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>可以看到，解耦之后，节点操作封装到了 transformElement 和 transformText这样的独立函数中。我们甚至可以编写任意多个类似的转换函数，只需要将它们注册到 context.nodeTransforms 中即可。这样就解决了功能增加所导致的traverseNode 函数“臃肿”的问题。</p></blockquote> <h3 id="转换上下文与节点操作"><a href="#转换上下文与节点操作" class="header-anchor">#</a> 转换上下文与节点操作</h3> <h4 id="上下文-context"><a href="#上下文-context" class="header-anchor">#</a> 上下文 Context</h4> <p>​	在前面，我们将转换函数注册到 context.nodeTransforms 数组中。那么，为什么要使用 context 对象呢？直接定义一个数组不可以吗？为了搞清楚这个问题，就要提到关于上下文的知识。我们可以把 Context 看作程序在某个范围内的“全局变量”，实际上，<strong>上下文并不是一个具象的东西，它依赖于具体的使用场景</strong>。我们举几个例子来直观地感受一下：</p> <ul><li>在编写 React 应用时，我们可以使用 React.createContext 函数创建一个上下文对象，该上下文对象允许我们将数据通过组件树一层层地传递下去。无论组件树的层级有多深，只要组件在这棵组件树的层级内，那么它就能够访问上下文对象中的数据。</li> <li>在编写 Vue.js 应用时，我们也可以通过 provide/inject 等能力，向一整棵组件树提供数据。这些数据可以称为上下文。</li> <li>在编写 Koa 应用时，中间件函数接收的 context 参数也是一种上下文对象，所有中间件都可以通过 context 来访问相同的数据。</li></ul> <p>​	通过上述三个例子我们能够认识到，<strong>上下文对象其实就是程序在某个范围内的“全局变量”</strong>。换句话说，我们也<strong>可以把全局变量看作全局上下文</strong>。</p> <p>​	对于 context.nodeTransforms 数组，这里的 context 可以看作 <strong>AST 转换函数过程中的上下文数据，所有 AST 转换函数都可以通过 context 来共享数据</strong>。上下文对象中通常会维护程序的当前状态，例如当前转换的节点是哪一个？当前转换的节点的父节点是谁？甚至当前节点是父节点的第几个子节点？等等。这些信息对于编写复杂的转换函数非常有用。</p> <p>​	所以，接下来我们要做的就是构造转换上下文信息：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 增加 currentNode，用来存储当前正在转换的节点</span>
     currentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     <span class="token comment">// 增加 childIndex，用来存储当前节点在父节点的 children 中的位置索引</span>
     childIndex<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
     <span class="token comment">// 增加 parent，用来存储当前转换节点的父节点</span>
     parent<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     nodeTransforms<span class="token operator">:</span> <span class="token punctuation">[</span>
       transformElement<span class="token punctuation">,</span>
       transformText
     <span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

   <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><p>在上面这段代码中，我们为转换上下文对象扩展了一些重要信息：</p> <ul><li>currentNode：用来存储当前正在转换的节点。</li> <li>childIndex：用来存储当前节点在父节点的 children 中的位置索引。</li> <li>arent：用来存储当前转换节点的父节点。</li></ul> <p>上下文对象指的是所有函数都能读取到的有用信息的对象集合，其可以根据需要随意拓展。此处是通过函数传参的方式相互传递，当发生变更时，需要对应地方有义务对上下文对象进行修改，保证改对象的唯一性、准确性。</p></blockquote> <p>​	紧接着，我们需要在合适的地方设置转换上下文对象中的数据：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 设置当前转换的节点信息 context.currentNode</span>
   context<span class="token punctuation">.</span>currentNode <span class="token operator">=</span> ast

   <span class="token keyword">const</span> transforms <span class="token operator">=</span> context<span class="token punctuation">.</span>nodeTransforms
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> transforms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     transforms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>currentNode<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> children <span class="token operator">=</span> context<span class="token punctuation">.</span>currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 递归地调用 traverseNode 转换子节点之前，将当前节点设置为父节点</span>
       context<span class="token punctuation">.</span>parent <span class="token operator">=</span> context<span class="token punctuation">.</span>currentNode
       <span class="token comment">// 设置位置索引</span>
       context<span class="token punctuation">.</span>childIndex <span class="token operator">=</span> i
       <span class="token comment">// 递归地调用时，将 context 透传</span>
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>其关键点在于，在递归地调用 traverseNode 函数进行子节点的转换之前，我们必须设置 context.parent 和 context.childIndex 的值，这样才能保证在接下来的递归转换中，context 对象所存储的信息是正确的。</p></blockquote> <h4 id="节点替换"><a href="#节点替换" class="header-anchor">#</a> 节点替换</h4> <p>​	有了上下文数据后，我们就可以实现节点替换功能了。什么是节点替换呢？在对 AST 进行转换的时候，我们可能希望把某些节点替换为其他类型的节点。例如，将所有文本节点替换成一个元素节点。为了完成节点替换，我们需要在上下文对象中添加 context.replaceNode 函数。该函数接收新的 AST 节点作为参数，并使用新节点替换当前正在转换的节点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     currentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     parent<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     <span class="token comment">// 用于替换节点的函数，接收新节点作为参数</span>
     <span class="token function">replaceNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 为了替换节点，我们需要修改 AST</span>
       <span class="token comment">// 找到当前节点在父节点的 children 中的位置：context.childIndex</span>
       <span class="token comment">// 然后使用新节点替换即可</span>
       context<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>children<span class="token punctuation">[</span>context<span class="token punctuation">.</span>childIndex<span class="token punctuation">]</span> <span class="token operator">=</span> node
       <span class="token comment">// 由于当前节点已经被新节点替换掉了，因此我们需要将 currentNode 更新为新节点</span>
       context<span class="token punctuation">.</span>currentNode <span class="token operator">=</span> node
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     nodeTransforms<span class="token operator">:</span> <span class="token punctuation">[</span>
       transformElement<span class="token punctuation">,</span>
       transformText
     <span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

   <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><blockquote><p>观察上面代码中的 replaceNode 函数。在该函数内，我们首先通过 context.childIndex 属性取得当前节点的位置索引，然后通过 context.parent.children 取得当前节点所在集合，最后配合使用 context.childIndex 与 context.parent.children 即可完成节点替换。另外，由于当前节点已经替换为新节点了，所以我们应该使用新节点更新 context.currentNode 属性的值。</p></blockquote> <p>​	接下来，我们就可以在转换函数中使用 replaceNode 函数对 AST 中的节点进行替换了。如下面 transformText 函数的代码所示，它能够将文本节点转换为元素节点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 转换函数的第二个参数就是 context 对象</span>
 <span class="token keyword">function</span> <span class="token function">transformText</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果当前转换的节点是文本节点，则调用 context.replaceNode 函数将其替换为元素节点</span>
     context<span class="token punctuation">.</span><span class="token function">replaceNode</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
       tag<span class="token operator">:</span> <span class="token string">'span'</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>转换函数的第二个参数就是 context 对象，所以我们可以在转换函数内部使用该对象上的任意属性或函数。在 transformText 函数内部，首先检查当前转换的节点是否是文本节点，如果是，则调用 context.replaceNode函数将其替换为新的 span 标签节点。</p></blockquote> <p>​	下面的例子用来验证节点替换功能：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	 运行上面这段代码，其转换前后的结果分别是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 转换前</span>
 Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> p
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> VueVue
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> p
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> TemplateTemplate
 <span class="token comment">// 转换后</span>
 Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> span
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> span
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>可以看到，转换后的 AST 中的文本节点全部变为 span 标签节点了。</p></blockquote> <h4 id="移除当前访问的节点"><a href="#移除当前访问的节点" class="header-anchor">#</a> 移除当前访问的节点</h4> <p>​	除了替换节点，有时我们还希望移除当前访问的节点。我们可以通过实现 context.removeNode 函数来达到目的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     currentNode<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     parent<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     <span class="token function">replaceNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>currentNode <span class="token operator">=</span> node
       context<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>children<span class="token punctuation">[</span>context<span class="token punctuation">.</span>childIndex<span class="token punctuation">]</span> <span class="token operator">=</span> node
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token comment">// 用于删除当前节点。</span>
     <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 调用数组的 splice 方法，根据当前节点的索引删除当前节点</span>
         context<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>childIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
         <span class="token comment">// 将 context.currentNode 置空</span>
         context<span class="token punctuation">.</span>currentNode <span class="token operator">=</span> <span class="token keyword">null</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     nodeTransforms<span class="token operator">:</span> <span class="token punctuation">[</span>
       transformElement<span class="token punctuation">,</span>
       transformText
     <span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

   <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><blockquote><p>移除当前访问的节点也非常简单，只需要取得其位置索引 context.childIndex，再调用数组的 splice 方法将其从所属的 children 列表中移除即可。</p></blockquote> <p>​	另外，<strong>当节点被移除之后，不要忘记将 context.currentNode 的值置空</strong>。注意，由于当前节点被移除了，所以后续的转换函数将不再需要处理该节点。因此，我们需要对 traverseNode 函数做一些调整：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   context<span class="token punctuation">.</span>currentNode <span class="token operator">=</span> ast

   <span class="token keyword">const</span> transforms <span class="token operator">=</span> context<span class="token punctuation">.</span>nodeTransforms
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> transforms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     transforms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>currentNode<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token comment">// 由于任何转换函数都可能移除当前节点，因此每个转换函数执行完毕后，</span>
     <span class="token comment">// 都应该检查当前节点是否已经被移除，如果被移除了，直接返回即可</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span>currentNode<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> children <span class="token operator">=</span> context<span class="token punctuation">.</span>currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>parent <span class="token operator">=</span> context<span class="token punctuation">.</span>currentNode
       context<span class="token punctuation">.</span>childIndex <span class="token operator">=</span> i
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>增加了一行代码，用于检查 context.currentNode 是否存在。<strong>由于任何转换函数都可能移除当前访问的节点，所以每个转换函数执行完毕后，都应该检查当前访问的节点是否已经被移除，如果被某个转换函数移除了，则 traverseNode 直接返回即可，无须做后续的处理</strong>。</p></blockquote> <p>​	有了 context.removeNode 函数之后，我们即可实现用于移除文本节点的转换函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transformText</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'Text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果是文本节点，直接调用 context.removeNode 函数将其移除即可</span>
     context<span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	配合上面的 transformText 转换函数，运行下面的用例：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	转换前后输出结果是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 转换前</span>
 Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> p
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> VueVue
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> p
 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>Text<span class="token operator">:</span> TemplateTemplate
 <span class="token comment">// 转换后</span>
 Root<span class="token operator">:</span>
 <span class="token operator">--</span>Element<span class="token operator">:</span> div
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
 <span class="token operator">--</span><span class="token operator">--</span>Element<span class="token operator">:</span> h1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>可以看到，在转换后的 AST 中，将不再有任何文本节点。</p></blockquote> <h3 id="进入与退出"><a href="#进入与退出" class="header-anchor">#</a> 进入与退出</h3> <p>​	在转换 AST 节点的过程中，往往需要根据其子节点的情况来决定如何对当前节点进行转换。这就要求<strong>父节点的转换操作必须等待其所有子节点全部转换完毕后再执行</strong>。然而，我们目前设计的转换工作流并不支持这一能力。</p> <p>​	上文中介绍的转换工作流，是一种从根节点开始、顺序执行的工作流：</p> <p><img src="/vivien-blog/assets/img/15-22.a42fba13.png" alt="顺序执行工作流"></p> <blockquote><p>可以看到，Root 根节点第一个被处理，节点层次越深，对它的处理将越靠后。<strong>这种顺序处理的工作流存在的问题是，当一个节点被处理时，意味着它的父节点已经被处理完毕了，并且我们无法再回过头重新处理父节点。</strong></p></blockquote> <p>​	更加理想的转换工作流应该如下图所示：</p> <p><img src="/vivien-blog/assets/img/15-23.29acee1c.png" alt="更加理想的转换工作流"></p> <blockquote><p>对节点的访问分为两个阶段，即进入阶段和退出阶段。当转换函数处于<strong>进入阶段</strong>时，它<strong>会先进入父节点</strong>，再进入子节点。而当转换函数处于<strong>退出阶段</strong>时，则会<strong>先退出子节点</strong>，再退出父节点。这样，只要我们在退出节点阶段对当前访问的节点进行处理，就一定能够保证其子节点全部处理完毕。</p></blockquote> <p>​	为了实现上图所示的转换工作流，我们需要重新设计转换函数的能力：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   context<span class="token punctuation">.</span>currentNode <span class="token operator">=</span> ast
   <span class="token comment">// 1. 增加退出阶段的回调函数数组</span>
   <span class="token keyword">const</span> exitFns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token keyword">const</span> transforms <span class="token operator">=</span> context<span class="token punctuation">.</span>nodeTransforms
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> transforms<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 2. 转换函数可以返回另外一个函数，该函数即作为退出阶段的回调函数</span>
     <span class="token keyword">const</span> onExit <span class="token operator">=</span> transforms<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>currentNode<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>onExit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 将退出阶段的回调函数添加到 exitFns 数组中</span>
       exitFns<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>onExit<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span>currentNode<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> children <span class="token operator">=</span> context<span class="token punctuation">.</span>currentNode<span class="token punctuation">.</span>children
   <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>parent <span class="token operator">=</span> context<span class="token punctuation">.</span>currentNode
       context<span class="token punctuation">.</span>childIndex <span class="token operator">=</span> i
       <span class="token function">traverseNode</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 在节点处理的最后阶段执行缓存到 exitFns 中的回调函数</span>
   <span class="token comment">// 注意，这里我们要反序执行</span>
   <span class="token keyword">let</span> i <span class="token operator">=</span> exitFns<span class="token punctuation">.</span>length
   <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     exitFns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>增加了一个数组 exitFns，用来存储由转换函数返回的回调函数。接着，在 traverseNode 函数的最后，执行这些缓存在 exitFns 数组中的回调函数。这样就保证了，<strong>当退出阶段的回调函数执行时，当前访问的节点的子节点已经全部处理过了</strong>。</p></blockquote> <p>​	有了这些能力之后，我们在编写转换函数时，可以<strong>将转换逻辑编写在退出阶段的回调函数中</strong>，从而保证在对当前访问的节点进行转换之前，其子节点一定全部处理完毕了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transformElement</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 进入节点</span>

   <span class="token comment">// 返回一个会在退出节点时执行的回调函数</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 在这里编写退出节点的逻辑，当这里的代码运行时，当前转换节点的子节点一定处理完毕了</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	另外还有一点需要注意，<strong>退出阶段的回调函数是反序执行的</strong>。这意味着，如果注册了多个转换函数，则它们的注册顺序将决定代码的执行结果。</p> <p>​	假设我们注册的两个转换函数分别是 transformA 和 transformB：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>

     <span class="token comment">// 注册两个转换函数，transformA 先于 transformB</span>
     nodeTransforms<span class="token operator">:</span> <span class="token punctuation">[</span>
       transformA<span class="token punctuation">,</span>
       transformB
     <span class="token punctuation">]</span>
   <span class="token punctuation">}</span>

   <span class="token function">traverseNode</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dump</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​	转换函数 transformA 先于 transformB 被注册。这意味着，在执行转换时，transformA 的“进入阶段”会先于 transformB 的“进入阶段”执行，而 transformA 的“退出阶段”将晚于 transformB 的“退出阶段”执行：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token operator">--</span> transformA 进入阶段执行
 <span class="token operator">--</span><span class="token operator">--</span> transformB 进入阶段执行
 <span class="token operator">--</span><span class="token operator">--</span> transformB 退出阶段执行
 <span class="token operator">--</span> transformA 退出阶段执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>这么设计的好处是，转换函数 transformA 将有机会等待 transformB 执行完毕后，再根据具体情况决定应该如何工作。</p></blockquote> <p>​	如果将 transformA 与 transformB 的顺序调换，那么转换函数的执行顺序也将改变：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token operator">--</span> transformB 进入阶段执行
 <span class="token operator">--</span><span class="token operator">--</span> transformA 进入阶段执行
 <span class="token operator">--</span><span class="token operator">--</span> transformA 退出阶段执行
 <span class="token operator">--</span> transformB 退出阶段执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>由此可见，<strong>当把转换逻辑编写在转换函数的退出阶段时，不仅能够保证所有子节点全部处理完毕，还能够保证所有后续注册的转换函数执行完毕。</strong></p> <p>这里，实现了一个基本的插件架构，即通过注册自定义的转换函数实现对 AST 的操作。</p></blockquote> <h2 id="将模板-ast-转为-javascript-ast"><a href="#将模板-ast-转为-javascript-ast" class="header-anchor">#</a> 将模板 AST 转为 JavaScript AST</h2> <p>​	为什么要将模板 AST 转换为 JavaScript AST 呢？原因我们已经多次提到：<strong>我们需要将模板编译为渲染函数。而渲染函数是由 JavaScript 代码来描述的，因此，我们需要将模板 AST 转换为用于描述渲染函数的 JavaScript AST。</strong></p> <p>​	以前面给出的模板为例：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Vue<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Template<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	与这段模板等价的渲染函数是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'Vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'Template'</span><span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>这段渲染函数的 JavaScript 代码所对应的 JavaScript AST 就是我们的转换目标。那么，它对应的 JavaScript AST 是什么样子的呢？与模板 AST 是模板的描述一样，JavaScript AST 是 JavaScript 代码的描述。所以，<strong>本质上我们需要设计一些数据结构来描述渲染函数的代码。</strong></p></blockquote> <p>​	首先，我们观察上面这段渲染函数的代码。它是一个函数声明，所以我们首先要描述 JavaScript 中的函数声明语句。一个函数声明语句由以下几部分组成：</p> <ul><li>id：函数名称，它是一个标识符 Identifier。</li> <li>params：函数的参数，它是一个数组。</li> <li>body：函数体，由于函数体可以包含多个语句，因此它也是一个数组。</li></ul> <p>​	为了简化问题，这里我们不考虑箭头函数、生成器函数、async 函数等情况。那么，根据以上这些信息，我们就可以设计一个基本的数据结构来描述函数声明语句：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> FunctionDeclNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'FunctionDecl'</span><span class="token punctuation">,</span> <span class="token comment">// 代表该节点是函数声明</span>
   <span class="token comment">// 函数的名称是一个标识符，标识符本身也是一个节点</span>
   id<span class="token operator">:</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span>
     name<span class="token operator">:</span> <span class="token string">'render'</span> <span class="token comment">// name 用来存储标识符的名称，在这里它就是渲染函数的名称 render</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   params<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 参数，目前渲染函数还不需要参数，所以这里是一个空数组</span>
   <span class="token comment">// 渲染函数的函数体只有一个语句，即 return 语句</span>
   body<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'ReturnStatement'</span><span class="token punctuation">,</span>
       <span class="token keyword">return</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token comment">// 暂时留空，在后续讲解中补全</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><blockquote><ul><li>使用一个<strong>对象</strong>来描述一个 JavaScript AST 节点。</li> <li>每个节点都具有 <strong>type</strong> 字段，该字段用来代表节点的类型。对于函数声明语句来说，它的类型是 FunctionDecl。</li> <li>使用 <strong>id</strong> 字段来存储<strong>函数的名称</strong>。函数的名称应该是一个合法的标识符，因此 id 字段本身也是一个类型为 Identifier 的节点。当然，在设计 JavaScript AST 时，可以根据实际需要进行调整。例如，我们完全可以将 id 字段设计为一个字符串类型的值。这样做虽然不完全符合 JavaScript 的语义，但是能够满足我们的需求。</li> <li>对于<strong>函数的参数</strong>，我们使用 <strong>params</strong> 数组来存储。目前，我们设计的渲染函数还不需要参数，因此暂时设为空数组。</li> <li>使用 <strong>body</strong> 字段来描述<strong>函数的函数体</strong>。一个函数的函数体内可以存在多个语句，所以我们使用一个数组来描述它。该数组内的每个元素都对应一条语句，对于渲染函数来说，目前它只有一个返回语句，所以我们使用一个类型为 ReturnStatement 的节点来描述该返回语句。</li></ul></blockquote> <p>​	介绍完函数声明语句的节点结构后，我们再来看一下渲染函数的返回值。**渲染函数返回的是虚拟 DOM 节点，具体体现在 h 函数的调用。**我们可以使用CallExpression 类型的节点来描述函数调用语句:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> CallExp <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
   <span class="token comment">// 被调用函数的名称，它是一个标识符</span>
   callee<span class="token operator">:</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span>
     name<span class="token operator">:</span> <span class="token string">'h'</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// 参数</span>
   arguments<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>类型为 CallExpression 的节点拥有两个属性。</p> <ul><li>callee：用来描述被调用函数的名字称，它本身是一个标识符节点。</li> <li>arguments：被调用函数的形式参数，多个参数的话用数组来描述。</li></ul></blockquote> <p>​	我们再次观察渲染函数的返回值：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// h 函数的第一个参数是一个字符串字面量</span>
   <span class="token comment">// h 函数的第二个参数是一个数组</span>
   <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token comment">/*...*/</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	可以看到，最外层的 h 函数的第一个参数是一个<strong>字符串字面量</strong>（字符串常量），我们可以使用类型为 StringLiteral 的节点来描述它：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> Str <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span>
   value<span class="token operator">:</span> <span class="token string">'div'</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	最外层的 h 函数的第二个参数是一个<strong>数组</strong>（数组AST），我们可以使用类型为 ArrayExpression 的节点来描述它：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> Arr <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'ArrayExpression'</span><span class="token punctuation">,</span>
   <span class="token comment">// 数组中的元素</span>
   elements<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	使用上述 CallExpression、StringLiteral、ArrayExpression 等节点来填充渲染函数的返回值，其最终结果如下面的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> FunctionDeclNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'FunctionDecl'</span> <span class="token comment">// 代表该节点是函数声明</span>
   <span class="token comment">// 函数的名称是一个标识符，标识符本身也是一个节点</span>
   id<span class="token operator">:</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span>
     name<span class="token operator">:</span> <span class="token string">'render'</span> <span class="token comment">// name 用来存储标识符的名称，在这里它就是渲染函数的名称 render</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   params<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 参数，目前渲染函数还不需要参数，所以这里是一个空数组</span>
   <span class="token comment">// 渲染函数的函数体只有一个语句，即 return 语句</span>
   body<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'ReturnStatement'</span><span class="token punctuation">,</span>
       <span class="token comment">// 最外层的 h 函数调用</span>
       <span class="token keyword">return</span><span class="token operator">:</span> <span class="token punctuation">{</span>
         type<span class="token operator">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
         callee<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'h'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
         arguments<span class="token operator">:</span> <span class="token punctuation">[</span>
           <span class="token comment">// 第一个参数是字符串字面量 'div'</span>
           <span class="token punctuation">{</span>
             type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span>
             value<span class="token operator">:</span> <span class="token string">'div'</span>
           <span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token comment">// 第二个参数是一个数组</span>
           <span class="token punctuation">{</span>
             type<span class="token operator">:</span> <span class="token string">'ArrayExpression'</span><span class="token punctuation">,</span>
             elements<span class="token operator">:</span> <span class="token punctuation">[</span>
               <span class="token comment">// 数组的第一个元素是 h 函数的调用</span>
               <span class="token punctuation">{</span>
                 type<span class="token operator">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
                 callee<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'h'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                 arguments<span class="token operator">:</span> <span class="token punctuation">[</span>
                   <span class="token comment">// 该 h 函数调用的第一个参数是字符串字面量</span>
                   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'p'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                   <span class="token comment">// 第二个参数也是一个字符串字面量</span>
                   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'Vue'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                 <span class="token punctuation">]</span>
               <span class="token punctuation">}</span><span class="token punctuation">,</span>
               <span class="token comment">// 数组的第二个元素也是 h 函数的调用</span>
               <span class="token punctuation">{</span>
                 type<span class="token operator">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
                 callee<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'h'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                 arguments<span class="token operator">:</span> <span class="token punctuation">[</span>
                   <span class="token comment">// 该 h 函数调用的第一个参数是字符串字面量</span>
                   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'p'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                   <span class="token comment">// 第二个参数也是一个字符串字面量</span>
                   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'Template'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
                 <span class="token punctuation">]</span>
               <span class="token punctuation">}</span>
             <span class="token punctuation">]</span>
           <span class="token punctuation">}</span>
         <span class="token punctuation">]</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><blockquote><p>如上面这段 <strong>JavaScript AST</strong> 的代码所示，它<strong>是对渲染函数代码的完整描述</strong>。</p></blockquote> <p>​	接下来我们的任务是，编写转换函数，将模板 AST 转换为上述 JavaScript AST。不过在开始之前，我们需要编写一些用来创建 JavaScript AST 节点的辅助函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用来创建 StringLiteral 节点</span>
 <span class="token keyword">function</span> <span class="token function">createStringLiteral</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'StringLiteral'</span><span class="token punctuation">,</span>
     value
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 用来创建 Identifier 节点</span>
 <span class="token keyword">function</span> <span class="token function">createIdentifier</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span>
     name
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 用来创建 ArrayExpression 节点</span>
 <span class="token keyword">function</span> <span class="token function">createArrayExpression</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'ArrayExpression'</span><span class="token punctuation">,</span>
     elements
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 用来创建 CallExpression 节点</span>
 <span class="token keyword">function</span> <span class="token function">createCallExpression</span><span class="token punctuation">(</span>callee<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'CallExpression'</span><span class="token punctuation">,</span>
     callee<span class="token operator">:</span> <span class="token function">createIdentifier</span><span class="token punctuation">(</span>callee<span class="token punctuation">)</span><span class="token punctuation">,</span>
     arguments
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><blockquote><p>有了这些辅助函数，我们可以更容易地编写转换代码。</p></blockquote> <p>​	为了把模板 AST 转换为 JavaScript AST，我们同样需要两个转换函数：transformElement 和 transformText，它们分别用来处理<strong>标签节点</strong>和<strong>文本节点</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 转换文本节点</span>
 <span class="token keyword">function</span> <span class="token function">transformText</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果不是文本节点，则什么都不做</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'Text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 文本节点对应的 JavaScript AST 节点其实就是一个字符串字面量，</span>
   <span class="token comment">// 因此只需要使用 node.content 创建一个 StringLiteral 类型的节点即可</span>
   <span class="token comment">// 最后将文本节点对应的 JavaScript AST 节点添加到 node.jsNode 属性下</span>
   node<span class="token punctuation">.</span>jsNode <span class="token operator">=</span> <span class="token function">createStringLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>content<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 转换标签节点</span>
 <span class="token keyword">function</span> <span class="token function">transformElement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 将转换代码编写在退出阶段的回调函数中，</span>
   <span class="token comment">// 这样可以保证该标签节点的子节点全部被处理完毕</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果被转换的节点不是元素节点，则什么都不做</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'Element'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 1. 创建 h 函数调用语句,</span>
     <span class="token comment">// h 函数调用的第一个参数是标签名称，因此我们以 node.tag 来创建一个字符串字面量节点</span>
     <span class="token comment">// 作为第一个参数</span>
     <span class="token keyword">const</span> callExp <span class="token operator">=</span> <span class="token function">createCallExpression</span><span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
       <span class="token function">createStringLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>tag<span class="token punctuation">)</span>
     <span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token comment">// 2. 处理 h 函数调用的参数</span>
     node<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span>
       <span class="token comment">// 如果当前标签节点只有一个子节点，则直接使用子节点的 jsNode 作为参数</span>
       <span class="token operator">?</span> callExp<span class="token punctuation">.</span>arguments<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>jsNode<span class="token punctuation">)</span>
       <span class="token comment">// 如果当前标签节点有多个子节点，则创建一个 ArrayExpression 节点作为参数</span>
       <span class="token operator">:</span> callExp<span class="token punctuation">.</span>arguments<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
         <span class="token comment">// 数组的每个元素都是子节点的 jsNode</span>
         <span class="token function">createArrayExpression</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>c <span class="token operator">=&gt;</span> c<span class="token punctuation">.</span>jsNode<span class="token punctuation">)</span><span class="token punctuation">)</span>
       <span class="token punctuation">)</span>
     <span class="token comment">// 3. 将当前标签节点对应的 JavaScript AST 添加到 jsNode 属性下</span>
     node<span class="token punctuation">.</span>jsNode <span class="token operator">=</span> callExp
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><blockquote><p>有两点需要注意：</p> <ul><li>在转换标签节点时，我们需要将转换逻辑编写在<strong>退出阶段</strong>的回调函数内，这样才能保证其子节点全部被处理完毕；</li> <li>无论是文本节点还是标签节点，它们转换后的 JavaScript AST 节点都存储在节点的 <strong>node.jsNode</strong> 属性下。</li></ul></blockquote> <p>​	使用上面两个转换函数即可完成标签节点和文本节点的转换，即<strong>把模板转换成 h 函数的调用</strong>。但是，转换后得到的 AST 只是用来描述渲染函数 render 的返回值的，所以我们最后一步要做的就是，补全 JavaScript AST，即<strong>把用来描述 render 函数本身的函数声明语句节点附加到 JavaScript AST 中</strong>。这需要我们编写transformRoot 函数来实现对 Root 根节点的转换：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 转换 Root 根节点</span>
 <span class="token keyword">function</span> <span class="token function">transformRoot</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 将逻辑编写在退出阶段的回调函数中，保证子节点全部被处理完毕</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果不是根节点，则什么都不做</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type <span class="token operator">!==</span> <span class="token string">'Root'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// node 是根节点，根节点的第一个子节点就是模板的根节点，</span>
     <span class="token comment">// 当然，这里我们暂时不考虑模板存在多个根节点的情况</span>
     <span class="token keyword">const</span> vnodeJSAST <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>jsNode
     <span class="token comment">// 创建 render 函数的声明语句节点，将 vnodeJSAST 作为 render 函数体的返回语句</span>
     node<span class="token punctuation">.</span>jsNode <span class="token operator">=</span> <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'FunctionDecl'</span><span class="token punctuation">,</span>
       id<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Identifier'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'render'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
       params<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       body<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'ReturnStatement'</span><span class="token punctuation">,</span>
           <span class="token keyword">return</span><span class="token operator">:</span> vnodeJSAST
         <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><blockquote><p>经过这一步处理之后，模板 AST 将转换为对应的 JavaScript AST，并且可以通过根节点的 node.jsNode 来访问转换后的 JavaScript AST。</p></blockquote> <h2 id="代码生成"><a href="#代码生成" class="header-anchor">#</a> 代码生成</h2> <p>​	如何根据  JavaScript AST 生成渲染函数的代码，即代码生成。**代码生成本质上是字符串拼接的艺术。**我们需要访问 JavaScript AST 中的节点，为每一种类型的节点生成相符的 JavaScript 代码。</p> <p>​	本节，我们将实现 generate 函数来完成代码生成的任务。<strong>代码生成也是编译器的最后一步</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">compile</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 模板 AST</span>
   <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>
   <span class="token comment">// 将模板 AST 转换为 JavaScript AST</span>
   <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
   <span class="token comment">// 代码生成</span>
   <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>jsNode<span class="token punctuation">)</span>

   <span class="token keyword">return</span> code
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	与 AST 转换一样，代码生成也需要上下文对象。该上下文对象用来<strong>维护代码生成过程中程序的运行状态</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">generate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 存储最终生成的渲染函数代码</span>
     code<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
     <span class="token comment">// 在生成代码时，通过调用 push 函数完成代码的拼接</span>
     <span class="token function">push</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>code <span class="token operator">+=</span> code
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 调用 genNode 函数完成代码生成的工作，</span>
   <span class="token function">genNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token comment">// 返回渲染函数代码</span>
   <span class="token keyword">return</span> context<span class="token punctuation">.</span>code
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>首先定义了上下文对象 context，它包含 <strong>context.code</strong> 属性，用来<strong>存储最终生成的渲染函数代码</strong>，还定义了 <strong>context.push</strong> 函数，用来<strong>完成代码拼接</strong>，接着调用 <strong>genNode</strong> 函数完成<strong>代码生成</strong>的工作，最后<strong>将最终生成的渲染函数代码返回</strong>。</p></blockquote> <p>​	另外，我们希望最终生成的代码具有较强的可读性，因此我们应该<strong>考虑生成代码的格式</strong>，例如缩进和换行等。这就需要我们扩展 context 对象，为其增加用来完成换行和缩进的工具函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">generate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     code<span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
     <span class="token function">push</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>code <span class="token operator">+=</span> code
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token comment">// 当前缩进的级别，初始值为 0，即没有缩进</span>
     currentIndent<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
     <span class="token comment">// 该函数用来换行，即在代码字符串的后面追加 \n 字符，</span>
     <span class="token comment">// 另外，换行时应该保留缩进，所以我们还要追加 currentIndent * 2 个空格字符</span>
     <span class="token function">newline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>code <span class="token operator">+=</span> <span class="token string">'\n'</span> <span class="token operator">+</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>currentIndent<span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token comment">// 用来缩进，即让 currentIndent 自增后，调用换行函数</span>
     <span class="token function">indent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>currentIndent<span class="token operator">++</span>
       context<span class="token punctuation">.</span><span class="token function">newline</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token comment">// 取消缩进，即让 currentIndent 自减后，调用换行函数</span>
     <span class="token function">deIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       context<span class="token punctuation">.</span>currentIndent<span class="token operator">--</span>
       context<span class="token punctuation">.</span><span class="token function">newline</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token function">genNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token keyword">return</span> context<span class="token punctuation">.</span>code
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><blockquote><p>增加了 context.currentIndent 属性，它代表缩进的级别，初始值为 0，代表没有缩进，还增加了 context.newline() 函数，每次调用该函数时，都会在代码字符串后面追加换行符 \n。</p> <p>由于换行时需要保留缩进，所以还要追加 context.currentIndent * 2 个空格字符。这里假设缩进为两个空格字符，后续我们可以将其设计为可配置的。</p> <p>同时，还增加了 context.indent() 函数用来完成代码缩进，它的原理很简单，即让缩进级别 context.currentIndent 进行自增，再调用 context.newline() 函数。与之对应的 context.deIndent() 函数则用来取消缩进，即让缩进级别 context.currentIndent  进行自减，再调用 context.newline() 函数。</p></blockquote> <p>​	有了这些基础能力之后，我们就可以开始编写 genNode 函数来完成代码生成的工作了。代码生成的原理其实很简单，只需要<strong>匹配各种类型的 JavaScript AST 节点，并调用对应的生成函数</strong>即可：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">genNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">case</span> <span class="token string">'FunctionDecl'</span><span class="token operator">:</span>
       <span class="token function">genFunctionDecl</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
       <span class="token keyword">break</span>
     <span class="token keyword">case</span> <span class="token string">'ReturnStatement'</span><span class="token operator">:</span>
       <span class="token function">genReturnStatement</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
       <span class="token keyword">break</span>
     <span class="token keyword">case</span> <span class="token string">'CallExpression'</span><span class="token operator">:</span>
       <span class="token function">genCallExpression</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
       <span class="token keyword">break</span>
     <span class="token keyword">case</span> <span class="token string">'StringLiteral'</span><span class="token operator">:</span>
       <span class="token function">genStringLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
       <span class="token keyword">break</span>
     <span class="token keyword">case</span> <span class="token string">'ArrayExpression'</span><span class="token operator">:</span>
       <span class="token function">genArrayExpression</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
       <span class="token keyword">break</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>使用 switch 语句来匹配不同类型的节点，并调用与之对应的生成器函数。</p> <ul><li>对于 FunctionDecl 节点，使用 genFunctionDecl 函数为该类型节点生成对应的 JavaScript 代码。</li> <li>对于 ReturnStatement 节点，使用 genReturnStatement 函数为该类型节点生成对应的 JavaScript 代码。</li> <li>对于 CallExpression 节点，使用 genCallExpression 函数为该类型节点生成对应的 JavaScript 代码。</li> <li>对于 StringLiteral 节点，使用 genStringLiteral 函数为该类型节点生成对应的JavaScript 代码。</li> <li>对于 ArrayExpression 节点，使用 genArrayExpression 函数为该类型节点生成对应的 JavaScript 代码。</li></ul> <p>由于我们目前只涉及这五种类型的 JavaScript 节点，所以现在的 genNode 函数足够完成上述案例。当然，如果后续需要增加节点类型，只需要在 genNode 函数中添加相应的处理分支即可。</p></blockquote> <p>​	接下来，我们将逐步完善代码生成工作。首先，我们来实现函数声明语句的代码生成，即 genFunctionDecl 函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">genFunctionDecl</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 从 context 对象中取出工具函数</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> push<span class="token punctuation">,</span> indent<span class="token punctuation">,</span> deIndent <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token comment">// node.id 是一个标识符，用来描述函数的名称，即 node.id.name</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">function </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>node<span class="token punctuation">.</span>id<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 genNodeList 为函数的参数生成代码</span>
   <span class="token function">genNodeList</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>params<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">) </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token comment">// 缩进</span>
   <span class="token function">indent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 为函数体生成代码，这里递归地调用了 genNode 函数</span>
   node<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> <span class="token function">genNode</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// 取消缩进</span>
   <span class="token function">deIndent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​	genFunctionDecl 函数用来为<strong>函数声明</strong>类型的节点生成对应的 JavaScript 代码。以渲染函数的声明节点为例，它最终生成的代码将会是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token operator">...</span> 函数体
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	另外我们注意到，在 genFunctionDecl 函数内部调用了 genNodeList 函数来为函数的参数生成对应的代码。它的实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">genNodeList</span><span class="token punctuation">(</span>nodes<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> push <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> node <span class="token operator">=</span> nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token function">genNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nodes<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">push</span><span class="token punctuation">(</span><span class="token string">', '</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	接收一个<strong>节点数组</strong>作为参数，并为每一个节点<strong>递归</strong>地调用 genNode 函数完成代码生成工作。这里要注意的一点是，每处理完一个节点，需要在生成的代码后面<strong>拼接逗号字符（,）</strong>。举例来说：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 如果节点数组为</span>
 <span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token punctuation">[</span>节点 <span class="token number">1</span>， 节点 <span class="token number">2</span>， 节点 <span class="token number">3</span><span class="token punctuation">]</span>
 <span class="token comment">// 那么生成的代码将类似于</span>
 <span class="token string">'节点 1，节点 2，节点 3'</span>
 <span class="token comment">// 如果在这段代码的前后分别添加圆括号，那么它将可用于函数的参数声明</span>
 <span class="token punctuation">(</span><span class="token string">'节点 1，节点 2，节点 3'</span><span class="token punctuation">)</span>
 <span class="token comment">// 如果在这段代码的前后分别添加方括号，那么它将是一个数组</span>
 <span class="token punctuation">[</span><span class="token string">'节点 1，节点 2，节点 3'</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>由上例可知，genNodeList 函数会在节点代码之间补充逗号字符。</p></blockquote> <p>​	实际上，genArrayExpression 函数就利用了这个特点来实现对<strong>数组表达式</strong>的代码生成：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">genArrayExpression</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> push <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token comment">// 追加方括号</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 genNodeList 为数组元素生成代码</span>
   <span class="token function">genNodeList</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>elements<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token comment">// 补全方括号</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>不过，由于目前渲染函数暂时没有接收任何参数，所以 genNodeList 函数不会为其生成任何代码。对于 genFunctionDecl 函数，另外需要注意的是，<strong>由于函数体本身也是一个节点数组，所以我们需要遍历它并递归地调用 genNode 函数生成代码。</strong></p></blockquote> <p>​	对于 ReturnStatement 和 StringLiteral 类型的节点来说，为它们生成代码很简单，如下所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">genReturnStatement</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> push <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token comment">// 追加 return 关键字和空格</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">return </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 genNode 函数递归地生成返回值代码</span>
   <span class="token function">genNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>return<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">genStringLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> push <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token comment">// 对于字符串字面量，只需要追加与 node.value 对应的字符串即可</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">'</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>node<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​	最后，只剩下 genCallExpression 函数了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">genCallExpression</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> push <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token comment">// 取得被调用函数名称和参数列表</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> callee<span class="token punctuation">,</span> arguments<span class="token operator">:</span> args <span class="token punctuation">}</span> <span class="token operator">=</span> node
   <span class="token comment">// 生成函数调用代码</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callee<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">(</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 genNodeList 生成参数代码</span>
   <span class="token function">genNodeList</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
   <span class="token comment">// 补全括号</span>
   <span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>可以看到，在 genCallExpression 函数内，我们也用到了 genNodeList 函数来为函数调用时的参数生成对应的代码。</p></blockquote> <p>​	配合上述生成器函数的实现，我们将得到符合预期的渲染函数代码。运行如下测试用例：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;p&gt;Vue&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
 <span class="token function">transform</span><span class="token punctuation">(</span>ast<span class="token punctuation">)</span>
 <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>jsNode<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	最终得到的代码字符串如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'Vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'Template'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li><p>Vue.js 的模板编译器用于把模板编译为渲染函数。它的工作流程大致分为三个步骤。(1) 分析模板，将其解析为模板 AST。(2) 将模板 AST 转换为用于描述渲染函数的 JavaScript AST。(3) 根据 JavaScript AST 生成渲染函数代码。</p></li> <li><p>词法分析的过程就是状态机在不同状态之间迁移的过程。在此过程中，状态机会产生一个个 Token，形成一个 Token 列表。我们将使用该 Token 列表来构造用于描述模板的 AST。具体做法是，扫描 Token 列表并维护一个开始标签栈。每当扫描到一个开始标签节点，就将其压入栈顶。栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有 Token 扫描完毕后，即可构建出一棵树型 AST。</p></li> <li><p>AST 是树型数据结构，为了访问AST 中的节点，采用深度优先的方式对 AST 进行遍历。在遍历过程中，我们可以对 AST 节点进行各种操作，从而实现对 AST 的转换。为了解耦节点的访问和操作，设计了插件化架构，将节点的操作封装到独立的转换函数中。这些转换函数可以通过 context.nodeTransforms 来注册。这里的 context 称为转换上下文。上下文对象中通常会维护程序的当前状态，例如当前访问的节点、当前访问的节点的父节点、当前访问的节点的位置索引等信息。有了上下文对象及其包含的重要信息后，即可轻松地实现节点的替换、删除等能力。但有时，当前访问节点的转换工作依赖于其子节点的转换结果，所以为了优先完成子节点的转换，将整个转换过程分为“进入阶段”与“退出阶段”。每个转换函数都分两个阶段执行，这样就可以实现更加细粒度的转换控制。</p></li> <li><p>模板 AST 用来描述模板，类似地，JavaScript AST 用于描述 JavaScript 代码。只有把模板 AST 转换为 JavaScript AST 后，才能据此生成最终的渲染函数代码。</p></li> <li><p>代码生成是模板编译器的最后一步工作，生成的代码将作为组件的渲染函数。代码生成的过程就是字符串拼接的过程。我们需要为不同的 AST 节点编写对应的代码生成函数。为了让生成的代码具有更强的可读性，还要对生成的代码进行缩进和换行。将用于缩进和换行的代码封装为工具函数，并且定义到代码生成过程中的上下文对象中。</p></li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/18 07:05:27</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="prev">
          14.内建组件和模块
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html">
          16.解析器
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#模板-dsl-的编译器" class="sidebar-link reco-side-模板-dsl-的编译器" data-v-9f22dc18>模板 DSL 的编译器</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#parser-的实现原理与状态机" class="sidebar-link reco-side-parser-的实现原理与状态机" data-v-9f22dc18>parser 的实现原理与状态机</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#有限状态自动机" class="sidebar-link reco-side-有限状态自动机" data-v-9f22dc18>有限状态自动机</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#构造-ast" class="sidebar-link reco-side-构造-ast" data-v-9f22dc18>构造 AST</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#ast-的结构" class="sidebar-link reco-side-ast-的结构" data-v-9f22dc18>AST 的结构</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#使用程序构造-ast" class="sidebar-link reco-side-使用程序构造-ast" data-v-9f22dc18>使用程序构造 AST</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#ast-的转换与插件化架构" class="sidebar-link reco-side-ast-的转换与插件化架构" data-v-9f22dc18>AST 的转换与插件化架构</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#节点的访问" class="sidebar-link reco-side-节点的访问" data-v-9f22dc18>节点的访问</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#转换上下文与节点操作" class="sidebar-link reco-side-转换上下文与节点操作" data-v-9f22dc18>转换上下文与节点操作</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#进入与退出" class="sidebar-link reco-side-进入与退出" data-v-9f22dc18>进入与退出</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#将模板-ast-转为-javascript-ast" class="sidebar-link reco-side-将模板-ast-转为-javascript-ast" data-v-9f22dc18>将模板 AST 转为 JavaScript AST</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#代码生成" class="sidebar-link reco-side-代码生成" data-v-9f22dc18>代码生成</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/15.%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.7738f530.js" defer></script><script src="/vivien-blog/assets/js/7.464cc3ea.js" defer></script><script src="/vivien-blog/assets/js/2.db1c35d8.js" defer></script><script src="/vivien-blog/assets/js/1.88465532.js" defer></script><script src="/vivien-blog/assets/js/19.2b108764.js" defer></script>
  </body>
</html>
