<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>16.解析器 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.1b7b4fd5.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.210383a7.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.00d63d32.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.96251043.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/20.c523984f.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.fa80c4ef.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.057c90a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.19c4abac.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.8bc66b45.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.a3435343.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.0068d84a.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.04fc30e6.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.9ff39244.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3b79619c.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.d5bf9027.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.698ce34c.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.45f08108.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.3681f055.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.387f6115.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.4d7580b7.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.c3fe5fe0.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.f0df6d73.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.2388eeb0.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.94a902d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.35c6f7e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.f7ecaac7.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.53eceb0f.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.1bbfbebb.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.b66bb0a4.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.1a72171a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.49317ff6.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.1919ad13.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.46542121.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.d20b2438.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.096c8422.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.6f10ade2.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.be3e0f7e.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.92794b90.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.93cec235.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.41118c66.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.3131a535.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.0fcf1058.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.c4515dab.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.2fe122be.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.341cf97a.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.06b93e75.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.9f594ab7.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.409fd3e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.5a3a4049.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.21fac10f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.c590614b.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.b8c03943.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.2c65a62c.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.15a38861.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.934f6b75.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.8704b94b.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e6e61ee0.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.c193bc49.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.03974196.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.7e51c94f.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.1da6c0eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.44155ea4.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.c892cb88.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.20dcb46a.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.ab72969e.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.35261d9d.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.d1f877b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.58cf6028.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.1056cd44.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.d32266a5.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.652b8114.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.1deb9d35.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.1b0a642d.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.f74917b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.b394b7e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.b1d92ead.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.fa969ab7.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.3676a039.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.8625a796.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.85e6ae67.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.cf3b4106.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.195eccac.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.a23fa0b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.cc54345c.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.3074601a.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.5861d737.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.89926beb.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.28daaf49.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.7333cd13.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.c0ec386a.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.47dd6986.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.7a8aca22.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.45edd43b.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.7b6e7073.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f8cbb551.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.6cc4496a.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.91f8578c.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.2a8f1cef.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.7a4f08f0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.072edcd7.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.11e37d34.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.b2ed6145.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.b0ffe6f1.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.37f798b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.4a2f8418.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.26d75a07.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.de800dca.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6ac0d041.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.cbde96fb.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.96d5beb2.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.4d9e115c.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.948fa90e.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.246d9e36.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.79d82321.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.d881655a.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.0d3c4c1c.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.241b57a2.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.4cb09072.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.6b6a6d21.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.09f385e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.684c40fa.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.3abfbc85.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.8e112cc6.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.ccd72f8f.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.50ca9f79.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.bfe29f10.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.a5f404ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.c86f128e.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.59512bfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.cf1ceb98.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="active sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>16.解析器</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">16.解析器</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/19</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><p>​	我们之前讨论了解析器（parser）的工作原理，知道了解析器本质是一个状态机。但我们也曾提到，正则表达式其实也是一个状态机。因此在编写 <code>parser</code> 的时候，利用正则表达式能够让我们少写不少代码。接下来我们将更多地利用正则表达式来实现 HTML 解析器。</p> <p>​	另外，一个完善的 HTML 解析器远比想象的要复杂。浏览器会对 HTML 文本进行解析，那么它是如何做的呢？其实关于 HTML 文本的解析，是有规范可循的，即 WHATWG 关于 HTML 的解析规范，其中定义了完整的错误处理和状态机的状态迁移流程，还提及了一些特殊的状态，例如 DATA、CDATA、RCDATA、RAWTEXT 等。</p> <h2 id="文本模式及其对解析器的影响"><a href="#文本模式及其对解析器的影响" class="header-anchor">#</a> 文本模式及其对解析器的影响</h2> <p>​	<strong>文本模式指的是解析器在工作时所进入的一些特殊状态，在不同的特殊状态下，解析器对文本的解析行为会有所不同</strong>。具体来说，当解析器遇到一些特殊标签时，会切换模式，从而影响其对文本的解析行为。这些特殊标签是：</p> <ul><li><code>&lt;title&gt;</code> 标签、<code>&lt;textarea&gt;</code> 标签，当解析器遇到这两个标签时，会切换到 <strong>RCDATA 模式</strong>；</li> <li><code>&lt;style&gt;</code>、<code>&lt;xmp&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;noembed&gt;</code>、<code>&lt;noframes&gt;</code>、<code>&lt;noscript&gt;</code>等标签，当解析器遇到这些标签时，会切换到 <strong>RAWTEXT 模式</strong>；</li> <li>当解析器遇到 <code>&lt;![CDATA[</code> 字符串时，会进入 <strong>CDATA 模式</strong>。</li></ul> <h3 id="data"><a href="#data" class="header-anchor">#</a> DATA</h3> <p>​	<strong>解析器的初始模式则是 DATA 模式</strong>。对于 Vue.js 的模板 DSL 来说，模板中不允许出现 <code>&lt;script&gt;</code> 标签，因此 Vue.js 模板解析器在遇到 <code>&lt;script&gt;</code> 标签时也会切换到 RAWTEXT 模式。</p> <p>​	<strong>解析器的行为会因工作模式的不同而不同</strong>。WHATWG 规范的第 13.2.5.1 节给出了初始模式下解析器的工作流程：</p> <p><img src="/vivien-blog/assets/img/16-1.7e9e161b.png" alt="WHATWG规范中关于DataState的描述"></p> <blockquote><p>在默认的 DATA 模式下，解析器在遇到字符 <code>&lt;</code> 时，会切换到<strong>标签开始状态</strong>（tag open state）。换句话说，在该模式下，解析器<strong>能够解析标签元素</strong>。</p> <p>当解析器遇到字符 <code>&amp;</code> 时，会切换到<strong>字符引用状态</strong>（character reference state），也称 <strong>HTML 字符实体状态</strong>。也就是说，在 DATA 模式下，解析器能够处理 <strong>HTML 字符实体</strong>。</p></blockquote> <h3 id="rcdata"><a href="#rcdata" class="header-anchor">#</a> RCDATA</h3> <p>​	我们再来看看当解析器处于 RCDATA 状态时，它的工作情况如何。下图给出了 WHATWG 规范第 13.2.5.2 节中所定义的 RCDATA 模式下状态机的工作方式：</p> <p><img src="/vivien-blog/assets/img/16-2.b9976e11.png" alt="WHATWG规范中关于RCDATAState的描述"></p> <blockquote><p>当解析器遇到字符 <code>&lt;</code> 时，<strong>不会再切换</strong>到标签开始状态，而会<strong>切换到 RCDATA</strong> less-than sign state 状态。</p></blockquote> <p>​	下图给出了 RCDATA less-thansign state 状态下解析器的工作方式：</p> <p><img src="/vivien-blog/assets/img/16-3.f51ebbfb.png" alt="WHATWG规范中关于RCDATALess-thanSignState的描述"></p> <blockquote><p>在 RCDATA less-than sign state 状态下，如果解析器遇到字符 <code>/</code>，则直接切换到 RCDATA 的<strong>结束标签状态</strong>，即 RCDATA end tag open state；否则会将当前字符 <code>&lt;</code> 作为<strong>普通字符</strong>处理，然后继续处理后面的字符。由此可知，在 <strong>RCDATA</strong> 状态下，解析器<strong>不能识别标签元素</strong>。</p></blockquote> <p>​	这其实间接说明了在<code>&lt;textarea&gt;</code> 内可以将字符 <code>&lt;</code> 作为普通文本，解析器并不会认为字符 <code>&lt;</code> 是标签开始的标志，如下面的代码所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>asdf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>asdfasdf
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>这段 HTML 代码中，<code>&lt;textarea&gt;</code> 标签内存在一个 <code>&lt;div&gt;</code> 标签。但解析器并不会把 <code>&lt;div&gt;</code> 解析为标签元素，而是作为普通文本处理。</p></blockquote> <p>​	在 RCDATA 模式下，解析器仍然<strong>支持 HTML 实体</strong>。因为当解析器遇到字符 <code>&amp;</code> 时，会切换到<strong>字符引用状态</strong>，如下面的代码所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;copy;">&amp;copy;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>浏览器在渲染这段 HTML 代码时，会在文本框内展示字符 <code>©</code>。</p></blockquote> <h3 id="rawtext"><a href="#rawtext" class="header-anchor">#</a> RAWTEXT</h3> <p>​	解析器在 RAWTEXT 模式下的工作方式与在 RCDATA 模式下类似。唯一不同的是，在 <strong>RAWTEXT</strong> 模式下，解析器将<strong>不再支持 HTML 实体</strong>。下图给出了WHATWG 规范第 13.2.5.3 节中所定义的 RAWTEXT 模式下状态机的工作方式：</p> <p><img src="/vivien-blog/assets/img/16-4.a93dc2c6.png" alt="WHATWG规范中关于RAWTEXTState的描述"></p> <blockquote><p><strong>RAWTEXT</strong> 模式的确<strong>不支持 HTML 实体</strong>。在该模式下，解析器会将 HTML 实体字符作为普通字符处理。Vue.js 的单文件组件的解析器在遇到 <code>&lt;script&gt;</code> 标签时就会进入 RAWTEXT 模式，这时它会<strong>把 <code>&lt;script&gt;</code> 标签内的内容全部作为普通文本处理</strong>。</p></blockquote> <h3 id="cdata"><a href="#cdata" class="header-anchor">#</a> CDATA</h3> <p>​	CDATA 模式在 RAWTEXT 模式的基础上更进一步。下图给出了 WHATWG 规范第 13.2.5.69 节中所定义的 CDATA 模式下状态机的工作方式：</p> <p><img src="/vivien-blog/assets/img/16-5.099e96cd.png" alt="WHATWG规范中关于CDATASectionState的描述"></p> <blockquote><p>在 CDATA 模式下，解析器将<strong>把任何字符都作为普通字符处理，直到遇到 CDATA 的结束标志为止。</strong></p></blockquote> <p>​	实际上，在 WHATWG 规范中还定义了 PLAINTEXT 模式，该模式与 RAWTEXT 模式类似。不同的是，<strong>解析器一旦进入 PLAINTEXT 模式，将不会再退出</strong>。另外，Vue.js 的模板 DSL 解析器是用不到 PLAINTEXT 模式的，因此我们不会过多介绍它。</p> <p>​	下表汇总了不同的模式及各其特性：</p> <table><thead><tr><th>模式</th> <th>能否解析标签</th> <th>是否支持 HTML 实体</th></tr></thead> <tbody><tr><td>DATA</td> <td>能</td> <td>是</td></tr> <tr><td>RCDATA</td> <td>否</td> <td>是</td></tr> <tr><td>RAWTEXT</td> <td>否</td> <td>否</td></tr> <tr><td>CDATA</td> <td>否</td> <td>否</td></tr></tbody></table> <blockquote><p>除了上表列出的特性之外，<strong>不同的模式还会影响解析器对于终止解析的判断</strong>。</p> <p>另外，后续编写解析器代码时，我们会将上述模式定义为状态表，如下面的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> TextModes <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token constant">DATA</span><span class="token operator">:</span> <span class="token string">'DATA'</span><span class="token punctuation">,</span>
<span class="token constant">RCDATA</span><span class="token operator">:</span> <span class="token string">'RCDATA'</span><span class="token punctuation">,</span>
<span class="token constant">RAWTEXT</span><span class="token operator">:</span> <span class="token string">'RAWTEXT'</span><span class="token punctuation">,</span>
<span class="token constant">CDATA</span><span class="token operator">:</span> <span class="token string">'CDATA'</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></blockquote> <h2 id="递归下降算法构造模板-ast"><a href="#递归下降算法构造模板-ast" class="header-anchor">#</a> 递归下降算法构造模板 AST</h2> <p>​	解析器的基本架构模型如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 定义文本模式，作为一个状态表</span>
 <span class="token keyword">const</span> TextModes <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token constant">DATA</span><span class="token operator">:</span> <span class="token string">'DATA'</span><span class="token punctuation">,</span>
   <span class="token constant">RCDATA</span><span class="token operator">:</span> <span class="token string">'RCDATA'</span><span class="token punctuation">,</span>
   <span class="token constant">RAWTEXT</span><span class="token operator">:</span> <span class="token string">'RAWTEXT'</span><span class="token punctuation">,</span>
   <span class="token constant">CDATA</span><span class="token operator">:</span> <span class="token string">'CDATA'</span>
 <span class="token punctuation">}</span>

 <span class="token comment">// 解析器函数，接收模板作为参数</span>
 <span class="token keyword">function</span> <span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 定义上下文对象</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// source 是模板内容，用于在解析过程中进行消费</span>
     source<span class="token operator">:</span> str<span class="token punctuation">,</span>
     <span class="token comment">// 解析器当前处于文本模式，初始模式为 DATA</span>
     mode<span class="token operator">:</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 调用 parseChildren 函数开始进行解析，它返回解析后得到的子节点</span>
   <span class="token comment">// parseChildren 函数接收两个参数：</span>
   <span class="token comment">// 第一个参数是上下文对象 context</span>
   <span class="token comment">// 第二个参数是由父代节点构成的节点栈，初始时栈为空</span>
   <span class="token keyword">const</span> nodes <span class="token operator">=</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

   <span class="token comment">// 解析器返回 Root 根节点</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
     <span class="token comment">// 使用 nodes 作为根节点的 children</span>
     children<span class="token operator">:</span> nodes
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><blockquote><ol><li>首先，定义了一个状态表 TextModes，它用来描述预定义的文本模式。</li> <li>然后，定义了 parse 函数，即解析器函数，在其中定义了上下文对象 context，用来维护解析程序执行过程中程序的各种状态。</li> <li>接着，调用 parseChildren 函数进行解析，该函数会返回解析后得到的子节点，并使用这些子节点作为 children 来创建 Root 根节点。</li> <li>最后，parse 函数返回根节点，完成模板 AST 的构建。</li></ol> <p>这段代码的思路与模板 AST 的构建思路有所不同。在前面，我们首先对模板内容进行标记化得到一系列 Token，然后根据这些 Token 构建模板 AST。<strong>实际上，创建 Token 与构造模板 AST 的过程可以同时进行，因为模板和模板 AST 具有同构的特性。</strong></p></blockquote> <p>​	另外，在上面这段代码中，<strong>parseChildren 函数是整个解析器的核心</strong>。后续我们会递归地调用它来不断地消费模板内容。<strong>parseChildren 函数会返回解析后得到的子节点</strong>。举个例子，假设有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	上面这段模板有两个根节点，即两个 <code>&lt;p&gt;</code> 标签。parseChildren 函数在解析这段模板后，会得到由这两个 <code>&lt;p&gt;</code> 节点组成的数组：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token punctuation">[</span>
    <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token comment">/*...*/</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token comment">/*...*/</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>之后，这个数组将作为 Root 根节点的 children。</p> <p>parseChildren 函数接收两个参数：</p> <ul><li>第一个参数：上下文对象 context。</li> <li>第二个参数：由父代节点构成的栈，用于维护节点间的父子级关系。</li></ul> <p><strong>parseChildren 函数本质上也是一个状态机，该状态机有多少种状态取决于子节点的类型数量。</strong></p> <p>在模板中，元素的子节点可以是以下几种：</p> <ul><li>标签节点，例如 <code>&lt;div&gt;</code>。</li> <li>文本插值节点，例如 <code></code>。</li> <li>普通文本节点，例如：<code>text</code>。</li> <li>注释节点，例如 <code>&lt;!----&gt;</code>。</li> <li>CDATA 节点，例如 <code>&lt;![CDATA[ xxx ]]&gt;</code>。</li></ul> <p>在标准的 HTML 中，节点的类型将会更多，例如 DOCTYPE 节点等。为了降低复杂度，我们仅考虑上述类型的节点。</p></blockquote> <p>​	下图给出了 parseChildren 函数在解析模板过程中的状态迁移过程：</p> <p><img src="/vivien-blog/assets/img/16-6.45ee3918.png" alt="parseChildren函数在解析模板过程中的状态迁移过程"></p> <blockquote><p>上图所展示的状态迁移过程总结如下：</p> <ul><li>当遇到字符 <code>&lt;</code> 时，<strong>进入临时状态</strong>。
<ul><li>如果下一个字符匹配正则 <code>/a-z/i</code>，则认为这是一个<strong>标签节点</strong>，于是调用 parseElement 函数完成标签的解析。注意正则表达式 <code>/a-z/i</code> 中的 <code>i</code>，意思是忽略大小写（case-insensitive）。</li> <li>如果字符串以 <code>&lt;!--</code> 开头，则认为这是一个<strong>注释节点</strong>，于是调用 parseComment 函数完成注释节点的解析。</li> <li>如果字符串以 <code>&lt;![CDATA[</code> 开头，则认为这是一个 <strong>CDATA 节点</strong>，于是调用 parseCDATA 函数完成 CDATA 节点的解析。</li></ul></li> <li>如果字符串以 <code>{{</code> 开头，则认为这是一个<strong>插值节点</strong>，于是调用 parseInterpolation 函数完成插值节点的解析。</li> <li>其他情况，都作为<strong>普通文本</strong>，调用 parseText 函数完成文本节点的解析。</li></ul></blockquote> <p>​	落实到代码时，我们还需要结合文本模式：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 定义 nodes 数组存储子节点，它将作为最终的返回值</span>
   <span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 从上下文对象中取得当前状态，包括模式 mode 和模板内容 source</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> mode<span class="token punctuation">,</span> source <span class="token punctuation">}</span> <span class="token operator">=</span> context

   <span class="token comment">// 开启 while 循环，只要满足条件就会一直对字符串进行解析</span>
   <span class="token comment">// 关于 isEnd() 后文会详细讲解</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnd</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">let</span> node
     <span class="token comment">// 只有 DATA 模式和 RCDATA 模式才支持插值节点的解析</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">||</span> mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">RCDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 只有 DATA 模式才支持标签节点的解析</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">&amp;&amp;</span> source<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'!'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&lt;!--'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">// 注释</span>
             node <span class="token operator">=</span> <span class="token function">parseComment</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&lt;![CDATA['</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">// CDATA</span>
             node <span class="token operator">=</span> <span class="token function">parseCDATA</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span>
           <span class="token punctuation">}</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 结束标签，这里需要抛出错误，后文会详细解释原因</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 标签</span>
           node <span class="token operator">=</span> <span class="token function">parseElement</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'{{'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 解析插值</span>
         node <span class="token operator">=</span> <span class="token function">parseInterpolation</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// node 不存在，说明处于其他模式，即非 DATA 模式且非 RCDATA 模式</span>
     <span class="token comment">// 这时一切内容都作为文本处理</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 解析文本节点</span>
       node <span class="token operator">=</span> <span class="token function">parseText</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// 将节点添加到 nodes 数组中</span>
     nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 当 while 循环停止后，说明子节点解析完毕，返回子节点</span>
   <span class="token keyword">return</span> nodes
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><p>​	上面这段代码完整地描述了上图所示的状态迁移过程，这里有几点需要注意：</p> <ul><li>parseChildren 函数的<strong>返回值是由子节点组成的数组</strong>，每次 <code>while</code> 循环都会解析一个或多个节点，这些节点会被添加到 nodes 数组中，并作为 parseChildren 函数的返回值返回。</li> <li>解析过程中需要<strong>判断当前的文本模式</strong>。根据上表可知，只有处于 DATA 模式或 RCDATA 模式时，解析器才支持插值节点的解析。并且，只有处于 DATA 模式时，解析器才支持标签节点、注释节点和 CDATA 节点的解析。</li> <li>我们知道，<strong>当遇到特定标签时，解析器会切换模式</strong>。一旦解析器切换到 DATA 模式和 RCDATA 模式之外的模式时，一切字符都将作为文本节点被解析。当然，即使在 DATA 模式或 RCDATA 模式下，如果无法匹配标签节点、注释节点、CDATA 节点、插值节点，那么也会作为文本节点解析。</li></ul> <blockquote><p>除了上述三点内容外，你可能对这段代码仍然有疑问，其中之一是 while 循环何时停止？以及 <code>isEnd()</code> 函数的用途是什么？这里我们给出简单的解释，parseChildren 函数是用来解析子节点的，因此 while 循环一定要遇到父级节点的结束标签才会停止，这是正常的思路。但这个思路存在一些问题，不过我们这里暂时将其忽略。</p></blockquote> <h3 id="parsechildren-函数"><a href="#parsechildren-函数" class="header-anchor">#</a> parseChildren 函数</h3> <p>​	我们可以通过一个例子来更加直观地了解 parseChildren 函数，以及其他解析函数在解析模板时的工作职责和工作流程。以下面的模板为例：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;
   &lt;p&gt;Text1&lt;/p&gt;
   &lt;p&gt;Text2&lt;/p&gt;
 &lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>这里需要强调的是，<strong>在解析模板时，我们不能忽略空白字符</strong>。这些空白字符包括：换行符（<code>\n</code>）、回车符（<code>\r</code>）、空格（<code>' '</code>）、制表符（<code>\t</code>）以及换页符（<code>\f</code>）。如果我们用加号（+）代表换行符，用减号（-）代表空格字符。</p></blockquote> <p>​	那么上面的模板可以表示为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	接下来，我们以这段模板作为输入来执行解析过程。</p> <p>​	解析器一开始处于 DATA 模式。开始执行解析后，解析器遇到的第一个字符为 <code>&lt;</code>，并且第二个字符能够匹配正则表达式 <code>/a-z/i</code>，所以解析器会进入标签节点状态，并调用 parseElement 函数进行解析。**parseElement 函数会做三件事：解析开始标签，解析子节点，解析结束标签。**可以用下面的伪代码来表达 parseElement 函数所做的事情：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 解析开始标签</span>
   <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token function">parseTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 这里递归地调用 parseChildren 函数进行 &lt;div&gt; 标签子节点的解析</span>
   element<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 解析结束标签</span>
   <span class="token function">parseEndTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     
   <span class="token keyword">return</span> element
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	如果一个标签不是自闭合标签，则可以认为，<strong>一个完整的标签元素是由开始标签、子节点和结束标签这三部分构成的</strong>。因此，在 parseElement 函数内，我们分别调用三个解析函数来处理这三部分内容。以上述模板为例。</p> <p>​	1、parseTag 解析开始标签。**parseTag 函数用于解析开始标签，包括开始标签上的属性和指令。**因此，在 parseTag 解析函数执行完毕后，会消费字符串中的内容<code>&lt;div&gt;</code>，处理后的模板内容将变为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	2、**递归地调用 parseChildren 函数解析子节点。**parseElement 函数在解析开始标签时，会产生一个标签节点 element。在 parseElement 函数执行完毕后，剩下的模板内容应该作为 element 的子节点被解析，即 element.children。因此，我们要递归地调用 parseChildren 函数。在这个过程中，parseChildren 函数会消费字符串的内容：<code>+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+</code>。处理后的模板内容将变为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	3、**parseEndTag 处理结束标签。**可以看到，在经过 parseChildren 函数处理后，模板内容只剩下一个结束标签了。因此，只需要调用 parseEndTag 解析函数来消费它即可。</p> <p>​	经过上述三个步骤的处理后，这段模板就被解析完毕了，最终得到了模板 AST。注意，**为了解析标签的子节点，我们递归地调用了 parseChildren 函数。**这意味着，一个新的状态机开始运行了，我们称其为“状态机 2”。“状态机 2”所处理的模板内容为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">+--&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	接下来，我们继续分析“状态机 2”的状态迁移流程。</p> <p>​	1、在“状态机 2”开始运行时，模板的第一个字符是换行符（字符 <code>+</code> 代表换行符）。因此，解析器会进入文 本节点状态，并调用 parseText 函数完成文本节点的解析。parseText 函数会将下一个 <code>&lt;</code> 字符之前的所有字符都视作文本节点的内容。换句话说，parseText 函数会消费模板内容 <code>+--</code>，并产生一个文本节点。在 parseText 解析函数执行完毕后，剩下的模板内容为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;p&gt;Text1&lt;/p&gt;+--&lt;p&gt;Text2&lt;/p&gt;+</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	2、接着，parseChildren 函数继续执行。此时模板的第一个字符为 <code>&lt;</code>，并且下一个字符能够匹配正则 <code>/a-z/i</code>。于是解析器再次进入 parseElement 解析函数的执行阶段，这会消费模板内容 <code>&lt;p&gt;Text1&lt;/p&gt;</code>。在这一步过后，剩下的模板内容为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">+--&lt;p&gt;Text2&lt;/p&gt;+</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	3、可以看到，此时模板的第一个字符是换行符，于是调用 parseText 函数消费模板内容 <code>+--</code>。现在，模板中剩下的内容是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;p&gt;Text2&lt;/p&gt;+</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	4、解析器会再次调用 parseElement 函数处理标签节点。在这之后，剩下的模板内容为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">+</span><span class="token template-punctuation string">`</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	可以看到，现在模板内容只剩下一个换行符了。<strong>parseChildren 函数会继续执行并调用 parseText 函数消费剩下的内容</strong>，并产生一个文本节点。最终，模板被解析完毕，“状态机 2”停止运行。</p> <p>​	在“状态机 2”运行期间，为了处理标签节点，我们又调用了两次 parseElement 函数。第一次调用用于处理内容 <code>&lt;p&gt;Text1&lt;/p&gt;</code>，第二次调用用于处理内容<code>&lt;p&gt;Text2&lt;/p&gt;</code>。我们知道，<strong>parseElement 函数会递归地调用 parseChildren 函数完成子节点的解析</strong>，这就意味着解析器会<strong>再开启了两个新的状态机</strong>。</p> <p>​	通过上述例子我们能够认识到，<strong>parseChildren 解析函数是整个状态机的核心，状态迁移操作都在该函数内完成</strong>。</p> <ul><li>在 parseChildren 函数运行过程中，为了处理<strong>标签节点</strong>，会调用 parseElement 解析函数，这会<strong>间接地调用 parseChildren 函数</strong>，并<strong>产生一个新的状态机</strong>。</li> <li>随着标签嵌套层次的增加，<strong>新的状态机会随着 parseChildren 函数被递归地调用而不断创建</strong>，这就是“递归下降”中“递归”二字的含义。</li> <li>而上级 parseChildren 函数的调用用于构造<strong>上级</strong>模板 AST 节点，被递归调用的下级 parseChildren 函数则用于构造<strong>下级</strong>模板 AST 节点。</li> <li>最终，会构造出<strong>一棵树型结构的模板 AST</strong>，这就是“递归下降”中“下降”二字的含义。</li></ul> <blockquote><p>递归下降：递归即递归调用 parseChildren，每次 parseElement 都会间接调用 parseChildren，因为要判断是否有子节点，所以下降指的是调用下级函数parseChildren。</p> <p>另外：前面的  <code>parseChildren()</code> 存在 bug，不能直接把 source 从 context 中解构出现，下面给出修正后的实现：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">parseChildren</span> <span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 定义 nodes 数组存储子节点，它将作为最终的返回值</span>
<span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">-</span>  <span class="token comment">// 从上下文对象中取得当前状态，包括模式 mode 和模板内容 source</span>
<span class="token operator">+</span>  <span class="token comment">// 从上下文对象中取得当前状态</span>
<span class="token operator">-</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> mode<span class="token punctuation">,</span> source <span class="token punctuation">}</span> <span class="token operator">=</span> context
<span class="token operator">+</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span> mode <span class="token punctuation">}</span> <span class="token operator">=</span> context

  <span class="token comment">// 开启 while 循环，只要满足条件就会一直对字符串进行解析</span>
  <span class="token comment">// 关于 isEnd() 后文会详细讲解</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnd</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node
    <span class="token comment">// 只有 DATA 模式和 RCDATA 模式才支持插值节点的解析</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">||</span> mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">RCDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 只有 DATA 模式才支持标签节点的解析</span>
<span class="token operator">-</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">&amp;&amp;</span> source<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">&amp;&amp;</span> context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">-</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'!'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'!'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">-</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&lt;!--'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&lt;!--'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 注释</span>
            node <span class="token operator">=</span> <span class="token function">parseComment</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
<span class="token operator">-</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&lt;![CDATA['</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&lt;![CDATA['</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// CDATA</span>
            node <span class="token operator">=</span> <span class="token function">parseCDATA</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
<span class="token operator">-</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 状态机遇到了闭合标签，此时应该抛出错误，因为它缺少与之对应的开始标签</span>
          <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'无效的结束标签'</span><span class="token punctuation">)</span>
<span class="token operator">-</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 标签</span>
          node <span class="token operator">=</span> <span class="token function">parseElement</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token operator">-</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'{{'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token operator">+</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'{{'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解析插值</span>
        node <span class="token operator">=</span> <span class="token function">parseInterpolation</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// node 不存在，说明处于其它模式，即非 DATA 模式且非 RCDATA 模式</span>
    <span class="token comment">// 这时一切内容都作为文本处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> <span class="token function">parseText</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将节点添加到 nodes 数组中</span>
    nodes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 当 while 循环停止后，说明子节点解析完毕，返回子节点</span>
  <span class="token keyword">return</span> nodes
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br></div></div></blockquote> <h2 id="状态机的开启与停止"><a href="#状态机的开启与停止" class="header-anchor">#</a> 状态机的开启与停止</h2> <p>​	我们知道，<strong>parseChildren 函数本质上是一个状态机</strong>，它会开启一个 <strong>while 循环</strong>使得状态机<strong>自动</strong>运行：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

   <span class="token keyword">const</span> <span class="token punctuation">{</span> mode <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token comment">// 运行状态机</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnd</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> nodes
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​	这里的问题在于，状态机何时停止呢？换句话说，while 循环应该何时停止运行呢？这涉及 <code>isEnd()</code> 函数的判断逻辑。为了搞清楚这个问题，我们需要模拟状态机的运行过程。</p> <h3 id="开启"><a href="#开启" class="header-anchor">#</a> 开启</h3> <p>​	我们知道，在调用 parseElement 函数解析标签节点时，会递归地调用 parseChildren 函数，从而开启新的状态机：</p> <p><img src="/vivien-blog/assets/img/16-7.8c5499a0.png" alt="开启新的状态机"></p> <p>​	为了便于描述，我们可以把图中的新的状态机称为“状态机 1”。“状态机 1”开始运行，继续解析模板，直到遇到下一个 <code>&lt;p&gt;</code> 标签：</p> <p><img src="/vivien-blog/assets/img/16-8.337ebbc9.png" alt="递归地开启新的状态机"></p> <p>​	因为遇到了 <code>&lt;p&gt;</code> 标签，所以“状态机 1”也会调用 parseElement 函数进行解析。于是又重复了上述过程，即把当前解析的标签节点压入父级节点栈，然后递归地调用 parseChildren 函数开启新的状态机，即“状态机 2”。可以看到，此时有两个状态机在同时运行。</p> <h3 id="停止"><a href="#停止" class="header-anchor">#</a> 停止</h3> <p>​	此时“状态机 2”拥有程序的执行权，它<strong>持续解析模板直到遇到结束标签</strong> <code>&lt;/p&gt;</code>。因为这是一个结束标签，并且在父级节点栈中存在与该结束标签同名的标签节点，所以“状态机 2”会<strong>停止</strong>运行，并<strong>弹出</strong>父级节点栈中处于栈顶的节点：</p> <p><img src="/vivien-blog/assets/img/16-9.329927bc.png" alt="状态机2停止运行"></p> <p>​	此时“状态机 2”已经停止运行了，但“状态机 1”仍在运行中，于是会<strong>继续解析模板，直到遇到下一个</strong> <code>&lt;p&gt;</code> 标签。这时“状态机 1”会再次调用 parseElement 函数解析标签节点，因此又会执行压栈并开启新的“状态机 3”：</p> <p><img src="/vivien-blog/assets/img/16-10.d7a1ad1c.png" alt="开启状态机3"></p> <p>​	此时“状态机 3”拥有程序的执行权，它会继续<strong>解析模板，直到遇到结束标签</strong><code>&lt;/p&gt;</code>。因为这是一个结束标签，并且在父级节点栈中存在与该结束标签同名的标签节点，所以“状态机 3”会<strong>停止</strong>运行，并<strong>弹出</strong>父级节点栈中处于栈顶的节点：</p> <p><img src="/vivien-blog/assets/img/16-11.553651d8.png" alt="状态机3停止运行"></p> <p>​	当“状态机 3”停止运行后，程序的执行权交还给“状态机 1”。“状态机 1”会继续解析模板，直到遇到最后的 <code>&lt;/div&gt;</code> 结束标签。这时“状态机 1”发现父级节点栈中存在与结束标签同名的标签节点，于是将该节点<strong>弹出</strong>父级节点栈，并<strong>停止</strong>运行：</p> <p><img src="/vivien-blog/assets/img/16-12.9cdeb922.png" alt="状态机1停止"></p> <p>​	这时父级节点栈为空，状态机全部停止运行，模板解析完毕。</p> <p>​	通过上面的描述，我们能够清晰地认识到，解析器会在何时开启新的状态机，以及状态机会在何时停止。结论是：<strong>当解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机。当解析器遇到结束标签，并且父级节点栈中存在与该标签同名的开始标签节点时，会停止当前正在运行的状态机。</strong></p> <p>​	根据上述规则，我们可以给出 <code>isEnd</code> 函数的逻辑：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">isEnd</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 当模板内容解析完毕后，停止</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token comment">// 获取父级标签节点</span>
   <span class="token keyword">const</span> parent <span class="token operator">=</span> ancestors<span class="token punctuation">[</span>ancestors<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
   <span class="token comment">// 如果遇到结束标签，并且该标签与父级标签节点同名，则停止</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>parent<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>​	上面这段代码展示了状态机的停止时机，具体如下：</p> <ul><li>第一个停止时机是当<strong>模板内容被解析完毕时</strong>；</li> <li>第二个停止时机则是在<strong>遇到结束标签时</strong>，这时解析器会取得父级节点栈栈顶的节点作为父节点，检查该结束标签是否与父节点的标签同名，如果相同，则状态机停止运行。</li></ul></blockquote> <h4 id="停止时机判断"><a href="#停止时机判断" class="header-anchor">#</a> 停止时机判断</h4> <h5 id="方式一"><a href="#方式一" class="header-anchor">#</a> 方式一</h5> <p>​	注意，在第二个停止时机中，我们直接比较结束标签的名称与栈顶节点的标签名称。这么做的确可行，但严格来讲是有瑕疵的。例如下面的模板所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	观察上述模板，它存在一个明显的问题，实际上，这段模板有两种解释方式，下图给出了第一种：</p> <p><img src="/vivien-blog/assets/img/16-13.9840f9b2.png" alt="第一种模板解释方式"></p> <blockquote><p>这种解释方式的流程如下：</p> <ul><li>“状态机 1”遇到 <code>&lt;div&gt;</code> 开始标签，调用 parseElement 解析函数，这会开启“状态机 2”来完成子节点的解析。</li> <li>“状态机 2”遇到 <code>&lt;span&gt;</code> 开始标签，调用 parseElement 解析函数，这会开启“状态机 3”来完成子节点的解析。</li> <li>“状态机 3”遇到 <code>&lt;/div&gt;</code> 结束标签。由于此时父级节点栈栈顶的节点名称是<code>span</code>，并不是 <code>div</code>，所以“状态机 3”不会停止运行。这时，“状态机 3”遭遇了不符合预期的状态，因为结束标签 <code>&lt;/div&gt;</code> 缺少与之对应的开始标签，所以这时“状态机 3”会抛出错误：“无效的结束标签”。</li></ul></blockquote> <p>​	上述流程的思路与我们当前的实现相符，状态机会遭遇不符合预期的状态。下面 parseChildren 函数的代码能够体现这一点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

   <span class="token keyword">const</span> <span class="token punctuation">{</span> mode <span class="token punctuation">}</span> <span class="token operator">=</span> context

   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnd</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">let</span> node

     <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">||</span> mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">RCDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">===</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span> <span class="token operator">&amp;&amp;</span> context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&lt;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'!'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 省略部分代码</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 状态机遭遇了闭合标签，此时应该抛出错误，因为它缺少与之对应的开始标签</span>
           <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'无效的结束标签'</span><span class="token punctuation">)</span>
           <span class="token keyword">continue</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 省略部分代码</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'{{'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 省略部分代码</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> nodes
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>换句话说，按照我们当前的实现思路来解析上述例子中的模板，最终得到的错误信息是：“无效的结束标签”。</p></blockquote> <h5 id="方式二"><a href="#方式二" class="header-anchor">#</a> 方式二</h5> <p>​	但其实还有另外一种更好的解析方式。观察上例中给出的模板，其中存在一段完整的内容：</p> <p><img src="/vivien-blog/assets/img/16-14.41cb9cfc.png" alt="第二种模板解释方式"></p> <blockquote><p>模板中存在一段完整的内容，我们希望解析器可以正常对其进行解析，这很可能也是符合用户意图的。但实际上，无论哪一种解释方式，对程序的影响都不大。两者的区别体现在错误处理上。</p> <ul><li>对于第一种解释方式，我们得到的错误信息是：“无效的结束标签”。</li> <li>对于第二种解释方式，在“完整的内容”部分被解析完毕后，解析器就会打印错误信息：“<code>&lt;span&gt;</code> 标签缺少闭合标签”。</li></ul> <p>很显然，第二种解释方式更加合理。</p></blockquote> <p>​	为了实现第二种解释方式，我们需要调整 <code>isEnd</code> 函数的逻辑。当判断状态机是否应该停止时，我们不应该总是与栈顶的父级节点做比较，而是应该<strong>与整个父级节点栈中的所有节点做比较</strong>。只要父级节点栈中存在与当前遇到的结束标签同名的节点，就停止状态机：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">isEnd</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>

   <span class="token comment">// 与父级节点栈内所有节点做比较</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> ancestors<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 只要栈中存在与当前结束标签同名的节点，就停止状态机</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>ancestors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token boolean">true</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​	按照新的思路再次对如下模板执行解析：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>这种解释方式的流程如下：</p> <ul><li>“状态机 1”遇到 <code>&lt;div&gt;</code> 开始标签，调用 parseElement 解析函数，并开启“状态机 2”解析子节点。</li> <li>“状态机 2”遇到 <code>&lt;span&gt;</code> 开始标签，调用 parseElement 解析函数，并开启“状态机 3”解析子节点。</li> <li>“状态机 3”遇到 <code>&lt;/div&gt;</code> 结束标签，由于节点栈中存在名为 <code>div</code> 的标签节点，于是“状态机 3”停止了。</li></ul></blockquote> <p>​	在这个过程中，“状态机 2”在调用 parseElement 解析函数时，parseElement函数能够发现 <code>&lt;span&gt;</code> 缺少闭合标签，于是会打印错误信息“<code>&lt;span&gt;</code> 标签缺少闭合标签”：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseElement</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>isSelfClosing<span class="token punctuation">)</span> <span class="token keyword">return</span> element

   ancestors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
   element<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span>
   ancestors<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>element<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token string">'end'</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 缺少闭合标签</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>element<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 标签缺少闭合标签</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> element
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="解析标签节点"><a href="#解析标签节点" class="header-anchor">#</a> 解析标签节点</h2> <p>​	在前面给出的 parseElement 函数的实现中，无论是解析<strong>开始</strong>标签还是<strong>闭合</strong>标签，我们都调用了 <strong>parseTag</strong> 函数。同时，我们使用 <strong>parseChildren</strong> 函数来解析开始标签与闭合标签<strong>中间的部分</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseElement</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 调用 parseTag 函数解析开始标签</span>
   <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>isSelfClosing<span class="token punctuation">)</span> <span class="token keyword">return</span> element

   ancestors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
   element<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span>
   ancestors<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>element<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 再次调用 parseTag 函数解析结束标签，传递了第二个参数：'end'</span>
     <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token string">'end'</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>element<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 标签缺少闭合标签</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> element
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>​	标签节点的整个解析过程如下：</p> <p><img src="/vivien-blog/assets/img/16-15.97cd11b3.png" alt="解析标签节点的过程"></p> <p>​	注意，由于开始标签与结束标签的格式非常类似，所以我们统一使用 parseTag 函数处理，并通过该函数的第二个参数来指定具体的处理类型。当第二个参数值为字符串 'end' 时，意味着解析的是结束标签。另外，**无论处理的是开始标签还是结束标签，parseTag 函数都会消费对应的内容。**为了实现对模板内容的消费，我们需要在上下文对象中新增两个工具函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 上下文对象</span>
   <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 模板内容</span>
     source<span class="token operator">:</span> str<span class="token punctuation">,</span>
     mode<span class="token operator">:</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span><span class="token punctuation">,</span>
     <span class="token comment">// advanceBy 函数用来消费指定数量的字符，它接收一个数字作为参数</span>
     <span class="token function">advanceBy</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 根据给定字符数 num，截取位置 num 后的模板内容，并替换当前模板内容</span>
       context<span class="token punctuation">.</span>source <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token comment">// 无论是开始标签还是结束标签，都可能存在无用的空白字符，例如 &lt;div    &gt;</span>
     <span class="token function">advanceSpaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 匹配空白字符</span>
       <span class="token keyword">const</span> match <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[\t\r\n\f ]+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 调用 advanceBy 函数消费空白字符</span>
         context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> nodes <span class="token operator">=</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
     children<span class="token operator">:</span> nodes
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><blockquote><p>为上下文对象增加了 advanceBy 函数和advanceSpaces 函数。其中，</p> <p><strong>advanceBy 函数用来消费指定数量的字符</strong>。其实现原理很简单，即调用字符串的 <code>slice</code> 函数，根据指定位置截取剩余字符串，并使用截取后的结果作为新的模板内容。</p> <p><strong>advanceSpaces 函数则用来消费无用的空白字符</strong>，因为标签中可能存在空白字符，例如在模板 <code>&lt;div----&gt;</code> 中减号（-）代表空白字符。</p></blockquote> <p>​	有了 advanceBy 和 advanceSpaces 函数后，我们就可以给出 parseTag 函数的实现了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 由于 parseTag 既用来处理开始标签，也用来处理结束标签，因此我们设计第二个参数 type，</span>
 <span class="token comment">// 用来代表当前处理的是开始标签还是结束标签，type 的默认值为 'start'，即默认作为开始标签处理</span>
 <span class="token keyword">function</span> <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token string">'start'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 从上下文对象中拿到 advanceBy 函数</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> advanceBy<span class="token punctuation">,</span> advanceSpaces <span class="token punctuation">}</span> <span class="token operator">=</span> context

   <span class="token comment">// 处理开始标签和结束标签的正则表达式不同</span>
   <span class="token keyword">const</span> match <span class="token operator">=</span> type <span class="token operator">===</span> <span class="token string">'start'</span>
     <span class="token comment">// 匹配开始标签</span>
     <span class="token operator">?</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&lt;([a-z][^\t\r\n\f /&gt;]*)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
     <span class="token comment">// 匹配结束标签</span>
     <span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&lt;\/([a-z][^\t\r\n\f /&gt;]*)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
   <span class="token comment">// 匹配成功后，正则表达式的第一个捕获组的值就是标签名称</span>
   <span class="token keyword">const</span> tag <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
   <span class="token comment">// 消费正则表达式匹配的全部内容，例如 '&lt;div' 这段内容</span>
   <span class="token function">advanceBy</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token comment">// 消费标签中无用的空白字符</span>
   <span class="token function">advanceSpaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token comment">// 在消费匹配的内容后，如果字符串以 '/&gt;' 开头，则说明这是一个自闭合标签</span>
   <span class="token keyword">const</span> isSelfClosing <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'/&gt;'</span><span class="token punctuation">)</span>
   <span class="token comment">// 如果是自闭合标签，则消费 '/&gt;'， 否则消费 '&gt;'</span>
   <span class="token function">advanceBy</span><span class="token punctuation">(</span>isSelfClosing <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span>

   <span class="token comment">// 返回标签节点</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
     <span class="token comment">// 标签名称</span>
     tag<span class="token punctuation">,</span>
     <span class="token comment">// 标签的属性暂时留空</span>
     props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token comment">// 子节点留空</span>
     children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token comment">// 是否自闭合</span>
     isSelfClosing
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><blockquote><p>上面这段代码有两个关键点：</p> <ul><li>由于 parseTag 函数既用于解析开始标签，又用于解析结束标签，因此<strong>需要用一个参数来标识当前处理的标签类型</strong>，即 type。</li> <li>对于开始标签和结束标签，用于匹配它们的正则表达式只有一点不同：结束标签是以字符串 <code>&lt;/</code> 开头的。</li></ul></blockquote> <p>​	下图给出了用于匹配开始标签的正则表达式的含义：</p> <p><img src="/vivien-blog/assets/img/16-16.daeef16d.png" alt="用于匹配开始标签和结束标签的正则"></p> <blockquote><p>下面给出了几个使用上图所示的正则来匹配开始标签的例子：</p> <ul><li>对于字符串 <code>'&lt;div&gt;'</code>，会匹配出字符串 <code>'&lt;div'，剩余 '&gt;'</code>。</li> <li>对于字符串 <code>'&lt;div/&gt;'</code>，会匹配出字符串 <code>'&lt;div'，剩余 '/&gt;'</code>。</li> <li>对于字符串 <code>'&lt;div----&gt;'</code>，其中减号（-）代表空白符，会匹配出字符串 <code>'&lt;div'，剩余 '----&gt;'</code>。</li></ul> <p>另外，图中所示的正则拥有一个捕获组，它用来捕获标签名称。</p> <p>除了正则表达式外，parseTag 函数的另外几个关键点如下：</p> <ul><li>在完成正则匹配后，<strong>需要调用 advanceBy 函数消费由正则匹配的全部内容。</strong></li> <li>根据上面给出的第三个正则匹配例子可知，由于标签中可能存在无用的空白字符，例如 <code>&lt;div----&gt;</code>，因此我们<strong>需要调用 advanceSpaces 函数消费空白字符。</strong></li> <li>在消费由正则匹配的内容后，**需要检查剩余模板内容是否以字符串 <code>/&gt;</code> 开头。**如果是，则说明当前解析的是一个自闭合标签，这时需要将标签节点的<code>isSelfClosing</code> 属性设置为 true。</li> <li>最后，**判断标签是否自闭合。**如果是，则调用 advnaceBy 函数消费内容 <code>/&gt;</code>，否则只需要消费内容 <code>&gt;</code> 即可。</li></ul></blockquote> <p>​	在经过上述处理后，parseTag 函数会返回一个标签节点。<strong>parseElement 函数在得到由 parseTag 函数产生的标签节点后，需要根据节点的类型完成文本模式的切换</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseElement</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>isSelfClosing<span class="token punctuation">)</span> <span class="token keyword">return</span> element

   <span class="token comment">// 切换到正确的文本模式</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'textarea'</span> <span class="token operator">||</span> element<span class="token punctuation">.</span>tag <span class="token operator">===</span> <span class="token string">'title'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果由 parseTag 解析得到的标签是 &lt;textarea&gt; 或 &lt;title&gt;，则切换到 RCDATA 模式</span>
     context<span class="token punctuation">.</span>mode <span class="token operator">=</span> TextModes<span class="token punctuation">.</span><span class="token constant">RCDATA</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">style|xmp|iframe|noembed|noframes|noscript</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果由 parseTag 解析得到的标签是：</span>
     <span class="token comment">// &lt;style&gt;、&lt;xmp&gt;、&lt;iframe&gt;、&lt;noembed&gt;、&lt;noframes&gt;、&lt;noscript&gt;</span>
     <span class="token comment">// 则切换到 RAWTEXT 模式</span>
     context<span class="token punctuation">.</span>mode <span class="token operator">=</span> TextModes<span class="token punctuation">.</span><span class="token constant">RAWTEXT</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 否则切换到 DATA 模式</span>
     context<span class="token punctuation">.</span>mode <span class="token operator">=</span> TextModes<span class="token punctuation">.</span><span class="token constant">DATA</span>
   <span class="token punctuation">}</span>

   ancestors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
   element<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">parseChildren</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> ancestors<span class="token punctuation">)</span>
   ancestors<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>element<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token string">'end'</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>element<span class="token punctuation">.</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 标签缺少闭合标签</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> element
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>至此，我们就实现了对标签节点的解析。但是目前的实现忽略了节点中的属性和指令。</p> <h2 id="解析属性"><a href="#解析属性" class="header-anchor">#</a> 解析属性</h2> <p>​	parseTag 解析函数会消费整个开始标签，这意味着该函数需要有能力处理开始标签中存在属性与指令，例如：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>display<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>div 标签存在一个 id 属性和一个 <code>v-show</code> 指令。</p></blockquote> <p>​	为了处理属性和指令，我们需要在 parseTag 函数中增加 parseAttributes 解析函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseTag</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token string">'start'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> advanceBy<span class="token punctuation">,</span> advanceSpaces <span class="token punctuation">}</span> <span class="token operator">=</span> context

   <span class="token keyword">const</span> match <span class="token operator">=</span> type <span class="token operator">===</span> <span class="token string">'start'</span>
     <span class="token operator">?</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&lt;([a-z][^\t\r\n\f /&gt;]*)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
     <span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&lt;\/([a-z][^\t\r\n\f /&gt;]*)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
   <span class="token keyword">const</span> tag <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

   <span class="token function">advanceBy</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token function">advanceSpaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 parseAttributes 函数完成属性与指令的解析，并得到 props 数组，</span>
   <span class="token comment">// props 数组是由指令节点与属性节点共同组成的数组</span>
   <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">parseAttributes</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>

   <span class="token keyword">const</span> isSelfClosing <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'/&gt;'</span><span class="token punctuation">)</span>
   <span class="token function">advanceBy</span><span class="token punctuation">(</span>isSelfClosing <span class="token operator">?</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span>

   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
     tag<span class="token punctuation">,</span>
     props<span class="token punctuation">,</span> <span class="token comment">// 将 props 数组添加到标签节点上</span>
     children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     isSelfClosing
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>​	这段代码的关键点之一是，我们需要**在消费标签的“开始部分”和无用的空白字符之后，再调用 parseAttribute 函数。**举个例子，假设标签的内容如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>display<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	标签的“开始部分”指的是字符串 <code>&lt;div</code>，所以当消耗标签的“开始部分”以及无用空白字符后，剩下的内容为：</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>id=&quot;foo&quot; v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这段内容才是 <strong>parseAttributes</strong> 函数要处理的内容。由于该函数<strong>只用来解析属性和指令</strong>，因此它会<strong>不断地消费上面这段模板内容，直到遇到标签的“结束部分”为止</strong>。其中，结束部分指的是字符 <code>&gt;</code> 或者字符串 <code>/&gt;</code>。据此我们可以给出 parseAttributes 函数的整体框架：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseAttributes</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 用来存储解析过程中产生的属性节点和指令节点</span>
   <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

   <span class="token comment">// 开启 while 循环，不断地消费模板内容，直至遇到标签的“结束部分”为止</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>
     <span class="token operator">!</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&gt;'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
     <span class="token operator">!</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'/&gt;'</span><span class="token punctuation">)</span>
   <span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 解析属性或指令</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 将解析结果返回</span>
   <span class="token keyword">return</span> props
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​	实际上，<strong>parseAttributes 函数消费模板内容的过程，就是不断地解析属性名称、等于号、属性值的过程</strong>：</p> <p><img src="/vivien-blog/assets/img/16-17.0cc7984c.png" alt="属性的格式"></p> <h3 id="parseattributes-函数"><a href="#parseattributes-函数" class="header-anchor">#</a> parseAttributes 函数</h3> <p>​	parseAttributes 函数会按照<strong>从左到右</strong>的顺序不断地消费字符串。以上图为例，该函数的解析过程如下：</p> <p>​	首先，解析出第一个属性的名称 id，并消费字符串 'id'。此时剩余模板内容为：</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>=&quot;foo&quot; v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	在解析属性名称时，除了要消费属性名称之外，<strong>还要消费属性名称后面可能存在的空白字符</strong>。如下面这段模板中，属性名称和等于号之间存在空白字符：</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>id  =  &quot;foo&quot; v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	但无论如何，在属性名称解析完毕之后，<strong>模板剩余内容一定是以等于号开头的</strong>，即：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code>&quot;foo&quot; v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>如果消费属性名称之后，模板内容<strong>不以等于号开头</strong>，则说明模板内容<strong>不合法</strong>，我们可以选择性地抛出错误。</p></blockquote> <p>​	接着，我们需要消费等于号字符。由于等于号和属性值之间也可能存在空白字符，所以我们也<strong>需要消费对应的空白字符</strong>。在这一步操作过后，模板的剩余内容如下：</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>&quot;foo&quot; v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>接下来，到了处理属性值的环节。模板中的属性值存在三种情况：</p> <ul><li>属性值被双引号包裹：id=&quot;foo&quot;。</li> <li>属性值被单引号包裹：id='foo'。</li> <li>属性值没有引号包裹：id=foo。</li></ul></blockquote> <p>​	按照上述例子，此时模板的内容一定以双引号（&quot;）开头。因此我们可以<strong>通过检查当前模板内容是否以引号开头来确定属性值是否被引用</strong>。如果属性值被引号引用，则消费引号。此时模板的剩余内容为：</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>foo&quot; v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>既然属性值被引号引用了，就意味着在剩余模板内容中，<strong>下一个引号之前</strong>的内容都应该被解析为属性值。在这个例子中，属性值的内容是字符串 foo。于是，我们消费属性值及其后面的引号。当然，如果属性值没有被引号引用，那么在剩余模板内容中，<strong>下一个空白字符之前</strong>的所有字符都应该作为属性值。</p></blockquote> <p>​	当属性值和引号被消费之后，由于属性值与下一个属性名称之间可能存在空白字符，所以我们<strong>还要消费对应的空白字符</strong>。在这一步处理过后，剩余模板内容为：</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>v-show=&quot;display&quot; &gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	可以看到，经过上述操作之后，第一个属性就处理完毕了。</p> <p>​	此时模板中还剩下一个指令，我们只需重新执行上述步骤，即可完成 <code>v-show</code> 指令的解析。当 <code>v-show</code> 指令解析完毕后，将会遇到标签的“结束部分”，即字符<code>&gt;</code>。这时，parseAttributes 函数中的 <code>while</code> 循环将会停止，完成属性和指令的解析。</p> <p>​	下面的 parseAttributes 函数给出了上述逻辑的具体实现：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseAttributes</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> advanceBy<span class="token punctuation">,</span> advanceSpaces <span class="token punctuation">}</span> <span class="token operator">=</span> context
   <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

   <span class="token keyword">while</span> <span class="token punctuation">(</span>
     <span class="token operator">!</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'&gt;'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
     <span class="token operator">!</span>context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'/&gt;'</span><span class="token punctuation">)</span>
   <span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 该正则用于匹配属性名称</span>
     <span class="token keyword">const</span> match <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
     <span class="token comment">// 得到属性名称</span>
     <span class="token keyword">const</span> name <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

     <span class="token comment">// 消费属性名称</span>
     <span class="token function">advanceBy</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
     <span class="token comment">// 消费属性名称与等于号之间的空白字符</span>
     <span class="token function">advanceSpaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token comment">// 消费等于号</span>
     <span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
     <span class="token comment">// 消费等于号与属性值之间的空白字符</span>
     <span class="token function">advanceSpaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

     <span class="token comment">// 属性值</span>
     <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">''</span>

     <span class="token comment">// 获取当前模板内容的第一个字符</span>
     <span class="token keyword">const</span> quote <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
     <span class="token comment">// 判断属性值是否被引号引用</span>
     <span class="token keyword">const</span> isQuoted <span class="token operator">=</span> quote <span class="token operator">===</span> <span class="token string">'&quot;'</span> <span class="token operator">||</span> quote <span class="token operator">===</span> <span class="token string">&quot;'&quot;</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span>isQuoted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 属性值被引号引用，消费引号</span>
       <span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
       <span class="token comment">// 获取下一个引号的索引</span>
       <span class="token keyword">const</span> endQuoteIndex <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>quote<span class="token punctuation">)</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>endQuoteIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 获取下一个引号之前的内容作为属性值</span>
         value <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> endQuoteIndex<span class="token punctuation">)</span>
         <span class="token comment">// 消费属性值</span>
         <span class="token function">advanceBy</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
         <span class="token comment">// 消费引号</span>
         <span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 缺少引号错误</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'缺少引号'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 代码运行到这里，说明属性值没有被引号引用</span>
       <span class="token comment">// 下一个空白字符之前的内容全部作为属性值</span>
       <span class="token keyword">const</span> match <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[^\t\r\n\f &gt;]+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>source<span class="token punctuation">)</span>
       <span class="token comment">// 获取属性值</span>
       value <span class="token operator">=</span> match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
       <span class="token comment">// 消费属性值</span>
       <span class="token function">advanceBy</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 消费属性值后面的空白字符</span>
     <span class="token function">advanceSpaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

     <span class="token comment">// 使用属性名称 + 属性值创建一个属性节点，添加到 props 数组中</span>
     props<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span>
       name<span class="token punctuation">,</span>
       value
     <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token punctuation">}</span>
   <span class="token comment">// 返回</span>
   <span class="token keyword">return</span> props
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br></div></div><p>在上面这段代码中，有两个重要的正则表达式：</p> <ul><li><code>/^[^\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</code>，用来匹配<strong>属性名称</strong>；</li> <li><code>/^[^\t\r\n\f &gt;]+/</code>，用来匹配<strong>没有使用引号引用的属性值</strong>。</li></ul> <p>​	我们分别来看看这两个正则表达式是如何工作的。</p> <h3 id="匹配原理"><a href="#匹配原理" class="header-anchor">#</a> 匹配原理</h3> <p>1、下图给出了用于匹配属性名称的正则表达式的匹配原理：</p> <p><img src="/vivien-blog/assets/img/16-18.7a8be8e4.png" alt="用于匹配属性的正则"></p> <blockquote><p>可以将这个正则表达式分为 A、B 两个部分来看：</p> <ul><li>部分 A 用于匹配<strong>一个位置</strong>，这个位置不能是空白字符，也不能是字符 <code>/</code> 或字符 <code>&gt;</code>，并且字符串要以该位置开头。</li> <li>部分 B 则用于匹配 <strong>0 个或多个位置</strong>，这些位置不能是空白字符，也不能是字符 <code>/</code>、<code>&gt;</code>、<code>=</code>。注意，这些位置不允许出现等于号（=）字符，这就实现了只匹配等于号之前的内容，即属性名称。</li></ul></blockquote> <p>2、下图给出了第二个正则表达式的匹配原理：</p> <p><img src="/vivien-blog/assets/img/16-19.cb2033f5.png" alt="第二个正则表达式的匹配原理"></p> <blockquote><p>该正则表达式从字符串的<strong>开始位置</strong>进行匹配，并且会匹配<strong>一个或多个</strong>非空白字符、非字符 <code>&gt;</code>。</p> <p>换句话说，该正则表达式会一直对字符串进行匹配，直到遇到空白字符或字符 <code>&gt;</code> 为止，这就实现了属性值的提取。</p></blockquote> <p>​	配合 parseAttributes 函数，假设给出如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>display<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	解析上面这段模板，将会得到如下 AST：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       props<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token comment">// 属性</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'id'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'v-show'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'display'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>可以看到，在 <code>div</code> 标签节点的 props 属性中，包含两个类型为 Attribute 的节点，这两个节点就是 parseAttributes 函数的解析结果。</p></blockquote> <p>​	我们可以增加更多在 Vue.js 中常见的属性和指令进行测试，如以下模板所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dynamicId<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handler<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>mousedown</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onMouseDown<span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	上面这段模板经过解析后，得到如下 AST：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       props<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token comment">// 属性</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">':id'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'dynamicId'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'@click'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'handler'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'v-on:mousedown'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'onMouseDown'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>可以看到，在类型为 Attribute 的属性节点中，其 <strong>name 字段完整地保留着模板中编写的属性名称</strong>。</p></blockquote> <p>​	我们可以对属性名称做进一步的分析，从而得到更具体的信息。</p> <p>​	例如，属性名称以字符 @ 开头，则认为它是一个 v-on 指令绑定。我们甚至可以把以 v- 开头的属性看作指令绑定，从而为它赋予不同的节点类型，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 指令，类型为 Directive</span>
 <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Directive'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'v-on:mousedown'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'onMouseDown'</span> <span class="token punctuation">}</span>
 <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Directive'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'@click'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'handler'</span> <span class="token punctuation">}</span>
 <span class="token comment">// 普通属性</span>
 <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Attribute'</span><span class="token punctuation">,</span> name<span class="token operator">:</span> <span class="token string">'id'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>不仅如此，为了得到更加具体的信息，我们甚至可以进一步分析指令节点的数据，也可以设计更多语法规则，这完全取决于框架设计者在语法层面的设计，以及为框架赋予的能力。</p></blockquote> <h2 id="解析文本与解码-html-实体"><a href="#解析文本与解码-html-实体" class="header-anchor">#</a> 解析文本与解码 HTML 实体</h2> <h3 id="解析文本"><a href="#解析文本" class="header-anchor">#</a> 解析文本</h3> <p>​	给出如下模板：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token string">'&lt;div&gt;Text&lt;/div&gt;'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>解析器在解析上面这段模板时，会先经过 parseTag 函数的处理，这会消费标签的开始部分 <code>'&lt;div&gt;'</code>。</p></blockquote> <p>​	处理完毕后，剩余模板内容为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token string">'Text&lt;/div&gt;'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	紧接着，解析器会调用 parseChildren 函数，开启一个新的状态机来处理这段模板。我们来回顾一下状态机的状态迁移过程：</p> <p><img src="/vivien-blog/assets/img/16-20.81436c1a.png" alt="parseChildren函数在解析模板过程中的状态迁移过程"></p> <p>​	状态机始于“状态 1”。在“状态 1”下，读取模板的第一个字符 T，由于该字符既不是字符 <code>&lt;</code>，也不是插值定界符 <code>{{</code>，因此状态机会进入“状态 7”，即调用 parseText 函数处理文本内容。此时解析器会在模板中寻找下一个 <code>&lt;</code> 字符或插值定界符 <code>{{</code> 的位置索引，记为索引 I。然后，解析器会从模板的头部到索引 I 的位置截取内容，这段截取出来的字符串将作为文本节点的内容。</p> <p>​	以下面的模板内容为例：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token string">'Text&lt;/div&gt;'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>parseText 函数会尝试在这段模板内容中找到<strong>第一个出现的字符 <code>&lt;</code> 的位置索引</strong>。在这个例子中，字符 <code>&lt;</code> 的索引值为 4。然后，parseText 函数会截取介于索引 [0,4) 的内容作为文本内容。在这个例子中，文本内容就是字符串 'Text'。</p></blockquote> <p>​	假设模板中存在插值，如下面的模板所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token string">'Text-{{ val }}&lt;/div&gt;'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>在处理这段模板时，parseText 函数会找到<strong>第一个插值定界符 <code>{{</code> 出现的位置索引</strong>。在这个例子中，定界符的索引为 5。于是，parseText 函数会截取介于索引[0, 5) 的内容作为文本内容。在这个例子中，文本内容就是字符串 'Text-'。</p></blockquote> <p>​	下面的 parseText 函数给出了具体实现：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseText</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// endIndex 为文本内容的结尾索引，默认将整个模板剩余内容都作为文本内容</span>
   <span class="token keyword">let</span> endIndex <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span>length
   <span class="token comment">// 寻找字符 &lt; 的位置索引</span>
   <span class="token keyword">const</span> ltIndex <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'&lt;'</span><span class="token punctuation">)</span>
   <span class="token comment">// 寻找定界符 {{ 的位置索引</span>
   <span class="token keyword">const</span> delimiterIndex <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'{{'</span><span class="token punctuation">)</span>

   <span class="token comment">// 取 ltIndex 和当前 endIndex 中较小的一个作为新的结尾索引</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>ltIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> ltIndex <span class="token operator">&lt;</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     endIndex <span class="token operator">=</span> ltIndex
   <span class="token punctuation">}</span>
   <span class="token comment">// 取 delimiterIndex 和当前 endIndex 中较小的一个作为新的结尾索引</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>delimiterIndex <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> delimiterIndex <span class="token operator">&lt;</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     endIndex <span class="token operator">=</span> delimiterIndex
   <span class="token punctuation">}</span>

   <span class="token comment">// 此时 endIndex 是最终的文本内容的结尾索引，调用 slice 函数截取文本内容</span>
   <span class="token keyword">const</span> content <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> endIndex<span class="token punctuation">)</span>
   <span class="token comment">// 消耗文本内容</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span>length<span class="token punctuation">)</span>

   <span class="token comment">// 返回文本节点</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     <span class="token comment">// 节点类型</span>
     type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span>
     <span class="token comment">// 文本内容</span>
     content
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><blockquote><p>由于字符 <code>&lt;</code> 与定界符 <code>{{</code> 的出现顺序是未知的，所以我们需要取两者中较小的一个作为文本截取的终点。有了截取终点后，只需要调用字符串的 <code>slice</code> 函数对字符串进行截取即可，截取出来的内容就是文本节点的文本内容。最后，我们创建一个类型为 Text 的文本节点，将其作为 parseText 函数的返回值。</p></blockquote> <p>​	配合上述 parseText 函数解析如下模板：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;Text&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	得到如下 AST：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       isSelfClosing<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token comment">// 文本节点</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span> content<span class="token operator">:</span> <span class="token string">'Text'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>​	这样，我们就实现了对文本节点的解析。解析文本节点本身并不复杂，复杂点在于，我们<strong>需要对解析后的文本内容进行 HTML 实体的解码工作</strong>。为此，我们有必要先了解什么是 HTML 实体。</p> <h3 id="解码命名字符引用"><a href="#解码命名字符引用" class="header-anchor">#</a> 解码命名字符引用</h3> <h4 id="html-实体"><a href="#html-实体" class="header-anchor">#</a> HTML 实体</h4> <p>​	**HTML 实体是一段以字符 &amp; 开始的文本内容。实体用来描述 HTML 中的保留字符和一些难以通过普通键盘输入的字符，以及一些不可见的字符。**例如，在 HTML中，字符 <code>&lt;</code> 具有特殊含义，如果希望以普通文本的方式来显示字符 <code>&lt;</code>，需要通过实体来表达：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>A<span class="token entity named-entity" title="&lt;">&amp;lt;</span>B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	其中字符串 <code>&amp;lt;</code> 就是一个 HTML 实体，用来表示字符 <code>&lt;</code>。如果我们不用 HTML实体，而是直接使用字符 <code>&lt;</code>，那么将会产生非法的 HTML 内容：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>A&lt;B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>这会导致浏览器的解析结果不符合预期。</p></blockquote> <p>​	<strong>HTML 实体总是以字符 <code>&amp;</code> 开头，以字符 <code>;</code> 结尾。<strong>在 Web 诞生的初期，HTML 实体的数量较少，因此</strong>允许省略</strong>其中的尾分号。但随着 HTML 字符集越来越大，HTML 实体出现了包含的情况，例如 <code>&amp;lt</code> 和 <code>&amp;ltcc</code> 都是合法的实体，如果不加分号，浏览器将无法区分它们。因此，WHATWG 规范中明确规定，<strong>如果不为实体加分号，将会产生解析错误</strong>。但考虑到历史原因（互联网上存在大量省略分号的情况），现代浏览器都<strong>能够解析</strong>早期规范中定义的那些可以省略分号的 HTML 实体。</p> <h4 id="命名字符引用"><a href="#命名字符引用" class="header-anchor">#</a> 命名字符引用</h4> <p>​	  HTML 实体有两类，一类叫作<strong>命名字符引用</strong>（named character reference），也叫<strong>命名实体</strong>（named entity），顾名思义，这类实体<strong>具有特定的名称</strong>，例如上文中的 <code>&amp;lt;</code>。WHATWG 规范中给出了全部的命名字符引用，有 2000 多个，可以通过命名字符引用表查询。下面列出了部分内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 共 2000+</span>
 <span class="token punctuation">{</span>
   <span class="token string-property property">&quot;GT&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&gt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;gt&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&gt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;LT&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&lt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;lt&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&lt;&quot;</span><span class="token punctuation">,</span>
   <span class="token comment">// 省略部分代码</span>
   <span class="token string-property property">&quot;awint;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;⨑&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;bcong;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;≌&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;bdquo;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;„&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;bepsi;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;϶&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;blank;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;␣&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;blk12;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;▒&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;blk14;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;░&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;blk34;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;▓&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;block;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;█&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;boxDL;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;╗&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;boxDl;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;╖&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;boxdL;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;╕&quot;</span><span class="token punctuation">,</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="数字字符引用"><a href="#数字字符引用" class="header-anchor">#</a> 数字字符引用</h4> <p>​	除了命名字符引用之外，还有一类字符引用<strong>没有特定的名称</strong>，<strong>只能用数字表示</strong>，这类实体叫作<strong>数字字符引用</strong>（numeric character reference）。与命名字符引用不同，数字字符引用以字符串 <code>&amp;#</code> 开头，比命名字符引用的开头部分多出了字符 <code>#</code>，例如 <code>&amp;#60;</code>。实际上， <code>&amp;#60;</code> 对应的字符也是 <code>&lt;</code>，换句话说， <code>&amp;#60;</code>与 <code>&amp;lt;</code>是等价的。数字字符引用既可以用十进制来表示，也可以使用十六进制来表示。例如，十进制数字 60 对应的十六进制值为 3c，因此实体 <code>&amp;#60;</code>也可以表示为<code>&amp;#x3c;</code>。可以看到，当使用十六进制数表示实体时，需要以字符串 <code>&amp;#x</code> 开头。</p> <p>​	理解了 HTML 实体后，我们再来讨论为什么 Vue.js 模板的解析器要对文本节点中的 HTML 实体进行解码。为了理解这个问题，我们需要先明白一个大前提：在 Vue.js 模板中，文本节点所包含的 HTML 实体不会被浏览器解析。这是因为<strong>模板中的文本节点最终将通过如 <code>el.textContent</code> 等文本操作方法设置到页面，而通过 el.textContent 设置的文本内容是不会经过 HTML 实体解码的</strong>，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">'&amp;lt;'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>最终 el 的文本内容将会原封不动地呈现为字符串<code>'&amp;lt;'</code>，而不会呈现字符 <code>&lt;</code>。这就意味着，如果用户在 Vue.js 模板中编写了 HTML 实体，而模板解析器不对其进行解码，那么最终渲染到页面的内容将不符合用户的预期。因此，我们应该<strong>在解析阶段对文本节点中存在的 HTML 实体进行解码</strong>。</p></blockquote> <p>​	模板解析器的解码行为应该与浏览器的行为一致。因此，我们应该按照WHATWG 规范实现解码逻辑。规范中明确定义了解码 HTML 实体时状态机的状态迁移流程。下图给出了简化版的状态迁移流程，我们会在后文中对其进行补充：</p> <p><img src="/vivien-blog/assets/img/16-21.44630a78.png" alt="image-20240914114001012"></p> <blockquote><p>假定状态机当前处于初始的 DATA 模式。当解析器遇到字符 <code>&amp;</code> 时，会进入“<strong>字符引用状态</strong>”，并消费字符 <code>&amp;</code>，接着解析下一个字符。如果下一个字符是 ASCII 字母或数字（ASCII alphanumeric），则进入“命名字符引用状态”，其中 ASCII 字母或数字指的是 <code>0~9</code> 这十个数字以及字符集合 <code>a~z</code> 再加上字符集合 <code>A~Z</code>。当然，如果下一个字符是 <code>#</code>，则进入“<strong>数字字符引用状态</strong>”。</p></blockquote> <h4 id="进入命名字符引用状态"><a href="#进入命名字符引用状态" class="header-anchor">#</a> 进入命名字符引用状态</h4> <p>​	一旦状态机进入命名字符引用状态，解析器将会执行比较复杂的匹配流程。</p> <p>​	举个例子，</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>	a<span class="token operator">&amp;</span>ltb
<span class="token comment">// 这段文本会被解析为：</span>
	a<span class="token operator">&lt;</span>b
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	我们分析整个解析过程:</p> <p>1、当解析器遇到字符 <code>&amp;</code> 时，会<strong>进入字符引用状态</strong>。接着，解析下一个字符l，这会使得解析器<strong>进入命名字符引用状态</strong>，并在命名字符引用表（后文简称“引用表”）中查找以字符 <code>l</code> 开头的项。由于引用表中存在诸多以字符 <code>l</code> 开头的项，例如 <code>lt</code>、<code>lg</code>、<code>le</code> 等，因此解析器认为此时是“匹配”的。</p> <p>2、于是开始解析下一个字符 <code>t</code>，并尝试去引用表中查找以 <code>lt</code> 开头的项。由于引用表中也存在多个以 <code>lt</code> 开头的项，例如 <code>lt</code>、<code>ltcc;</code>、<code>ltri;</code> 等，因此解析器认为此时也是“匹配”的。</p> <p>3、于是又开始解析下一个字符 <code>b</code>，并尝试去引用表中查找以 <code>ltb</code> 开头的项，结果发现引用表中不存在符合条件的项，至此匹配结束。</p> <p>4、当匹配结束时，解析器会检查最后一个匹配的字符。如果该字符是分号（<code>;</code>），则会产生一个合法的匹配，并渲染对应字符。但在上例中，最后一个匹配的字符是字符 <code>t</code>，并不是分号（<code>;</code>），因此会产生一个解析错误，但由于历史原因，浏览器仍然能够解析它。</p> <p>​	在这种情况下，浏览器的解析规则是：<strong>最短原则</strong>。其中“最短”指的是命名字符引用的名称最短。</p> <blockquote><p>​	举个例子，假设文本内容为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>a<span class="token operator">&amp;</span>ltcc<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	我们知道 <code>&amp;ltcc;</code> 是一个合法的命名字符引用，因此上述文本会被渲染为：<code>a⪦</code>。但如果去掉上述文本中的分号，即：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>a<span class="token operator">&amp;</span>ltcc
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	解析器在处理这段文本中的实体时，最后匹配的字符将不再是分号，而是字符 <code>c</code>。按照“最短原则”，解析器只会渲染名称更短的字符引用。在字符串 <code>&amp;ltcc</code> 中，<code>&amp;lt</code> 的名称要短于 <code>&amp;ltcc</code>，因此最终会将 <code>&amp;lt</code> 作为合法的字符引用来渲染，而字符串 <code>cc</code> 将作为普通字符来渲染。所以上面的文本最终会被渲染为：<code>a&lt;cc</code>。</p></blockquote> <p>​	需要说明的是，上述解析过程<strong>仅限于不用作属性值的普通文本</strong>。换句话说，**用作属性值的文本会有不同的解析规则。**举例来说，给出如下 HTML 文本：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo.com?a=1&amp;lt=2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>foo.com?a=1&amp;lt=2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p><code>a</code> 标签的 <code>href</code> 属性值与它的文本子节点具有同样的内容，但它们被解析之后的结果不同。其中<strong>属性值</strong>中出现的 <code>&amp;lt</code> 将<strong>原封不动地展示</strong>，而<strong>文本子节点</strong>中出现的 <code>&amp;lt</code> 将会被<strong>解析为字符</strong> <code>&lt;</code>。这也是符合期望的，很明显，<code>&amp;lt=2</code> 将构成链接中的查询参数，如果将其中的 <code>&amp;lt</code> 解码为字符 <code>&lt;</code>，将会破坏用户的 <code>URL</code>。实际上，WHATWG 规范中对此也有完整的定义，出于历史原因的考虑，对于属性值中的字符引用，如果最后一个匹配的字符不是分号，并且该匹配的字符的下一个字符是等于号、ASCII 字母或数字，那么该匹配项将作为普通文本被解析。</p></blockquote> <p>​	明白了原理，我们就着手实现。我们面临的第一个问题是，如何处理省略分号的情况？关于字符引用中的分号，我们可以总结如下：</p> <ul><li>当存在分号时：执行完整匹配。</li> <li>当省略分号时：执行最短匹配。</li></ul> <p>​	为此，我们需要精心设计命名字符引用表。由于命名字符引用的数量非常多，因此这里我们只取其中一部分作为命名字符引用表的内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> namedCharacterReferences <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token string-property property">&quot;gt&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&gt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;gt;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&gt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;lt&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&lt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;lt;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&lt;&quot;</span><span class="token punctuation">,</span>
   <span class="token string-property property">&quot;ltcc;&quot;</span><span class="token operator">:</span> <span class="token string">&quot;⪦&quot;</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>观察 namedCharacterReferences 对象可以发现，<strong>相同的字符对应的实体会有多个，即带分号的版本和不带分号的版本</strong>，例如&quot;<code>gt</code>&quot; 和 &quot;<code>gt;</code>&quot;。另外<strong>一些实体则只有带分号的版本，因为这些实体不允许省略分号</strong>，例如 &quot;<code>ltcc;</code>&quot;。</p></blockquote> <p>​	我们可以根据这张表来实现实体的解码逻辑。假设我们有如下文本内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>a<span class="token operator">&amp;</span>ltccbbb
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	在解码这段文本时，我们首先根据字符 <code>&amp;</code> 将文本分为两部分：</p> <ul><li>一部分是普通文本：<code>a</code>。</li> <li>另一部分则是：<code>&amp;ltccbbb</code>。</li></ul> <p>​	对于普通文本部分，由于它不需要被解码，因此索引原封不动地保留。而对于可能是字符引用的部分，执行解码工作：</p> <p>1、计算出命名字符引用表中实体名称的最大长度。由于在 namedCharacterReferences 对象中，名称最长的实体是 <code>ltcc;</code>，它具有 5 个字符，因此最大长度是 5。</p> <p>2、根据最大长度截取字符串 <code>ltccbbb</code>，即 <code>'ltccbbb'.slice(0, 5)</code>，最终结果是：'<code>ltccb</code>'</p> <p>3、用截取后的字符串 '<code>ltccb</code>' 作为键去命名字符引用表中查询对应的值，即解码。由于引用表 namedCharacterReferences 中不存在键值为 '<code>ltccb</code>' 的项，因此不匹配。</p> <p>4、当发现不匹配时，我们将最大长度减 1，并重新执行第二步，直到找到匹配项为止。在上面这个例子中，最终的匹配项将会是 '<code>lt</code>'。因此，上述文本最终会被解码为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>a<span class="token operator">&lt;</span>ccbbb
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这样，我们就实现了当字符引用省略分号时按照“最短原则”进行解码。</p> <p>​	下面的 decodeHtml 函数给出了具体实现：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 第一个参数为要被解码的文本内容</span>
 <span class="token comment">// 第二个参数是一个布尔值，代表文本内容是否作为属性值</span>
 <span class="token keyword">function</span> <span class="token function">decodeHtml</span><span class="token punctuation">(</span>rawText<span class="token punctuation">,</span> asAttr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> offset <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">const</span> end <span class="token operator">=</span> rawText<span class="token punctuation">.</span>length
   <span class="token comment">// 经过解码后的文本将作为返回值被返回</span>
   <span class="token keyword">let</span> decodedText <span class="token operator">=</span> <span class="token string">''</span>
   <span class="token comment">// 引用表中实体名称的最大长度</span>
   <span class="token keyword">let</span> maxCRNameLength <span class="token operator">=</span> <span class="token number">0</span>

   <span class="token comment">// advance 函数用于消费指定长度的文本</span>
   <span class="token keyword">function</span> <span class="token function">advance</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     offset <span class="token operator">+=</span> length
     rawText <span class="token operator">=</span> rawText<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 消费字符串，直到处理完毕为止</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 用于匹配字符引用的开始部分，如果匹配成功，那么 head[0] 的值将有三种可能：</span>
     <span class="token comment">// 1. head[0] === '&amp;'，这说明该字符引用是命名字符引用</span>
     <span class="token comment">// 2. head[0] === '&amp;#'，这说明该字符引用是用十进制表示的数字字符引用</span>
     <span class="token comment">// 3. head[0] === '&amp;#x'，这说明该字符引用是用十六进制表示的数字字符引用</span>
     <span class="token keyword">const</span> head <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&amp;(?:#x?)?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>rawText<span class="token punctuation">)</span>
     <span class="token comment">// 如果没有匹配，说明已经没有需要解码的内容了</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 计算剩余内容的长度</span>
       <span class="token keyword">const</span> remaining <span class="token operator">=</span> end <span class="token operator">-</span> offset
       <span class="token comment">// 将剩余内容加到 decodedText 上</span>
       decodedText <span class="token operator">+=</span> rawText<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> remaining<span class="token punctuation">)</span>
       <span class="token comment">// 消费剩余内容</span>
       <span class="token function">advance</span><span class="token punctuation">(</span>remaining<span class="token punctuation">)</span>
       <span class="token keyword">break</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// head.index 为匹配的字符 &amp; 在 rawText 中的位置索引</span>
     <span class="token comment">// 截取字符 &amp; 之前的内容加到 decodedText 上</span>
     decodedText <span class="token operator">+=</span> rawText<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">.</span>index<span class="token punctuation">)</span>
     <span class="token comment">// 消费字符 &amp; 之前的内容</span>
     <span class="token function">advance</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>index<span class="token punctuation">)</span>

     <span class="token comment">// 如果满足条件，则说明是命名字符引用，否则为数字字符引用</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&amp;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">''</span>
       <span class="token keyword">let</span> value
       <span class="token comment">// 字符 &amp; 的下一个字符必须是 ASCII 字母或数字，这样才是合法的命名字符引用</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[0-9a-z]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>rawText<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 根据引用表计算实体名称的最大长度，</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>maxCRNameLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           maxCRNameLength <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>namedCharacterReferences<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
             <span class="token punctuation">(</span>max<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> name<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token number">0</span>
           <span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 从最大长度开始对文本进行截取，并试图去引用表中找到对应的项</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> length <span class="token operator">=</span> maxCRNameLength<span class="token punctuation">;</span> <span class="token operator">!</span>value <span class="token operator">&amp;&amp;</span> length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 截取字符 &amp; 到最大长度之间的字符作为实体名称</span>
           name <span class="token operator">=</span> rawText<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span>
           <span class="token comment">// 使用实体名称去索引表中查找对应项的值</span>
           value <span class="token operator">=</span> <span class="token punctuation">(</span>namedCharacterReferences<span class="token punctuation">)</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// 如果找到了对应项的值，说明解码成功</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 检查实体名称的最后一个匹配字符是否是分号</span>
           <span class="token keyword">const</span> semi <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">';'</span><span class="token punctuation">)</span>
           <span class="token comment">// 如果解码的文本作为属性值，最后一个匹配的字符不是分号，</span>
           <span class="token comment">// 并且最后一个匹配字符的下一个字符是等于号（=）、ASCII 字母或数字，</span>
           <span class="token comment">// 由于历史原因，将字符 &amp; 和实体名称 name 作为普通文本</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>
             asAttr <span class="token operator">&amp;&amp;</span>
             <span class="token operator">!</span>semi <span class="token operator">&amp;&amp;</span>
             <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[=a-z0-9]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>rawText<span class="token punctuation">[</span>name<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">)</span>
           <span class="token punctuation">)</span> <span class="token punctuation">{</span>
             decodedText <span class="token operator">+=</span> <span class="token string">'&amp;'</span> <span class="token operator">+</span> name
             <span class="token function">advance</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> name<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
             <span class="token comment">// 其他情况下，正常使用解码后的内容拼接到 decodedText 上</span>
             decodedText <span class="token operator">+=</span> value
             <span class="token function">advance</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> name<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
           <span class="token punctuation">}</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果没有找到对应的值，说明解码失败</span>
           decodedText <span class="token operator">+=</span> <span class="token string">'&amp;'</span> <span class="token operator">+</span> name
           <span class="token function">advance</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> name<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 如果字符 &amp; 的下一个字符不是 ASCII 字母或数字，则将字符 &amp; 作为普通文本</span>
         decodedText <span class="token operator">+=</span> <span class="token string">'&amp;'</span>
         <span class="token function">advance</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> decodedText
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br></div></div><p>​	有了 decodeHtml 函数之后，我们就可以在解析文本节点时通过它对文本内容进行解码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseText</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span>
     content<span class="token operator">:</span> <span class="token function">decodeHtml</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token comment">// 调用 decodeHtml 函数解码内容</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="解码数字字符引用"><a href="#解码数字字符引用" class="header-anchor">#</a> 解码数字字符引用</h3> <p>​	在前面，我们使用下面的正则表达式来匹配一个文本中字符引用的开始部分：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> head <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&amp;(?:#x?)?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>rawText<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>我们可以根据该正则的匹配结果，来判断字符引用的类型：</p> <ul><li>如果 head[0] === <code>'&amp;'</code>，则说明匹配的是命名字符引用。</li> <li>如果 head[0] === <code>'&amp;#'</code>，则说明匹配的是以十进制表示的数字字符引用。</li> <li>如果 head[0] === <code>'&amp;#x'</code>，则说明匹配的是以十六进制表示的数字字符引用。</li></ul></blockquote> <p>​	数字字符引用的格式是：前缀 + Unicode 码点。解码数字字符引用的关键在于，如何提取字符引用中的 Unicode 码点。考虑到数字字符引用的前缀可以是以十进制表示（<code>&amp;#</code>），也可以是以十六进制表示（<code>&amp;#x</code>），所以我们使用下面的代码来完成码点的提取：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 判断是以十进制表示还是以十六进制表示</span>
 <span class="token keyword">const</span> hex <span class="token operator">=</span> head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&amp;#x'</span>
 <span class="token comment">// 根据不同进制表示法，选用不同的正则</span>
 <span class="token keyword">const</span> pattern <span class="token operator">=</span> hex <span class="token operator">?</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&amp;#x([0-9a-f]+);?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span> <span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&amp;#([0-9]+);?</span><span class="token regex-delimiter">/</span></span>
 <span class="token comment">// 最终，body[1] 的值就是 Unicode 码点</span>
 <span class="token keyword">const</span> body <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>rawText<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	有了 Unicode 码点之后，只需要调用 <code>String.fromCodePoint</code> 函数即可将其解码为对应的字符：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 根据对应的进制，将码点字符串转换为数字</span>
   <span class="token keyword">const</span> cp <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>body<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hex <span class="token operator">?</span> <span class="token number">16</span> <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">)</span>
   <span class="token comment">// 解码</span>
   <span class="token keyword">const</span> char <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCodePoint</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	不过，在真正进行解码前，需要对码点的值进行合法性检查。WHATWG 规范中对此也有明确的定义：</p> <ul><li><code>如果码点值为 0x00，即十进制的数字 0，它在 Unicode 中代表空字符（NULL），这将是一个解析错误，解析器会将码点值替换为 0xFFFD。</code></li> <li><code>如果码点值大于 0x10FFFF（0x10FFFF 为 Unicode 的最大值），这也是一个解析错误，解析器会将码点值替换为 0xFFFD。</code></li> <li><code>如果码点值处于**代理对**（surrogate pair）范围内，这也是一个解析错误，解析器会将码点值替换为 0xFFFD，其中 surrogate pair 是预留给 UTF-16 的码位，其范围是：[0xD800, 0xDFFF]。</code></li> <li><code>如果码点值是 noncharacter，这也是一个解析错误，但什么都不需要做。这里的 noncharacter 代表 Unicode 永久保留的码点，用于 Unicode 内部，它的取值范围是：[0xFDD0, 0xFDEF]，还包括：0xFFFE、0xFFFF、0x1FFFE、0x1FFFF、0x2FFFE、0x2FFFF、0x3FFFE、0x3FFFF、0x4FFFE、0x4FFFF、0x5FFFE、0x5FFFF、0x6FFFE、0x6FFFF、0x7FFFE、0x7FFFF、0x8FFFE、0x8FFFF、0x9FFFE、0x9FFFF、0xAFFFE、0xAFFFF、0xBFFFE、0xBFFFF、0xCFFFE、0xCFFFF、0xDFFFE、0xDFFFF、0xEFFFE、0xEFFFF、0xFFFFE、0xFFFFF、0x10FFFE、0x10FFFF。</code></li></ul> <p>​	如果码点值对应的字符是回车符（<code>0x0D</code>），或者码点值为<strong>控制字符集</strong>（controlcharacter）中的非 ASCII 空白符（ASCII whitespace），则是一个解析错误。这时需要将码点作为索引，在下表中查找对应的替换码点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> <span class="token constant">CCR_REPLACEMENTS</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token number">0x80</span><span class="token operator">:</span> <span class="token number">0x20ac</span><span class="token punctuation">,</span>
   <span class="token number">0x82</span><span class="token operator">:</span> <span class="token number">0x201a</span><span class="token punctuation">,</span>
   <span class="token number">0x83</span><span class="token operator">:</span> <span class="token number">0x0192</span><span class="token punctuation">,</span>
   <span class="token number">0x84</span><span class="token operator">:</span> <span class="token number">0x201e</span><span class="token punctuation">,</span>
   <span class="token number">0x85</span><span class="token operator">:</span> <span class="token number">0x2026</span><span class="token punctuation">,</span>
   <span class="token number">0x86</span><span class="token operator">:</span> <span class="token number">0x2020</span><span class="token punctuation">,</span>
   <span class="token number">0x87</span><span class="token operator">:</span> <span class="token number">0x2021</span><span class="token punctuation">,</span>
   <span class="token number">0x88</span><span class="token operator">:</span> <span class="token number">0x02c6</span><span class="token punctuation">,</span>
   <span class="token number">0x89</span><span class="token operator">:</span> <span class="token number">0x2030</span><span class="token punctuation">,</span>
   <span class="token number">0x8a</span><span class="token operator">:</span> <span class="token number">0x0160</span><span class="token punctuation">,</span>
   <span class="token number">0x8b</span><span class="token operator">:</span> <span class="token number">0x2039</span><span class="token punctuation">,</span>
   <span class="token number">0x8c</span><span class="token operator">:</span> <span class="token number">0x0152</span><span class="token punctuation">,</span>
   <span class="token number">0x8e</span><span class="token operator">:</span> <span class="token number">0x017d</span><span class="token punctuation">,</span>
   <span class="token number">0x91</span><span class="token operator">:</span> <span class="token number">0x2018</span><span class="token punctuation">,</span>
   <span class="token number">0x92</span><span class="token operator">:</span> <span class="token number">0x2019</span><span class="token punctuation">,</span>
   <span class="token number">0x93</span><span class="token operator">:</span> <span class="token number">0x201c</span><span class="token punctuation">,</span>
   <span class="token number">0x94</span><span class="token operator">:</span> <span class="token number">0x201d</span><span class="token punctuation">,</span>
   <span class="token number">0x95</span><span class="token operator">:</span> <span class="token number">0x2022</span><span class="token punctuation">,</span>
   <span class="token number">0x96</span><span class="token operator">:</span> <span class="token number">0x2013</span><span class="token punctuation">,</span>
   <span class="token number">0x97</span><span class="token operator">:</span> <span class="token number">0x2014</span><span class="token punctuation">,</span>
   <span class="token number">0x98</span><span class="token operator">:</span> <span class="token number">0x02dc</span><span class="token punctuation">,</span>
   <span class="token number">0x99</span><span class="token operator">:</span> <span class="token number">0x2122</span><span class="token punctuation">,</span>
   <span class="token number">0x9a</span><span class="token operator">:</span> <span class="token number">0x0161</span><span class="token punctuation">,</span>
   <span class="token number">0x9b</span><span class="token operator">:</span> <span class="token number">0x203a</span><span class="token punctuation">,</span>
   <span class="token number">0x9c</span><span class="token operator">:</span> <span class="token number">0x0153</span><span class="token punctuation">,</span>
   <span class="token number">0x9e</span><span class="token operator">:</span> <span class="token number">0x017e</span><span class="token punctuation">,</span>
   <span class="token number">0x9f</span><span class="token operator">:</span> <span class="token number">0x0178</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><blockquote><p><strong>如果存在对应的替换码点，则渲染该替换码点对应的字符，否则直接渲染原码点对应的字符。</strong></p></blockquote> <p>​	上述关于码点合法性检查的具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 根据对应的进制，将码点字符串转换为数字</span>
   <span class="token keyword">const</span> cp <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>body<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hex <span class="token operator">?</span> <span class="token number">16</span> <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">)</span>
   <span class="token comment">// 检查码点的合法性</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果码点值为 0x00，替换为 0xfffd</span>
     cp <span class="token operator">=</span> <span class="token number">0xfffd</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">&gt;</span> <span class="token number">0x10ffff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果码点值超过 Unicode 的最大值，替换为 0xfffd</span>
     cp <span class="token operator">=</span> <span class="token number">0xfffd</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0xd800</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0xdfff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果码点值处于 surrogate pair 范围内，替换为 0xfffd</span>
     cp <span class="token operator">=</span> <span class="token number">0xfffd</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0xfdd0</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0xfdef</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cp <span class="token operator">&amp;</span> <span class="token number">0xfffe</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xfffe</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果码点值处于 noncharacter 范围内，则什么都不做，交给平台处理</span>
     <span class="token comment">// noop</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
     <span class="token comment">// 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]</span>
     <span class="token comment">// 去掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)</span>
     <span class="token comment">// 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含</span>
     <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0x01</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">||</span>
     cp <span class="token operator">===</span> <span class="token number">0x0b</span> <span class="token operator">||</span>
     <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0x0d</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0x1f</span><span class="token punctuation">)</span> <span class="token operator">||</span>
     <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0x7f</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0x9f</span><span class="token punctuation">)</span>
   <span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到，则使用原码点</span>
     cp <span class="token operator">=</span> <span class="token constant">CCR_REPLACEMENTS</span><span class="token punctuation">[</span>cp<span class="token punctuation">]</span> <span class="token operator">||</span> cp
   <span class="token punctuation">}</span>
   <span class="token comment">// 最后进行解码</span>
   <span class="token keyword">const</span> char <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCodePoint</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>在上面这段代码中，我们完整地还原了码点合法性检查的逻辑，它有如下几个关键点：</p> <ul><li>其中<strong>控制字符集</strong>（control character）的码点范围是：[0x01, 0x1f] 和 [0x7f,0x9f]。这个码点范围包含了 ASCII 空白符：<code>0x09(TAB)</code>、<code>0x0A(LF)</code>、<code>0x0C(FF)</code> 和<code>0x0D(CR)</code>，但 WHATWG 规范中要求包含 <code>0x0D(CR)</code>。</li> <li>码点 <code>0xfffd</code> 对应的符号是 <code>�</code>。你一定在出现“乱码”的情况下见过这个字符，它是 Unicode 中的替换字符，通常表示在解码过程中出现“错误”，例如使用了错误的解码方式等。</li></ul></blockquote> <p>​	最后，我们将上述代码整合到 <code>decodeHtml</code> 函数中，这样就实现一个完善的 HTML 文本解码函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">decodeHtml</span><span class="token punctuation">(</span>rawText<span class="token punctuation">,</span> asAttr <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token comment">// 消费字符串，直到处理完毕为止</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>offset <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>

     <span class="token comment">// 如果满足条件，则说明是命名字符引用，否则为数字字符引用</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&amp;'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 省略部分代码</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 判断是十进制表示还是十六进制表示</span>
       <span class="token keyword">const</span> hex <span class="token operator">=</span> head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'&amp;#x'</span>
       <span class="token comment">// 根据不同进制表示法，选用不同的正则</span>
       <span class="token keyword">const</span> pattern <span class="token operator">=</span> hex <span class="token operator">?</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&amp;#x([0-9a-f]+);?</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span> <span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^&amp;#([0-9]+);?</span><span class="token regex-delimiter">/</span></span>
       <span class="token comment">// 最终，body[1] 的值就是 Unicode 码点</span>
       <span class="token keyword">const</span> body <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>rawText<span class="token punctuation">)</span>

       <span class="token comment">// 如果匹配成功，则调用 String.fromCodePoint 函数进行解码</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 根据对应的进制，将码点字符串转换为数字</span>
         <span class="token keyword">const</span> cp <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>body<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hex <span class="token operator">?</span> <span class="token number">16</span> <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">)</span>
         <span class="token comment">// 码点的合法性检查</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果码点值为 0x00，替换为 0xfffd</span>
           cp <span class="token operator">=</span> <span class="token number">0xfffd</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">&gt;</span> <span class="token number">0x10ffff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果码点值超过 Unicode 的最大值，替换为 0xfffd</span>
           cp <span class="token operator">=</span> <span class="token number">0xfffd</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0xd800</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0xdfff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果码点值处于 surrogate pair 范围内，替换为 0xfffd</span>
           cp <span class="token operator">=</span> <span class="token number">0xfffd</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0xfdd0</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0xfdef</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cp <span class="token operator">&amp;</span> <span class="token number">0xfffe</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0xfffe</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果码点值处于 noncharacter 范围内，则什么都不做，交给平台处理</span>
           <span class="token comment">// noop</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
           <span class="token comment">// 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]</span>
           <span class="token comment">// 去掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)</span>
           <span class="token comment">// 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含</span>
           <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0x01</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">||</span>
           cp <span class="token operator">===</span> <span class="token number">0x0b</span> <span class="token operator">||</span>
           <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0x0d</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0x1f</span><span class="token punctuation">)</span> <span class="token operator">||</span>
           <span class="token punctuation">(</span>cp <span class="token operator">&gt;=</span> <span class="token number">0x7f</span> <span class="token operator">&amp;&amp;</span> cp <span class="token operator">&lt;=</span> <span class="token number">0x9f</span><span class="token punctuation">)</span>
         <span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到，则使用原码点</span>
           cp <span class="token operator">=</span> <span class="token constant">CCR_REPLACEMENTS</span><span class="token punctuation">[</span>cp<span class="token punctuation">]</span> <span class="token operator">||</span> cp
         <span class="token punctuation">}</span>
         <span class="token comment">// 解码后追加到 decodedText 上</span>
         decodedText <span class="token operator">+=</span> String<span class="token punctuation">.</span><span class="token function">fromCodePoint</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span>
         <span class="token comment">// 消费整个数字字符引用的内容</span>
         <span class="token function">advance</span><span class="token punctuation">(</span>body<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 如果没有匹配，则不进行解码操作，只是把 head[0] 追加到 decodedText 上并消费</span>
         decodedText <span class="token operator">+=</span> head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
         <span class="token function">advance</span><span class="token punctuation">(</span>head<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> decodedText
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br></div></div><h2 id="解析插值与注释"><a href="#解析插值与注释" class="header-anchor">#</a> 解析插值与注释</h2> <p>​	文本插值是 <code>Vue.js</code> 模板中用来渲染动态数据的常用方法：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token punctuation">{</span><span class="token punctuation">{</span> count <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	默认情况下，插值以字符串 <code>{{</code> 开头，并以字符串 <code>}}</code> 结尾。我们通常将这两个特殊的字符串称为定界符。<strong>定界符中间的内容可以是任意合法的 <code>JavaScript</code> 表达式</strong>，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>foo <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token comment">// 或者</span>
<span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	解析器在遇到文本插值的起始定界符(<code>{{</code>)时，会进入文本“插值状态 6”，并调用 <code>parseInterpolation</code> 函数来解析插值内容：</p> <p><img src="/vivien-blog/assets/img/16-22.727e5cd1.png" alt="parseChildren函数在解析模板过程中的状态迁移过程"></p> <p>​	解析器在解析插值时，只需要将文本插值的开始定界符与结束定界符<strong>之间的内容</strong>提取出来，作为  <code>JavaScript</code> 表达式即可，具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseInterpolation</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 消费开始定界符</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token string">'{{'</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token comment">// 找到结束定界符的位置索引</span>
   closeIndex <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'}}'</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>closeIndex <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'插值缺少结束定界符'</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 截取开始定界符与结束定界符之间的内容作为插值表达式</span>
   <span class="token keyword">const</span> content <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> closeIndex<span class="token punctuation">)</span>
   <span class="token comment">// 消费表达式的内容</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token comment">// 消费结束定界符</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token string">'}}'</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>

   <span class="token comment">// 返回类型为 Interpolation 的节点，代表插值节点</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Interpolation'</span><span class="token punctuation">,</span>
     <span class="token comment">// 插值节点的 content 是一个类型为 Expression 的表达式节点</span>
     content<span class="token operator">:</span> <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Expression'</span><span class="token punctuation">,</span>
       <span class="token comment">// 表达式节点的内容则是经过 HTML 解码后的插值表达式</span>
       content<span class="token operator">:</span> <span class="token function">decodeHtml</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>​	配合上面的 <code>parseInterpolation</code> 函数，解析如下模板内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;foo {{ bar }} baz&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	最终将得到如下 <code>AST</code>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       isSelfClosing<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
       props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span> content<span class="token operator">:</span> <span class="token string">'foo '</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token comment">// 插值节点</span>
         <span class="token punctuation">{</span>
           type<span class="token operator">:</span> <span class="token string">'Interpolation'</span><span class="token punctuation">,</span>
           content<span class="token operator">:</span> <span class="token punctuation">[</span>
             type<span class="token operator">:</span> <span class="token string">'Expression'</span><span class="token punctuation">,</span>
             content<span class="token operator">:</span> <span class="token string">' bar '</span>
           <span class="token punctuation">]</span>
         <span class="token punctuation">}</span><span class="token punctuation">,</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Text'</span><span class="token punctuation">,</span> content<span class="token operator">:</span> <span class="token string">' baz'</span> <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>​	解析注释的思路与解析插值非常相似，如下面的 <code>parseComment</code> 函数所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">parseComment</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 消费注释的开始部分</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token string">'&lt;!--'</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token comment">// 找到注释结束部分的位置索引</span>
   closeIndex <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'--&gt;'</span><span class="token punctuation">)</span>
   <span class="token comment">// 截取注释节点的内容</span>
   <span class="token keyword">const</span> content <span class="token operator">=</span> context<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> closeIndex<span class="token punctuation">)</span>
   <span class="token comment">// 消费内容</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token comment">// 消费注释的结束部分</span>
   context<span class="token punctuation">.</span><span class="token function">advanceBy</span><span class="token punctuation">(</span><span class="token string">'--&gt;'</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
   <span class="token comment">// 返回类型为 Comment 的节点</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     type<span class="token operator">:</span> <span class="token string">'Comment'</span><span class="token punctuation">,</span>
     content
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>​	配合 <code>parseComment</code> 函数，解析如下模板内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;!-- comments --&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	最终得到如下 <code>AST</code>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'Root'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       type<span class="token operator">:</span> <span class="token string">'Element'</span><span class="token punctuation">,</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       isSelfClosing<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
       props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'Comment'</span><span class="token punctuation">,</span> content<span class="token operator">:</span> <span class="token string">' comments '</span> <span class="token punctuation">}</span>
       <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>文本模式指的是解析器在工作时所进入的一些特殊状态，如 RCDATA 模式、CDATA 模式、RAWTEXT 模式，以及初始的 DATA 模式等。在不同模式下，解析器对文本的解析行为会有所不同。</li> <li>在 parseChildren 函数运行的过程中，为了处理标签节点，会调用 parseElement 解析函数，这会间接地调用 parseChildren 函数，并产生一个新的状态机。随着标签嵌套层次的增加，新的状态机也会随着 parseChildren 函数被递归地调用而不断创建，这就是“递归下降”中“递归”二字的含义。而上级 parseChildren 函数的调用用于构造上级模板 AST 节点，被递归调用的下级 parseChildren 函数则用于构造下级模板 AST 节点。最终会构造出一棵树型结构的模板 AST，这就是“递归下降”中“下降”二字的含义。</li> <li>在解析模板构建 AST 的过程中，parseChildren 函数是核心。每次调用parseChildren 函数，就意味着新状态机的开启。状态机的结束时机有两个。第一个停止时机是当模板内容被解析完毕时。第二个停止时机则是遇到结束标签时，这时解析器会取得父级节点栈栈顶的节点作为父节点，检查该结束标签是否与父节点的标签同名，如果相同，则状态机停止运行。</li> <li>解析文本节点本身并不复杂，它的复杂点在于，我们需要对解析后的文本内容进行 HTML 实体的解码工作。WHATWG 规范中也定义了解码 HTML 实体过程中的状态迁移流程。HTML 实体类型有两种，分别是命名字符引用和数字字符引用。命名字符引用的解码方案可以总结为两种。当存在分号时：执行完整匹配。当省略分号时：执行最短匹配。</li> <li>对于数字字符引用，则需要按照 WHATWG 规范中定义的规则逐步实现。</li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2025/2/18 02:43:40</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="prev">
          15.编译器核心技术概览
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html">
          17.编译优化
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#文本模式及其对解析器的影响" class="sidebar-link reco-side-文本模式及其对解析器的影响" data-v-9f22dc18>文本模式及其对解析器的影响</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#data" class="sidebar-link reco-side-data" data-v-9f22dc18>DATA</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#rcdata" class="sidebar-link reco-side-rcdata" data-v-9f22dc18>RCDATA</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#rawtext" class="sidebar-link reco-side-rawtext" data-v-9f22dc18>RAWTEXT</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#cdata" class="sidebar-link reco-side-cdata" data-v-9f22dc18>CDATA</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#递归下降算法构造模板-ast" class="sidebar-link reco-side-递归下降算法构造模板-ast" data-v-9f22dc18>递归下降算法构造模板 AST</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#parsechildren-函数" class="sidebar-link reco-side-parsechildren-函数" data-v-9f22dc18>parseChildren 函数</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#状态机的开启与停止" class="sidebar-link reco-side-状态机的开启与停止" data-v-9f22dc18>状态机的开启与停止</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#开启" class="sidebar-link reco-side-开启" data-v-9f22dc18>开启</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#停止" class="sidebar-link reco-side-停止" data-v-9f22dc18>停止</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解析标签节点" class="sidebar-link reco-side-解析标签节点" data-v-9f22dc18>解析标签节点</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解析属性" class="sidebar-link reco-side-解析属性" data-v-9f22dc18>解析属性</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#parseattributes-函数" class="sidebar-link reco-side-parseattributes-函数" data-v-9f22dc18>parseAttributes 函数</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#匹配原理" class="sidebar-link reco-side-匹配原理" data-v-9f22dc18>匹配原理</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解析文本与解码-html-实体" class="sidebar-link reco-side-解析文本与解码-html-实体" data-v-9f22dc18>解析文本与解码 HTML 实体</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解析文本" class="sidebar-link reco-side-解析文本" data-v-9f22dc18>解析文本</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解码命名字符引用" class="sidebar-link reco-side-解码命名字符引用" data-v-9f22dc18>解码命名字符引用</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解码数字字符引用" class="sidebar-link reco-side-解码数字字符引用" data-v-9f22dc18>解码数字字符引用</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#解析插值与注释" class="sidebar-link reco-side-解析插值与注释" data-v-9f22dc18>解析插值与注释</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/16.%E8%A7%A3%E6%9E%90%E5%99%A8.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.1b7b4fd5.js" defer></script><script src="/vivien-blog/assets/js/7.210383a7.js" defer></script><script src="/vivien-blog/assets/js/2.00d63d32.js" defer></script><script src="/vivien-blog/assets/js/1.96251043.js" defer></script><script src="/vivien-blog/assets/js/20.c523984f.js" defer></script>
  </body>
</html>
