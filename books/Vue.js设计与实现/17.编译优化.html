<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>17.编译优化 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.7738f530.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.464cc3ea.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.db1c35d8.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.88465532.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/76.43f489ac.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.b772a431.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.62f13f40.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.262eebca.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.d15aec8d.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.3a4e8685.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.d8ef8d42.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.9c62ca3a.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.79799973.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3d688fa2.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.189a67fe.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.815085b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.d29dfabd.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.2ea8565d.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.3253031a.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.5feade57.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.819e6082.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.55297748.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.44b80f99.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.36461d4e.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.99af4d82.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.153f661c.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.df0b310d.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.4edb84f7.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.fa7bfc4d.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.f1a5a11a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.1580535f.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.d2a29b85.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.b5be33e2.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.52480968.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.94af5ec3.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.8dca7f6c.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.c753d508.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.bf5216d1.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.9bb718ff.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.dd72318d.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.025cbb0a.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.7cbb5ff9.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.099aee64.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.c1d6e501.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.2b108764.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.e9bcad68.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.4582846d.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.169fb77c.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.aea2c93b.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.1866cbba.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.9ab9834f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.d71bb6eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.383ae212.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.f47e5265.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.d6652043.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.542b86e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.d25326b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e55f1610.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.2fd2d217.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.0d01bb51.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.18330ce2.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.f63999dd.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.9c63570f.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.7e649a94.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.5cd0ff12.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.1380315b.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.9a8bc83a.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.dfc3dc84.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.9f0491a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.56c7442b.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.572118ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.a2889e9a.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.94b92181.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.546a376b.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.6e1296f2.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.294c2556.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.5c64fcbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.f38ecb23.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.a7eaecbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.566ea0ad.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.03726d99.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.44e0a209.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.196020b0.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.cb2a2b01.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.018c7e56.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.0b005dfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.7a746c54.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.9e0d4857.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.16f48649.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.54c9caee.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.932acfca.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.a26eda75.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.d6106a7d.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.0e84a519.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.04cd2610.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f99c6d3c.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.72422da4.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.31dada36.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.d8b153a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.ddda63c0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.6966e143.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.a2fbe5d8.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.48bb5c9c.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.debb65a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.0066da58.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.95333a2b.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.51dafac2.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6fe5ff10.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.03ddba74.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.1baba6a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.2f8bb846.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.b5976902.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.f64041b6.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.64d19acb.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.f89c690f.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.192fa399.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.ddf16957.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.25fbc2b8.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.4fea84f6.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.e5c8d0d5.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.201c7a26.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.4accbe01.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.a921fb5d.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.c4b024d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.872418d3.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.ae5ba79d.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.043c5690.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.fd1da6ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.a0dec3a9.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.15551b0c.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="active sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>17.编译优化</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">17.编译优化</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/20</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><p>​	编译优化指的是编译器将模板编译为渲染函数的过程中，<strong>尽可能多地提取关键信息，并以此指导生成最优代码</strong>的过程。编译优化的策略与具体实现是由框架的设计思路所决定的，不同的框架具有不同的设计思路，因此编译优化的策略也不尽相同。但优化的方向基本一致，即<strong>尽可能地区分动态内容和静态内容</strong>，并针对不同的内容采用不同的优化策略。</p> <h2 id="动态节点收集与补丁标志"><a href="#动态节点收集与补丁标志" class="header-anchor">#</a> 动态节点收集与补丁标志</h2> <h3 id="传统-diff-算法的问题"><a href="#传统-diff-算法的问题" class="header-anchor">#</a> 传统 Diff 算法的问题</h3> <p>​	前面学习了三种关于传统虚拟 DOM 的 Diff 算法，但无论哪一种 Diff 算法，当它在比对新旧两棵虚拟 DOM 树的时候，总是要按照虚拟 DOM 的层级结构“一层一层”地遍历。举个例子，假设我们有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	这段模板中，唯一可能变化的就是 p 标签的文本子节点的内容。也就是说，当响应式数据 text 的值发生变化时，最高效的更新方式就是直接设置 p 标签的文本内容。但传统 Diff 算法显然做不到如此高效，当响应式数据 text 发生变化时，会产生一棵新的虚拟 DOM 树，传统 Diff 算法对比新旧两棵虚拟 DOM 树的过程如下：</p> <ul><li>对比 div 节点，以及该节点的属性和子节点。</li> <li>对比 p 节点，以及该节点的属性和子节点。</li> <li>对比 p 节点的文本子节点，如果文本子节点的内容变了，则更新之，否则什么都不做。</li></ul> <p>​	可以看到，与直接更新 p 标签的文本内容相比，传统 Diff 算法存在很多无意义的比对操作。如果能够<strong>跳过这些无意义的操作</strong>，性能将会大幅提升。而这就是Vue.js 3 编译优化的思路来源。</p> <p>​	实际上，模板的结构非常稳定。通过编译手段，我们可以分析出很多关键信息，例如哪些节点是静态的，哪些节点是动态的。结合这些关键信息，编译器可以直接生成原生 DOM 操作的代码，这样甚至能够抛掉虚拟 DOM，从而避免虚拟 DOM 带来的性能开销。但是，<strong>考虑到渲染函数的灵活性，以及 Vue.js 2 的兼容问题</strong>，Vue.js 3 最终还是选择了保留虚拟 DOM。这样一来，就必然要面临它所带来的额外性能开销。</p> <p>​	为什么虚拟 DOM 会产生额外的性能开销呢？根本原因在于，**渲染器在运行时得不到足够的信息。**传统 Diff 算法无法利用编译时提取到的任何关键信息， 这导致渲染器在运行时不可能去做相关的优化。而 Vue.js 3 的编译器会将编译时得到的关键信息“附着”在它生成的虚拟 DOM 上，这些信息会通过虚拟 DOM传递给渲染器。最终，渲染器会根据这些关键信息执行“快捷路径”，从而提升运行时的性能。</p> <blockquote><p>生成 render 函数的时候我们已经知道哪些内容可以优化，但却没有做任何的标记，导致 render 函数需要一个个执行，就导致了浪费。</p></blockquote> <h3 id="block-与-patchflags"><a href="#block-与-patchflags" class="header-anchor">#</a> Block 与 PatchFlags</h3> <p>​	之所以说传统 Diff 算法无法避免新旧虚拟 DOM 树间无用的比较操作，是因为它在运行时得不到足够的关键信息，从而无法区分动态内容和静态内容。换句话说，只要运行时能够<strong>区分动态内容和静态内容</strong>，即可实现极致的优化策略。</p> <h4 id="patchflags"><a href="#patchflags" class="header-anchor">#</a> PatchFlags</h4> <p>​	假设我们有如下模板，</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ bar }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>这段模板中，只有  是动态的内容。因此，在理想情况下，当响应式数据 bar 的值变化时，只需要更新 p 标签的文本节点即可。</p></blockquote> <p>​	为了实现这个目标，我们需要提供更多信息给运行时，这需要我们从虚拟 DOM 的结构入手。来看一下传统的虚拟 DOM 是如何描述上面那段模板的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	传统的虚拟 DOM 中没有任何标志能够<strong>体现出节点的动态性</strong>。但经过编译优化之后，编译器会将它提取到的关键信息“附着”到虚拟 DOM 节点上：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> patchFlag<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 这是动态节点</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>可以看到，用来描述 p 标签的虚拟节点拥有一个额外的属性，即 patchFlag，它的值是一个数字。<strong>只要虚拟节点存在该属性，我们就认为它是一个动态节点。这里的 patchFlag 属性就是所谓的补丁标志。</strong></p></blockquote> <p>​	我们可以把补丁标志理解为一系列数字标记，并根据数字值的不同赋予它不同的含义，示例如下：</p> <ul><li>数字 1：代表节点有动态的 textContent（例如上面模板中的 p 标签）。</li> <li>数字 2：代表元素有动态的 class 绑定。</li> <li>数字 3：代表元素有动态的 style 绑定。</li> <li>数字 4：其他……。</li></ul> <p>​	通常，我们会在运行时的代码中定义补丁标志的映射，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> PatchFlags <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token constant">TEXT</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 代表节点有动态的 textContent</span>
   <span class="token constant">CLASS</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// 代表元素有动态的 class 绑定</span>
   <span class="token constant">STYLE</span><span class="token operator">:</span> <span class="token number">3</span>
   <span class="token comment">// 其他……</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	有了这项信息，我们就可以在虚拟节点的创建阶段，把它的动态子节点提取出来，并将其存储到该虚拟节点的 dynamicChildren 数组内：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> patchFlag<span class="token operator">:</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span> <span class="token punctuation">}</span>  <span class="token comment">// 这是动态节点</span>
   <span class="token punctuation">]</span><span class="token punctuation">,</span>
   <span class="token comment">// 将 children 中的动态节点提取到 dynamicChildren 数组中</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token comment">// p 标签具有 patchFlag 属性，因此它是动态节点</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> patchFlag<span class="token operator">:</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="block"><a href="#block" class="header-anchor">#</a> Block</h4> <p>​	观察上面的 vnode 对象可以发现，与普通虚拟节点相比，它多出了一个额外的 dynamicChildren 属性。我们**把带有该属性的虚拟节点称为“块”，即 Block。**所以，<strong>一个 Block 本质上也是一个虚拟 DOM 节点，只不过它比普通的虚拟节点多出来一个用来存储动态子节点的 dynamicChildren 属性</strong>。这里需要注意的是，**一个 Block 不仅能够收集它的直接动态子节点，还能够收集所有动态子代节点。**举个例子，假设我们有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ bar }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>在这段模板中，p 标签并不是最外层 div 标签的直接子节点，而是它的子代节点。</p></blockquote> <p>​	因此，最外层的 div 标签对应的 Block 能够将 p 标签收集到其 dynamicChildren 数组中：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span>
       tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
       children<span class="token operator">:</span> <span class="token punctuation">[</span>
         <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> patchFlag<span class="token operator">:</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span> <span class="token punctuation">}</span>  <span class="token comment">// 这是动态节点</span>
       <span class="token punctuation">]</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">]</span><span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token comment">// Block 可以收集所有动态子代节点</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> patchFlag<span class="token operator">:</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>​	有了 Block 这个概念之后，渲染器的更新操作将会<strong>以 Block 为维度</strong>。也就是说，当渲染器在更新一个 Block 时，会忽略虚拟节点的 children 数组，而是<strong>直接找到该虚拟节点的 dynamicChildren 数组</strong>，并只更新该数组中的<strong>动态节点</strong>。这样，在更新时就实现了跳过静态内容，只更新动态内容。</p> <p>​	同时，由于<strong>动态节点中存在对应的补丁标志</strong>，所以在更新动态节点的时候，也能够做到靶向更新。例如，当一个动态节点的 patchFlag 值为数字 1 时，我们知道它只存在动态的文本节点，所以只需要更新它的文本内容即可。</p> <p>​	既然 Block 的好处这么多，那么什么情况下需要将一个普通的虚拟节点变成 Block节点呢？实际上，当我们<strong>在编写模板代码的时候，所有模板的根节点都会是一个 Block 节点</strong>：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token comment">&lt;!-- 这个 div 标签是一个 Block --&gt;</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">&lt;!-- 这个 p 标签不是 Block，因为它不是根节点 --&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ bar }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token comment">&lt;!-- 这个 h1 标签是一个 Block --&gt;</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">&lt;!-- 这个 span 标签不是 Block，因为它不是根节点 --&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dynamicId<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​	实际上，除了模板中的根节点需要作为 Block 角色之外，<strong>任何带有 v-for、v-if/v-else-if/v-else 等指令的节点都需要作为 Block 节点</strong>。</p> <h3 id="收集动态节点"><a href="#收集动态节点" class="header-anchor">#</a> 收集动态节点</h3> <p>​	在编译器生成的渲染函数代码中，并不会直接包含用来描述虚拟节点的数据结构，而是<strong>包含着用来创建虚拟 DOM 节点的辅助函数</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'text'</span><span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	其中 createVNode 函数就是用来创建虚拟 DOM 节点的辅助函数，它的基本实现类似于：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">createVNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> key <span class="token operator">=</span> props <span class="token operator">&amp;&amp;</span> props<span class="token punctuation">.</span>key
   props <span class="token operator">&amp;&amp;</span> <span class="token keyword">delete</span> props<span class="token punctuation">.</span>key

   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     tag<span class="token punctuation">,</span>
     props<span class="token punctuation">,</span>
     children<span class="token punctuation">,</span>
     key
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>可以看到，createVNode 函数的返回值是一个虚拟 DOM 节点。在 createVNode 函数内部，通常还会对 props 和 children 做一些额外的处理工作。</p></blockquote> <p>​	编译器在优化阶段提取的关键信息会影响最终生成的代码，具体体现在用于创建虚拟 DOM 节点的辅助函数上。假设我们有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	编译器在对这段模板进行编译优化后，会<strong>生成带有补丁标志（patch flag）的渲染函数</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">TEXT</span><span class="token punctuation">)</span> <span class="token comment">// PatchFlags.TEXT 就是补丁标志</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>用于创建 p 标签的 createVNode 函数调用存在第四个参数，即 PatchFlags.TEXT。这个参数就是所谓的<strong>补丁标志</strong>，它代表当前虚拟 DOM 节点是一个动态节点，并且动态因素是：<strong>具有动态的文本子节点</strong>。这样就实现了对动态节点的标记。</p></blockquote> <p>​	下一步我们要思考的是如何将根节点变成一个 Block，以及如何将动态子代节点收集到该 Block 的 dynamicChildren 数组中。这里有一个重要的事实，即在渲染函数内，对 createVNode 函数的调用是层层的嵌套结构，并且该函数的执行顺序是“<strong>内层先执行，外层后执行</strong>”：</p> <p><img src="/vivien-blog/assets/img/17-1.75c637f2.png" alt="由内向外的执行方式"></p> <p>​	当外层 createVNode 函数执行时，内层的 createVNode 函数已经执行完毕了。因此，为了让外层 Block 节点能够收集到内层动态节点，就需要一个栈结构的数据来临时存储内层的动态节点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 动态节点栈</span>
 <span class="token keyword">const</span> dynamicChildrenStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
 <span class="token comment">// 当前动态节点集合</span>
 <span class="token keyword">let</span> currentDynamicChildren <span class="token operator">=</span> <span class="token keyword">null</span>
 <span class="token comment">// openBlock 用来创建一个新的动态节点集合，并将该集合压入栈中</span>
 <span class="token keyword">function</span> <span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   dynamicChildrenStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>currentDynamicChildren <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// closeBlock 用来将通过 openBlock 创建的动态节点集合从栈中弹出</span>
 <span class="token keyword">function</span> <span class="token function">closeBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   currentDynamicChildren <span class="token operator">=</span> dynamicChildrenStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​	接着，我们还需要调整 createVNode 函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">createVNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> key <span class="token operator">=</span> props <span class="token operator">&amp;&amp;</span> props<span class="token punctuation">.</span>key
   props <span class="token operator">&amp;&amp;</span> <span class="token keyword">delete</span> props<span class="token punctuation">.</span>key

   <span class="token keyword">const</span> vnode <span class="token operator">=</span> <span class="token punctuation">{</span>
     tag<span class="token punctuation">,</span>
     props<span class="token punctuation">,</span>
     children<span class="token punctuation">,</span>
     key<span class="token punctuation">,</span>
     patchFlags<span class="token operator">:</span> flags
   <span class="token punctuation">}</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> flags <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> currentDynamicChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 动态节点，将其添加到当前动态节点集合中</span>
     currentDynamicChildren<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> vnode
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>在 createVNode 函数内部，检测节点是否存在补丁标志。如果存在，则说明该节点是动态节点，于是将其添加到当前动态节点集合 currentDynamicChildren 中。</p></blockquote> <p>​	 最后，我们需要重新设计渲染函数的执行方式：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 1. 使用 createBlock 代替 createVNode 来创建 block</span>
   <span class="token comment">// 2. 每当调用 createBlock 之前，先调用 openBlock</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* patch flag */</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'bar'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">createBlock</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// block 本质上也是一个 vnode</span>
   <span class="token keyword">const</span> block <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
   <span class="token comment">// 将当前动态节点集合作为 block.dynamicChildren</span>
   block<span class="token punctuation">.</span>dynamicChildren <span class="token operator">=</span> currentDynamicChildren

   <span class="token comment">// 关闭 block</span>
   <span class="token function">closeBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 返回</span>
   <span class="token keyword">return</span> block
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>利用逗号运算符的性质来保证渲染函数的返回值仍然是 VNode 对象。这里的关键点是 createBlock 函数**，任何应该作为 Block 角色的虚拟节点，都应该使用该函数来完成虚拟节点的创建。**</p> <p>由于createVNode 函数和 createBlock 函数的执行顺序是<strong>从内向外</strong>，所以当 createBlock 函数执行时，内层的所有 createVNode 函数<strong>已经执行完毕</strong>了。这时，currentDynamicChildren 数组中所存储的就是属于当前 Block 的所有动态子代节点。</p> <p>因此，我们只需要<strong>将 currentDynamicChildren 数组作为 block.dynamicChildren 属性的值</strong>即可。这样，我们就完成了动态节点的收集。</p></blockquote> <h3 id="渲染器的运行时支持"><a href="#渲染器的运行时支持" class="header-anchor">#</a> 渲染器的运行时支持</h3> <p>​	现在，我们已经有了动态节点集合 vnode.dynamicChildren，以及附着其上的补丁标志。基于这两点，即可在渲染器中实现靶向更新。</p> <p>​	回顾一下传统的节点更新方式，如下面的 patchElement 函数所示，它取自第三篇所讲解的渲染器：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> el <span class="token operator">=</span> n2<span class="token punctuation">.</span>el <span class="token operator">=</span> n1<span class="token punctuation">.</span>el
   <span class="token keyword">const</span> oldProps <span class="token operator">=</span> n1<span class="token punctuation">.</span>props
   <span class="token keyword">const</span> newProps <span class="token operator">=</span> n2<span class="token punctuation">.</span>props

   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> newProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">patchProps</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> oldProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> newProps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">patchProps</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 在处理 children 时，调用 patchChildren 函数</span>
   <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> el<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>渲染器在更新标签节点时，<strong>使用 patchChildren 函数</strong>来更新标签的子节点。但该函数会<strong>使用传统虚拟 DOM 的 Diff 算法</strong>进行更新，这样做效率比较低。</p></blockquote> <p>​	有了 dynamicChildren 之后，我们可以<strong>直接对比动态节点</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> el <span class="token operator">=</span> n2<span class="token punctuation">.</span>el <span class="token operator">=</span> n1<span class="token punctuation">.</span>el
   <span class="token keyword">const</span> oldProps <span class="token operator">=</span> n1<span class="token punctuation">.</span>props
   <span class="token keyword">const</span> newProps <span class="token operator">=</span> n2<span class="token punctuation">.</span>props

   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>dynamicChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用 patchBlockChildren 函数，这样只会更新动态节点</span>
     <span class="token function">patchBlockChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> el<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">patchBlockChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 只更新动态节点即可</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">.</span>dynamicChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">patchElement</span><span class="token punctuation">(</span>n1<span class="token punctuation">.</span>dynamicChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> n2<span class="token punctuation">.</span>dynamicChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>优先<strong>检测虚拟 DOM 是否存在动态节点集合</strong>，即 dynamicChildren 数组。如果存在，则直接调用 patchBlockChildren 函数完成更新。</p> <p>这样，渲染器只会更新动态节点，而跳过所有静态节点。</p></blockquote> <p>​	动态节点集合能够使得渲染器在执行更新时跳过静态节点，但对于单个动态节点的更新来说，由于它存在对应的补丁标志，因此我们可以针对性地完成靶向更新：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> el <span class="token operator">=</span> n2<span class="token punctuation">.</span>el <span class="token operator">=</span> n1<span class="token punctuation">.</span>el
   <span class="token keyword">const</span> oldProps <span class="token operator">=</span> n1<span class="token punctuation">.</span>props
   <span class="token keyword">const</span> newProps <span class="token operator">=</span> n2<span class="token punctuation">.</span>props

   <span class="token keyword">if</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>patchFlags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 靶向更新</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>patchFlags <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 只需要更新 class</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>patchFlags <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 只需要更新 style</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// ...</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 全量更新</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> newProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">patchProps</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> newProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> oldProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> newProps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">patchProps</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> oldProps<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 在处理 children 时，调用 patchChildren 函数</span>
   <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> el<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>通过<strong>检测补丁标志</strong>实现了 props 的靶向更新。这样就避免了全量的 props 更新，从而最大化地提升性能。</p></blockquote> <h2 id="block-树"><a href="#block-树" class="header-anchor">#</a> Block 树</h2> <p>​	前面提到，<strong>组件模板的根节点必须作为 Block 角色</strong>。这样，从根节点开始，所有动态子代节点都会被收集到根节点的 dynamicChildren 数组中。但是，如果只有根节点是 Block 角色，是不会形成 Block 树的。既然会形成 Block 树，那就意味着除了根节点之外，还会有其他特殊节点充当 Block 角色。实际上，<strong>带有结构化指令的节点，如带有 v-if 和 v-for 指令的节点，都应该作为 Block角色</strong>。接下来，我们就详细了解原因。</p> <h3 id="带有-v-if-指令的节点"><a href="#带有-v-if-指令的节点" class="header-anchor">#</a> 带有 v-if 指令的节点</h3> <p>​	  首先，我们来看下面这段模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ a }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ a }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	假设只有最外层的 div 标签会作为 Block 角色。那么，当变量 foo 的值为 true时，block 收集到的动态节点是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> cosnt block <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>a<span class="token punctuation">,</span> patchFlags<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	而当变量 foo 的值为 false 时，block 收集到的动态节点是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> cosnt block <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>a<span class="token punctuation">,</span> patchFlags<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	可以发现，无论变量 foo 的值是 true 还是 false，block 所收集的动态节点是不变的。这意味着，在 Diff 阶段不会做任何更新。但是我们也看到了，在上面的模板中，带有 v-if 指令的是 <code>&lt;section&gt;</code> 标签，而带有 v-else 指令的是 <code>&lt;div&gt;</code> 标签。很明显，更新前后的标签不同，如果不做任何更新，将产生严重的 bug。不仅如此，下面的模板也会出现同样的问题：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ a }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">v-else</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 即使这里是 section --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 这个 div 标签在 Diff 过程中被忽略 --&gt;</span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ a }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span> <span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>这段模板中，即使带有 v-if 指令的标签与带有 v-else 指令的标签都是<code>&lt;section&gt;</code> 标签，但由于两个分支的虚拟 DOM 树的结构不同，仍然会导致更新失败。</p></blockquote> <p>​	实际上，上述问题的根本原因在于，<strong>dynamicChildren 数组中收集的动态节点是忽略虚拟 DOM 树层级的</strong>。换句话说，结构化指令会导致更新前后模板的结构发生变化，即<strong>模板结构不稳定</strong>。那么，如何让虚拟 DOM 树的结构变稳定呢？其实很简单，只需要<strong>让带有 v-if/v-else-if/v-else 等结构化指令的节点也作为 Block 角色</strong>即可。</p> <p>​	以下面的模板为例：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ a }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">v-else</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 即使这里是 section --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 这个 div 标签在 Diff 过程中被忽略 --&gt;</span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ a }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span> <span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	如果上面这段模板中的两个 <code>&lt;section&gt;</code> 标签都作为 Block 角色，那么将构成一棵Block 树：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">Block</span><span class="token punctuation">(</span>Div<span class="token punctuation">)</span>
     <span class="token operator">-</span> <span class="token function">Block</span><span class="token punctuation">(</span>Section v<span class="token operator">-</span><span class="token keyword">if</span><span class="token punctuation">)</span>
     <span class="token operator">-</span> <span class="token function">Block</span><span class="token punctuation">(</span>Section v<span class="token operator">-</span><span class="token keyword">else</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	**父级 Block 除了会收集动态子代节点之外，也会收集子 Block。**因此，两个子Block(section) 将作为父级 Block(div) 的动态节点被收集到父级 Block(div) 的dynamicChildren 数组中：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> cosnt block <span class="token operator">=</span> <span class="token punctuation">{</span>
     tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
     dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
       <span class="token comment">/* Block(Section v-if) 或者 Block(Section v-else) */</span>
       <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'section'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token number">0</span> <span class="token comment">/* key 值会根据不同的 Block 而发生变化 */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	这样，当 v-if 条件为真时，父级 Block 的 dynamicChildren 数组中包含的是 Block(section v-if)；当 v-if 的条件为假时，父级 Block 的 dynamicChildren 数组中包含的将是 Block(section v-else)。在 Diff 过程中，渲染器能够根据 Block的 key 值区分出更新前后的两个 Block 是不同的，并使用新的 Block 替换旧的Block。这样就解决了 DOM 结构不稳定引起的更新问题。</p> <h3 id="带有-v-for-指令的节点"><a href="#带有-v-for-指令的节点" class="header-anchor">#</a> 带有 v-for 指令的节点</h3> <p>​	不仅带有 v-if 指令的节点会让虚拟 DOM 树的结构不稳定，带有 v-for 指令的节点也会让虚拟 DOM 树变得不稳定，而后者的情况会稍微复杂一些。</p> <p>​	思考如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ item }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">&gt;</span></span>{{ foo }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">&gt;</span></span>{{ bar }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	假设 list 是一个数组，在更新过程中，list 数组的值由 [1 ,2] 变为 [1]。按照之前的思路，即只有根节点会作为 Block 角色，那么，上面的模板中，只有最外层的<code>&lt;div&gt;</code> 标签会作为 Block。所以，这段模板在更新前后对应的 Block 树是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 更新前</span>
 <span class="token keyword">const</span> prevBlock <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'i'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'i'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>

 <span class="token comment">// 更新后</span>
 <span class="token keyword">const</span> nextBlock <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> item<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'i'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'i'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>​	更新前的 Block 树（prevBlock）中有四个动态节点，而更新后的 Block 树（nextBlock）中只有三个动态节点。这时要如何进行 Diff 操作呢？有人可能会说，使用更新前后的两个 dynamicChildren 数组内的节点进行传统 Diff 不就可以吗？这么做显然是不对的，因为**传统 Diff 的一个非常重要的前置条件是：进行 Diff 操作的节点必须是同层级节点。**但是 <strong>dynamicChildren 数组内的节点未必是同层级的</strong>，这一点我们在前面的章节中提到过。</p> <p>​	实际上，解决方法很简单，我们只需要<strong>让带有 v-for 指令的标签也作为 Block 角色</strong>即可。这样就能够保证虚拟 DOM 树具有稳定的结构，即无论 v-for 在运行时怎样变化，这棵 Block 树看上去都是一样的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> block <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token comment">// 这是一个 Block，它有 dynamicChildren</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> Fragment<span class="token punctuation">,</span> dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token comment">/* v-for 的节点 */</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'i'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'i'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> ctx<span class="token punctuation">.</span>bar<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	<strong>由于 v-for 指令渲染的是一个片段，所以我们需要使用类型为 Fragment 的节点来表达 v-for 指令的渲染结果，并作为 Block 角色。</strong></p> <h3 id="fragment-的稳定性"><a href="#fragment-的稳定性" class="header-anchor">#</a> Fragment 的稳定性</h3> <p>​	在前面，我们使用了一个 Fragment 来表达 v-for 循环产生的虚拟节点，并让其充当 Block 的角色来解决 v-for 指令导致的虚拟 DOM 树结构不稳定问题。但是，我们需要仔细研究这个 Fragment 节点本身。</p> <p>​	给出下面这段模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ item }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	当 list 数组由 [1, 2] 变成 [1] 时，Fragment 节点在更新前后对应的内容分别是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 更新前</span>
 <span class="token keyword">const</span> prevBlock <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> Fragment<span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> item<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> item<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 更新后</span>
 <span class="token keyword">const</span> prevBlock <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> Fragment<span class="token punctuation">,</span>
   dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> item<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>​	可以发现，<strong>Fragment 本身收集的动态节点仍然面临结构不稳定的情况。<strong>所谓结构不稳定，从结果上看，指的是</strong>更新前后一个 block 的 dynamicChildren 数组中收集的动态节点的数量或顺序不一致。<strong>这种不一致会</strong>导致无法直接进行靶向更新</strong>，怎么办呢？其实对于这种情况，没有更好的解决办法，我们只能放弃根据dynamicChildren 数组中的动态节点进行靶向更新的思路，并回退到传统虚拟DOM 的 Diff 手段，即直接使用 Fragment 的 children 而非 dynamicChildren来进行 Diff 操作。但需要注意的是，<strong>Fragment 的子节点（children）仍然可以是由 Block 组成的数组</strong>，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> block <span class="token operator">=</span> <span class="token punctuation">{</span>
   tag<span class="token operator">:</span> Fragment<span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> item<span class="token punctuation">,</span> dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token comment">/*...*/</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> item<span class="token punctuation">,</span> dynamicChildren<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token comment">/*...*/</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>这样，当 Fragment 的子节点进行更新时，就可以恢复优化模式。</p></blockquote> <p>​	既然有不稳定的 Fragment，那就有稳定的 Fragment。那什么样的 Fragment 是稳定的呢？有以下几种情况。</p> <ul><li><strong>v-for 指令的表达式是常量</strong>：</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>n in 10<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token comment">&lt;!-- 或者 --&gt;</span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>s in 'abc'<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>由于表达式 10 和 'abc' 是常量，所以无论怎样更新，上面两个 Fragment 都不会变化。因此这两个 Fragment 是稳定的。对于稳定的 Fragment，我们不需要回退到传统 Diff 操作，这在性能上会有一定的优势。</p></blockquote> <ul><li><strong>模板中有多个根节点</strong>。Vue.js 3 不再限制组件的模板必须有且仅有一个根节点。当模板中存在多个根节点时，我们需要使用 Fragment 来描述它。例如：</li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>同时，用于描述具有多个根节点的模板的 Fragment 也是稳定的。</p></blockquote> <h2 id="静态提升"><a href="#静态提升" class="header-anchor">#</a> 静态提升</h2> <p>​	**静态提升能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。**假设我们有如下模板：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>static text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ title }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	在没有静态提升的情况下，它对应的渲染函数是：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'static text'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>title<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	在这段虚拟 DOM 的描述中存在两个 p 标签，一个是纯静态的，而另一个拥有动态文本。当响应式数据 title 的值发生变化时，整个渲染函数会重新执行，并产生新的虚拟 DOM 树。这个过程有一个明显的问题，即<strong>纯静态的虚拟节点在更新时也会被重新创建一次</strong>。很显然，这是没有必要的，所以我们需要想办法避免由此带来的性能开销。而解决方案就是所谓的“静态提升”，即<strong>把纯静态的节点提升到渲染函数之外</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 把静态节点提升到渲染函数之外</span>
 <span class="token keyword">const</span> hoist1 <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'text'</span><span class="token punctuation">)</span>

 <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     hoist1<span class="token punctuation">,</span> <span class="token comment">// 静态节点引用</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>title<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>当把纯静态的节点提升到渲染函数之外后，<strong>在渲染函数内只会持有对静态节点的引用</strong>。当响应式数据变化，并使得渲染函数重新执行时，并不会重新创建静态的虚拟节点，从而避免了额外的性能开销。</p></blockquote> <p>​	需要强调的是，<strong>静态提升是以树为单位的</strong>。以下面的模板为例：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>abc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span> <span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>这段模板中，除了根节点的 div 标签会作为 Block 角色而不可被提升之外，整个 <code>&lt;section&gt;</code> 元素及其子代节点都会被提升。如果我们把上面模板中的静态字符串 abc 换成动态绑定的 ，那么整棵树都不会被提升。</p></blockquote> <p>​	虽然包含动态绑定的节点本身不会被提升，但是该动态节点上仍然可能存在纯静态的属性，如下面的模板所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">foo</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>bar<span class="token punctuation">&quot;</span></span> <span class="token attr-name">a</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>b</span><span class="token punctuation">&gt;</span></span>{{ text }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	这段模板中，p 标签存在动态绑定的文本内容，因此整个节点都不会被静态提升。但该节点的所有 props 都是静态的，因此在最终生成渲染函数时，我们可以<strong>将纯静态的 props 提升到渲染函数之外</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 静态提升的 props 对象</span>
 <span class="token keyword">const</span> hoistProp <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> a<span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> hoistProp<span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>这样做同样可以减少创建虚拟 DOM 产生的开销以及内存占用。</p></blockquote> <h2 id="预字符串化"><a href="#预字符串化" class="header-anchor">#</a> 预字符串化</h2> <p>​	基于静态提升，我们还可以进一步采用预字符串化的优化手段。**预字符串化是基于静态提升的一种优化策略。**静态提升的虚拟节点或虚拟节点树本身是静态的，那么，能否将其预字符串化呢？如下面的模板所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   // ... 20 个 p 标签
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	假设上面的模板中包含大量连续纯静态的标签节点，当采用了静态提升优化策略时，其编译后的代码如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> hoist1 <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">HOISTED</span><span class="token punctuation">)</span>
 <span class="token keyword">const</span> hoist2 <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">HOISTED</span><span class="token punctuation">)</span>
 <span class="token comment">// ... 20 个 hoistx 变量</span>
 cosnt hoist20 <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> PatchFlags<span class="token punctuation">.</span><span class="token constant">HOISTED</span><span class="token punctuation">)</span>

 <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     hoist1<span class="token punctuation">,</span> hoist2<span class="token punctuation">,</span> <span class="token comment">/* ...20 个变量 */</span><span class="token punctuation">,</span> hoist20
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	<strong>预字符串化能够将这些静态节点序列化为字符串，并生成一个 Static 类型的VNode</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> hoistStatic <span class="token operator">=</span> <span class="token function">createStaticVNode</span><span class="token punctuation">(</span><span class="token string">'&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;...20 个...&lt;p&gt;&lt;/p&gt;'</span><span class="token punctuation">)</span>

 <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     hoistStatic
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	这么做有几个明显的优势：</p> <ul><li>大块的静态内容可以通过 innerHTML 进行设置，在性能上具有一定优势。</li> <li>减少创建虚拟节点产生的性能开销。</li> <li>减少内存占用。</li></ul> <h2 id="缓存内联事件处理函数"><a href="#缓存内联事件处理函数" class="header-anchor">#</a> 缓存内联事件处理函数</h2> <p>​	提到优化，就不得不提对内联事件处理函数的缓存。**缓存内联事件处理函数可以避免不必要的更新。**假设模板内容如下：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Comp</span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a + b<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这段模板展示的是一个绑定了 change 事件的组件，并且为 change 事件绑定的事件处理程序是一个内联语句。对于这样的模板，编译器会为其创建一个内联事件处理函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token comment">// 内联事件处理函数</span>
     <span class="token function-variable function">onChange</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>a <span class="token operator">+</span> ctx<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	很显然，每次重新渲染时（即 render 函数重新执行时），都会为 Comp 组件创建一个全新的 props 对象。同时，props 对象中 onChange 属性的值也会是全新的函数。这会导致渲染器对 Comp 组件进行更新，造成额外的性能开销。为了避免这类无用的更新，我们需要对内联事件处理函数进行缓存：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将内联事件处理函数缓存到 cache 数组中</span>
     onChange<span class="token operator">:</span> cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>$event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>a <span class="token operator">+</span> ctx<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>渲染函数的第二个参数是一个<strong>数组 cache</strong>，该数组来自组件实例，可以把内联事件处理函数添加到 cache 数组中。</p> <p>这样，当渲染函数重新执行并创建新的虚拟 DOM 树时，会优先读取缓存中的事件处理函数。</p> <p>这样，无论执行多少次渲染函数，props 对象中 onChange 属性的值始终不变，于是就不会触发 Comp 组件更新了。</p></blockquote> <h2 id="v-once"><a href="#v-once" class="header-anchor">#</a> v-once</h2> <p>​	Vue.js 3 不仅会缓存内联事件处理函数，<strong>配合 v-once 还可实现对虚拟 DOM 的缓存。<strong>Vue.js 2 也支持 v-once 指令，当编译器遇到 v-once 指令时，会</strong>利用 cache 数组来缓存渲染函数的全部或者部分执行结果</strong>，如下面的模板所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-once</span><span class="token punctuation">&gt;</span></span>{{ foo }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	这段模板中，div 标签存在动态绑定的文本内容。但是它被 v-once 指令标记，所以这段模板会被编译为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createVNode</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>该 div 标签对应的虚拟节点被缓存到了 cache 数组中。</p></blockquote> <p>​	既然虚拟节点已经被缓存了，那么后续更新导致渲染函数重新执行时，会优先读取缓存的内容，而不会重新创建虚拟节点。同时，**由于虚拟节点被缓存，意味着更新前后的虚拟节点不会发生变化，因此也就不需要这些被缓存的虚拟节点参与 Diff 操作了。**所以在实际编译后的代码中经常出现下面这段内容：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">render</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">createBlock</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
     cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>
       <span class="token function">setBlockTracking</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 阻止这段 VNode 被 Block 收集</span>
       cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token function">setBlockTracking</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 恢复</span>
       cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 整个表达式的值</span>
     <span class="token punctuation">)</span>
   <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>注意这段代码中的 setBlockTracking(-1) 函数调用，它<strong>用来暂停动态节点的收集</strong>。换句话说，**使用 v-once 包裹的动态节点不会被父级 Block 收集。**因此，<strong>被 v-once 包裹的动态节点在组件更新时，自然不会参与 Diff 操作</strong>。</p></blockquote> <p>​	<strong>v-once 指令通常用于不会发生改变的动态绑定中</strong>，例如绑定一个常量：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ SOME_CONSTANT }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	为了提升性能，我们可以使用 v-once 来标记这段内容：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-once</span><span class="token punctuation">&gt;</span></span>{{ SOME_CONSTANT }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>这样，在组件更新时就会跳过这段内容的更新，从而提升更新性能。</p> <p>不会变化的常量，搭配 v-once，可以缓存 dom，不被 block 收集，参与组件的更新，起到优化性能的作用。</p></blockquote> <p>​	实际上，v-once 指令能够从两个方面提升性能：</p> <ul><li>**避免组件更新时重新创建虚拟 DOM 带来的性能开销。**因为虚拟 DOM 被缓存了，所以更新时无须重新创建。</li> <li>**避免无用的 Diff 开销。**这是因为被 v-once 标记的虚拟 DOM 树不会被父级Block 节点收集。</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>编译优化指的是通过编译的手段提取关键信息，并以此指导生成最优代码的过程。具体来说，Vue.js 3 的编译器会充分分析模板，提取关键信息并将其附着到对应的虚拟节点上。在运行时阶段，渲染器通过这些关键信息执行“快捷路径”，从而提升性能。</li> <li>编译优化的核心在于，区分动态节点与静态节点。Vue.js 3 会为动态节点打上补丁标志，即 patchFlag。同时，Vue.js 3 还提出了 Block 的概念，一个 Block 本质上也是一个虚拟节点，但与普通虚拟节点相比，会多出一个 dynamicChildren 数组。该数组用来收集所有动态子代节点，这利用了 createVNode 函数和createBlock 函数的层层嵌套调用的特点，即以“由内向外”的方式执行。再配合一个用来临时存储动态节点的节点栈，即可完成动态子代节点的收集。</li> <li>由于 Block 会收集所有动态子代节点，所以对动态节点的比对操作是忽略 DOM层级结构的。这会带来额外的问题，即 v-if、v-for 等结构化指令会影响 DOM 层级结构，使之不稳定。这会间接导致基于 Block 树的比对算法失效。而解决方式很简单，只需要让带有 v-if、v-for 等指令的节点也作为 Block 角色即可。</li> <li>除了 Block 树以及补丁标志之外，Vue.js 3 在编译优化方面还做了其他努力，具体如下。
<ul><li>静态提升：能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。</li> <li>预字符串化：在静态提升的基础上，对静态节点进行字符串化。这样做能够减少创建虚拟节点产生的性能开销以及内存占用。</li> <li>缓存内联事件处理函数：避免造成不必要的组件更新。</li> <li>v-once 指令：缓存全部或部分虚拟节点，能够避免组件更新时重新创建虚拟DOM 带来的性能开销，也可以避免无用的 Diff 操作。</li></ul></li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/20 00:32:58</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="prev">
          16.解析器
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html">
          18.同构渲染
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#动态节点收集与补丁标志" class="sidebar-link reco-side-动态节点收集与补丁标志" data-v-9f22dc18>动态节点收集与补丁标志</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#传统-diff-算法的问题" class="sidebar-link reco-side-传统-diff-算法的问题" data-v-9f22dc18>传统 Diff 算法的问题</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#block-与-patchflags" class="sidebar-link reco-side-block-与-patchflags" data-v-9f22dc18>Block 与 PatchFlags</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#收集动态节点" class="sidebar-link reco-side-收集动态节点" data-v-9f22dc18>收集动态节点</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#渲染器的运行时支持" class="sidebar-link reco-side-渲染器的运行时支持" data-v-9f22dc18>渲染器的运行时支持</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#block-树" class="sidebar-link reco-side-block-树" data-v-9f22dc18>Block 树</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#带有-v-if-指令的节点" class="sidebar-link reco-side-带有-v-if-指令的节点" data-v-9f22dc18>带有 v-if 指令的节点</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#带有-v-for-指令的节点" class="sidebar-link reco-side-带有-v-for-指令的节点" data-v-9f22dc18>带有 v-for 指令的节点</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#fragment-的稳定性" class="sidebar-link reco-side-fragment-的稳定性" data-v-9f22dc18>Fragment 的稳定性</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#静态提升" class="sidebar-link reco-side-静态提升" data-v-9f22dc18>静态提升</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#预字符串化" class="sidebar-link reco-side-预字符串化" data-v-9f22dc18>预字符串化</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#缓存内联事件处理函数" class="sidebar-link reco-side-缓存内联事件处理函数" data-v-9f22dc18>缓存内联事件处理函数</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#v-once" class="sidebar-link reco-side-v-once" data-v-9f22dc18>v-once</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/17.%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.7738f530.js" defer></script><script src="/vivien-blog/assets/js/7.464cc3ea.js" defer></script><script src="/vivien-blog/assets/js/2.db1c35d8.js" defer></script><script src="/vivien-blog/assets/js/1.88465532.js" defer></script><script src="/vivien-blog/assets/js/76.43f489ac.js" defer></script>
  </body>
</html>
