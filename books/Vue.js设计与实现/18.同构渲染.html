<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>18.同构渲染 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.fb52fe8e.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.ec60f3e8.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.6744b811.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.4a3363c7.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/49.fabffcc4.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.4c4f923d.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.23f6ee21.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.27280ff0.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.036dcfc2.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.dd57924a.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.c64926ce.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.ae22082c.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.cc5718d1.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.ea758456.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.1cece5c4.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.fb904237.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.c96b7ce6.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.cac5d5ac.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.2c304996.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.175b1533.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.f7a94348.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.108a87dc.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.1dd5813a.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.12e37784.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.d5a69554.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.c0d57e2c.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.e3681a63.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.88ab75a5.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.7279e08a.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.8c3104c3.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.2192c1e9.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.7e5316d9.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.2d45c303.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.e58f9b12.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.04389a95.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.c63d86f5.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.dedd7a57.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.3eabc773.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.e3641fb8.js"><link rel="prefetch" href="/vivien-blog/assets/js/132.2facddfc.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.dac78458.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.2e755ff2.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.019b3fee.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.7fea8ba1.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.8a66241c.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.b30ed550.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.0553bcb7.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.4d920a4a.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.d6f92154.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.f2b02a6d.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.08096abb.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.dcd037f0.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.bf9dc0fe.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.d7218834.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.d4fed813.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.3c835672.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.7a6d346e.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.8b973b0a.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.a10b30c7.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.4c227bf7.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.9873b2e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.661b84b0.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.e6dccfdc.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.98205037.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.8ef6d6eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.dc9c4a51.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.be23166d.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.6d6477a3.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.e5f670f0.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.236d900a.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.67482f69.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.1de2024a.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.7ddd9470.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.31587bf5.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.8616ff54.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.d3d247b3.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.927b0f38.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.8f70aa2d.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.e8d25d24.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.e8251262.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.fbef7aa0.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.2b707def.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.b5188815.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.8b80c528.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.d66e2998.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.ddbebf8b.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.8e7920c0.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.225e2695.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.892ce6e5.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.b8bfb276.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.843f60af.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.51cffd1c.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.5a86bccd.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.949972fa.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.33369a65.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.8e9ea32a.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.18095c46.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.f74a0870.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.4e844f29.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.b14f8508.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.a4ad5c5f.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.47d8709c.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.6f79a828.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.328bb2ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.6854995c.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.bf1fb5d8.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.650c3e3e.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.654802b9.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.ff61e0ac.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.b0ba342b.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.dfa3f211.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.1cdcd186.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.f50cbf20.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.6440b662.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.bfd378d6.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.b9ac818d.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.2ee8cc6a.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.56fa5a36.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.be00769d.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.e1d81528.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.524cff04.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.e5cb233a.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.15feaa5b.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.44aad763.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.45a553ea.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.74a76eb1.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.6314d68a.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.0def9066.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.1010a1a2.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.5dd57b30.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.b01b0c86.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.da1394aa.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="active sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>18.同构渲染</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">18.同构渲染</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/23</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><p>​	Vue.js 可以用于构建客户端应用程序，组件的代码在浏览器中运行，并输出 DOM 元素。同时，Vue.js 还可以在 Node.js 环境中运行，它可以将同样的组件渲染为字符串并发送给浏览器。这实际上描述了 Vue.js 的两种渲染方式，即<strong>客户端渲染</strong>（client-side rendering，CSR），以及<strong>服务端渲染</strong>（server-side rendering，SSR）。另外，Vue.js 作为现代前端框架，不仅能够独立地进行 CSR 或 SSR，还能够将两者结合，形成所谓的<strong>同构渲染</strong>（isomorphic rendering）。</p> <h2 id="csr、ssr-以及同构渲染"><a href="#csr、ssr-以及同构渲染" class="header-anchor">#</a> CSR、SSR 以及同构渲染</h2> <p>​	在设计软件时，我们经常会遇到这样的问题：“是否应该使用服务端渲染？” 这个问题没有确切的答案，具体还要看软件的需求以及场景。想要为软件选择合适的架构策略，就需要我们对不同的渲染策略做到了然于胸，知道它们各自的优缺点。</p> <h3 id="ssr"><a href="#ssr" class="header-anchor">#</a> SSR</h3> <p>​	服务端渲染并不是一项新技术，也不是一个新概念。在 Web 2.0 之前，网站主要负责提供各种各样的内容，通常是一些新闻站点、个人博客、小说站点等。这些站点主要强调内容本身，而不强调与用户之间具有高强度的交互。当时的站点基本采用传统的服务端渲染技术来实现。例如，比较流行的 PHP/JSP 等技术。</p> <p>​	下图给出了服务端渲染的工作流程：</p> <p><img src="/vivien-blog/assets/img/18-1.f2eaf3c9.png" alt="服务端渲染的工作流程"></p> <p>(1) 用户通过浏览器请求站点。（通过链接跳转，不是 Ajax）</p> <p>(2) 服务器请求 API 获取数据。</p> <p>(3) 接口返回数据给服务器。</p> <p>(4) 服务器根据模板和获取的数据拼接出最终的 HTML 字符串。</p> <p>(5) 服务器将 HTML 字符串发送给浏览器，浏览器解析 HTML 内容并渲染。</p> <p>当用户再次通过超链接进行页面跳转，会重复上述 5 个步骤。可以看到，传统的服务端渲染的用户体验非常差，任何一个微小的操作都可能导致页面刷新。</p> <h3 id="csr"><a href="#csr" class="header-anchor">#</a> CSR</h3> <p>​	后来以 AJAX 为代表，催生了 Web 2.0。在这个阶段，大量的 SPA（single-pageapplication）诞生，也就是 CSR 技术。与 SSR 在服务端完成模板和数据的融合不同，CSR 是在浏览器中完成模板与数据的融合，并渲染出最终的 HTML 页面。</p> <p>​	下图给出了 CSR 的详细工作流程：</p> <p><img src="/vivien-blog/assets/img/18-2.a9f71fcd.png" alt="CSR的工作流程"></p> <p>(1) **客户端向服务器或 CDN 发送请求，获取静态的 HTML 页面。**注意，此时获取的HTML 页面通常是空页面。在 HTML 页面中，会包含 <code>&lt;style&gt;</code>、<code>&lt;link&gt;</code> 和<code>&lt;script&gt;</code> 等标签。例如：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>zh<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>My App<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/dist/app.css<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/dist/app.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>这是一个包含 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 与 <code>&lt;script&gt;</code> 标签的空 HTML 页面。浏览器在得到该页面后，不会渲染出任何内容，所以从用户的视角看，此时页面处于“<strong>白屏</strong>”阶段。</p></blockquote> <p>(2) **虽然 HTML 页面是空的，但浏览器仍然会解析 HTML 内容。**由于 HTML 页面中存在 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 和 <code>&lt;script&gt;</code> 等标签，所以浏览器会加载 HTML 中引用的资源，例如 app.css 和 app.js。<strong>接着，服务器或 CDN 会将相应的资源返回给浏览器，浏览器对 CSS 和 JavaScript 代码进行解释和执行。<strong>因为页面的渲染任务是由 JavaScript 来完成的，所以当 JavaScript 被解释和执行后，才会渲染出页面内容，即“白屏”结束。但</strong>初始渲染出来的内容通常是一个“骨架”，因为还没有请求 API 获取数据。</strong></p> <p>(3) <strong>客户端再通过 AJAX 技术请求 API 获取数据，一旦接口返回数据，客户端就会完成动态内容的渲染，并呈现完整的页面。</strong></p> <p>当用户再次通过点击“跳转”到其他页面时，浏览器并不会真正的进行跳转动作，即不会进行刷新，而是通过前端路由的方式动态地渲染页面，这对用户的交互体验会非常友好。</p> <blockquote><p>CSR 加载的主包可能比较大，对首页性能会有影响。可以进行拆包、动态组件等减小主包大小的方式提升一下性能。也可以首页使用 SSR 解决该问题。</p></blockquote> <h3 id="对比-ssr-与-csr"><a href="#对比-ssr-与-csr" class="header-anchor">#</a> 对比 SSR 与 CSR</h3> <p>​	但很明显的是，与 SSR 相比，CSR 会产生所谓的“白屏”问题。实际上，CSR 不仅仅会产生白屏问题，它对 SEO（搜索引擎优化）也不友好。下表从多个方面比较了 SSR 与 CSR。</p> <table><thead><tr><th></th> <th>SSR</th> <th>CSR</th></tr></thead> <tbody><tr><td>SEO</td> <td>友好</td> <td>不友好</td></tr> <tr><td>白屏问题</td> <td>无</td> <td>有</td></tr> <tr><td>占用服务端资源</td> <td>多</td> <td>少</td></tr> <tr><td>用户体验</td> <td>差</td> <td>好</td></tr></tbody></table> <p>​	SSR 和 CSR 各有优缺点。SSR 对 SEO 更加友好，而 CSR 对 SEO 不太友好。由于 SSR 的内容到达时间更快，因此它不会产生白屏问题。相对地，CSR 会有白屏问题。另外，由于 SSR 是在服务端完成页面渲染的，所以它需要消耗更多服务端资源。CSR 则能够减少对服务端资源的消耗。对于用户体验，由于 CSR 不需要进行真正的“跳转”，用户会感觉更加“流畅”，所以 CSR 相比 SSR 具有更好的用户体验。从这些角度来看，无论是 SSR 还是 CSR，都不可以作为“银弹”，**我们需要从项目的实际需求出发，决定到底采用哪一个。**例如你的项目非常需要SEO，那么就应该采用 SSR。</p> <blockquote><ul><li><strong>服务器端渲染(SSR)</strong></li> <li>优点:</li></ul> <ol><li><p>更快的首屏加载速度：服务器已经生成了完整的 HTML 页面，用户可以直接看到内容，无需等待 JavaScript 在客户端执行。</p></li> <li><p>更好的 SEO：搜索擎爬虫可以更容易地抓取和索引服务器渲染的内容。</p></li> <li><p>适合复杂页面：对于包含大量数据和复杂计算的页面，SSR 可以减轻客户端的负载。</p> <ul><li>缺点:</li></ul></li> <li><p>服务器压力大：每个请求都需要服务器渲染，可能导致服务器资源消耗增加。</p></li> <li><p>开发复杂性：需要处理服务器端和客户端环境的差异，可能增加开发和调试的难度。</p></li> <li><p>缓存策略：需要考虑合适的缓存策略以提高性能。</p></li></ol> <ul><li><strong>客户端渲染(CSR)</strong> <ul><li>优点:</li></ul></li></ul> <ol><li><p>响应速度快：页面的更新和跳转不需要刷新页面，用户体验流畅。</p></li> <li><p>前端部署简单：通常只需要一个静态文件服务器即可部署应用。</p></li> <li><p>动态性强：易于实现复杂的用户交互和动态内容更新。</p> <ul><li>缺点:</li></ul></li> <li><p>首屏加载时间可能较长：需要等待 JavaScript 文件下载和执行，用户可能首先看到空白页面或加载中的提示。</p></li> <li><p>SEO 优化困难：搜索引擎爬虫可能无法执行 JavaScript，导致无法抓取动态生成的内容。</p></li> <li><p>白屏时间：在 JavaScript 加载和执行期间，用户可能会经历白屏等待。</p></li></ol> <p>​	在实际应用中，选择 SSR 还是 CSR 取决于项目的具体需求。如果项目对首屏加载时间和 SEO 有较高要求，SSR 可能是更好的选择；如果项目更注重动态交互和减少服务器负载，CSR 可能更合适。现代前端框架通常提供了 SSR 和 CSR 的解决方案，如 React 的 Next.js、Vue 的 Nuxt.js 等，使得开发者可以根据需要灵活选择渲染策略。</p></blockquote> <h3 id="同构渲染"><a href="#同构渲染" class="header-anchor">#</a> 同构渲染</h3> <p>​	那么，我们能否融合 SSR 与 CSR 两者的优点于一身呢？答案是“可以的”，这就是接下来我们要讨论的同构渲染。**同构渲染分为首次渲染（即首次访问或刷新页面）以及非首次渲染。**下图给出了同构渲染首次渲染的工作流程：</p> <p><img src="/vivien-blog/assets/img/18-3.7e50fa7d.png" alt="真实DOM与虚拟DOM的关系"></p> <p>​	实际上，**同构渲染中的首次渲染与 SSR 的工作流程是一致的。**也就是说，当首次访问或者刷新页面时，整个页面的内容是在服务端完成渲染的，浏览器最终得到的是渲染好的 HTML 页面。但是该页面是纯静态的，这意味着用户还不能与页面进行任何交互，因为整个应用程序的脚本还没有加载和执行。另外，该静态的HTML 页面中也会包含 <code>&lt;link&gt;</code>、<code>&lt;script&gt;</code> 等标签。除此之外，同构渲染所产生的 HTML 页面与 SSR 所产生的 HTML 页面有一点最大的不同，即前者会包含当前页面所需要的初始化数据。直白地说，服务器通过 API 请求的数据会被序列化为字符串，并拼接到静态的 HTML 字符串中，最后一并发送给浏览器。这么做实际上是为了后续的激活操作。</p> <p>​	**假设浏览器已经接收到初次渲染的静态 HTML 页面，接下来浏览器会解析并渲染该页面。**在解析过程中，浏览器会发现 HTML 代码中存在 <code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 标签，于是会从 CDN 或服务器获取相应的资源，这一步与 CSR 一致。当 JavaScript 资源加载完毕后，会进行激活操作，这里的激活就是我们在 Vue.js 中常说的 “hydration”。</p> <p>​	激活包含两部分工作内容:</p> <p>(1) Vue.js 在当前页面已经渲染的 DOM 元素以及 Vue.js 组件所渲染的虚拟 DOM 之间建立联系。（复用 DOM）</p> <p>(2) Vue.js 从 HTML 页面中提取由服务端序列化后发送过来的数据，用以初始化整个 Vue.js 应用程序。（提前初始化数据）</p> <p>​	激活完成后，整个应用程序已经完全被 Vue.js 接管为 CSR 应用程序了。后续操作都会按照 CSR 应用程序的流程来执行。当然，如果刷新页面，仍然会进行服务端渲染，然后再进行激活，如此往复。</p> <h3 id="对比-ssr、csr-和同构渲染"><a href="#对比-ssr、csr-和同构渲染" class="header-anchor">#</a> 对比 SSR、CSR 和同构渲染</h3> <p>​	下表对比了 SSR、CSR 和同构渲染的优劣：</p> <table><thead><tr><th></th> <th>SSR</th> <th>CSR</th> <th>同构渲染</th></tr></thead> <tbody><tr><td>SEO</td> <td>友好</td> <td>不友好</td> <td>友好</td></tr> <tr><td>白屏问题</td> <td>无</td> <td>有</td> <td>无</td></tr> <tr><td>占用服务端资源</td> <td>多</td> <td>少</td> <td>中</td></tr> <tr><td>用户体验</td> <td>差</td> <td>好</td> <td>好</td></tr></tbody></table> <p>​	同构渲染除了也需要部分服务端资源外，其他方面的表现都非常棒。由于同构渲染方案在首次渲染时和浏览器刷新时仍然需要服务端完成渲染工作，所以也需要部分服务端资源，但相比所有页面跳转都需要服务端完成渲染来说，同构渲染所占用的服务端资源相对少一些。</p> <p>​	另外，对同构渲染最多的误解是，它能够提升<strong>可交互时间</strong>（TTI）。事实是同构渲染仍然需要像 CSR 那样等待 JavaScript 资源加载完成，并且客户端激活完成后，才能响应用户操作。因此，理论上同构渲染无法提升可交互时间。</p> <p>​	**同构渲染的“同构”一词的含义是，同样一套代码既可以在服务端运行，也可以在客户端运行。**例如，我们用 Vue.js 编写一个组件，该组件既可以在服务端运行，被渲染为 HTML 字符串；也可以在客户端运行，就像普通的 CSR 应用程序一样。</p> <h2 id="将虚拟-dom-渲染为-html-字符串"><a href="#将虚拟-dom-渲染为-html-字符串" class="header-anchor">#</a> 将虚拟 DOM 渲染为 HTML 字符串</h2> <div class="custom-block tip"><p class="title"></p><p>以普通标签节点为例，在将其渲染为字符串时，要考虑以下内容:</p> <ul><li>自闭合标签的处理。对于自闭合标签，无须为其渲染闭合标签部分，也无须处理其子节点。</li> <li>属性名称的合法性，以及属性值的转义。</li> <li>文本子节点的转义。</li></ul> <p>具体的转义规则如下:</p> <ul><li><p>对于普通内容，应该对文本中的以下字符进行转义。</p> <ul><li><p>将字符 <code>&amp;</code> 转义为实体 <code>&amp;amp;</code>。</p></li> <li><p>将字符 <code>&lt;</code> 转义为实体 <code>&amp;lt;</code>。</p></li> <li><p>将字符 <code>&gt;</code> 转义为实体 <code>&amp;gt;</code>。</p></li></ul></li> <li><p>对于属性值，除了上述三个字符应该转义之外，还应该转义下面两个字符。</p> <ul><li><p>将字符 <code>&quot;</code> 转义为实体<code>&amp;quot;</code>。</p></li> <li><p>将字符 <code>'</code> 转义为实体 <code>&amp;#39;</code>。</p></li></ul></li></ul></div><p>​	既然“同构”指的是，同样的代码既能在服务端运行，也能在客户端运行，那么本节我们就讨论如何在服务端将虚拟 DOM 渲染为 HTML 字符串。（将普通标签类型的虚拟节点渲染为 HTML 字符串）</p> <p>​	给出如下虚拟节点对象，它用来描述一个普通的 div 标签：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> ElementVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   props<span class="token operator">:</span> <span class="token punctuation">{</span>
     id<span class="token operator">:</span> <span class="token string">'foo'</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>​	为了将虚拟节点 ElementVNode 渲染为字符串，我们需要实现 renderElementVNode 函数。该函数<strong>接收用来描述普通标签的虚拟节点作为参数，并返回渲染后的 HTML 字符串</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 返回渲染后的结果，即 HTML 字符串</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	在不考虑任何边界条件的情况下，实现 renderElementVNode 非常简单，如下面的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 取出标签名称 tag 和标签属性 props，以及标签的子节点</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
   <span class="token comment">// 开始标签的头部</span>
   <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
   <span class="token comment">// 处理标签属性</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 以 key=&quot;value&quot; 的形式拼接字符串</span>
       ret <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 开始标签的闭合</span>
   ret <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&gt;</span><span class="token template-punctuation string">`</span></span>

   <span class="token comment">// 处理子节点</span>
   <span class="token comment">// 如果子节点的类型是字符串，则是文本内容，直接拼接</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     ret <span class="token operator">+=</span> children
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果子节点的类型是数组，则递归地调用 renderElementVNode 完成渲染</span>
     children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>child <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       ret <span class="token operator">+=</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 结束标签</span>
   ret <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;</span><span class="token template-punctuation string">`</span></span>

   <span class="token comment">// 返回拼接好的 HTML 字符串</span>
   <span class="token keyword">return</span> ret
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>​	接着，我们可以调用 renderElementVNode 函数完成对 ElementVNode 的渲染：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">renderElementVNode</span><span class="token punctuation">(</span>ElementVNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// &lt;div id=&quot;foo&quot;&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/div&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	可以看到，输出结果是我们所期望的 HTML 字符串。**实际上，将一个普通标签类型的虚拟节点渲染为 HTML 字符串，本质上是字符串的拼接。**不过，上面给出的 renderElementVNode 函数的实现仅仅用来展示将虚拟 DOM 渲染为 HTML 字符串的核心原理，并不满足生产要求，因为它存在以下几点缺陷：</p> <ul><li>renderElementVNode 函数在渲染标签类型的虚拟节点时，还需要考虑该节点<strong>是否是自闭合标签</strong>。</li> <li>对于属性（props）的处理会比较复杂，要考虑<strong>属性名称是否合法</strong>，还要对属性值进行 HTML 转义。</li> <li>子节点的类型多种多样，<strong>可能是任意类型的虚拟节点</strong>，如 Fragment、组件、函数式组件、文本等，这些都需要处理。</li> <li>标签的<strong>文本子节点也需要进行 HTML 转义</strong>。</li></ul> <p>上述这些问题都属于边界条件，接下来我们逐个处理。</p> <p>​	首先处理自闭合标签，它的术语叫作 void element，它的完整列表如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> <span class="token constant">VOID_TAGS</span> <span class="token operator">=</span> <span class="token string">'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	可以在 WHATWG 的规范中查看完整的 void element。<strong>对于 void element，由于它无须闭合标签，所以在为此类标签生成 HTML 字符串时，无须为其生成对应的闭合标签</strong>，如下面的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> <span class="token constant">VOID_TAGS</span> <span class="token operator">=</span> <span class="token string">'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>

 <span class="token keyword">function</span> <span class="token function">renderElementVNode2</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
   <span class="token comment">// 判断是否是 void element</span>
   <span class="token keyword">const</span> isVoidElement <span class="token operator">=</span> <span class="token constant">VOID_TAGS</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>

   <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       ret <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>props<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 如果是 void element，则自闭合</span>
   ret <span class="token operator">+=</span> isVoidElement <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/&gt;</span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&gt;</span><span class="token template-punctuation string">`</span></span>
   <span class="token comment">// 如果是 void element，则直接返回结果，无须处理 children，因为 void element 没有 children</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>isVoidElement<span class="token punctuation">)</span> <span class="token keyword">return</span> ret

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     ret <span class="token operator">+=</span> children
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>child <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       ret <span class="token operator">+=</span> <span class="token function">renderElementVNode2</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   ret <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;</span><span class="token template-punctuation string">`</span></span>

   <span class="token keyword">return</span> ret
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><blockquote><p>增加了对 void element 的处理。注意，<strong>由于自闭合标签没有子节点，所以可以跳过对 children 的处理。</strong></p></blockquote> <p>​	接下来，我们需要更严谨地处理 HTML 属性。处理属性需要考虑多个方面，首先是对 boolean attribute 的处理。所谓 boolean attribute，并不是说这类属性的值是布尔类型，而是指，如果这类指令存在，则代表 true，否则代表 false。例如<code>&lt;input/&gt;</code> 标签的 checked 属性和 disabled 属性：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token comment">&lt;!-- 选中的 checkbox --&gt;</span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checkbox<span class="token punctuation">&quot;</span></span> <span class="token attr-name">checked</span> <span class="token punctuation">/&gt;</span></span>
 <span class="token comment">&lt;!-- 未选中的 checkbox --&gt;</span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>checkbox<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>当渲染 boolean attribute 时，通常无须渲染它的属性值。</p></blockquote> <p>​	关于属性，另外一点需要考虑的是安全问题。WHATWG 规范的 13.1.2.3 节中明确定义了属性名称的组成。属性名称必须由一个或多个<strong>非</strong>以下字符组成：</p> <ul><li>控制字符集（control character）的码点范围是：<code>[0x01, 0x1f]</code> 和 <code>[0x7f, 0x9f]</code>。</li> <li>U+0020 (SPACE)、U+0022 (&quot;)、U+0027 (')、U+003E (&gt;)、U+002F (/) 以及U+003D (=)。</li> <li>noncharacters，这里的 noncharacters 代表 Unicode 永久保留的码点，这些码点在 Unicode 内部使用，它的取值范围是：[0xFDD0, 0xFDEF]，还包括：0xFFFE、0xFFFF、0x1FFFE、0x1FFFF、0x2FFFE、0x2FFFF、0x3FFFE、0x3FFFF、0x4FFFE、0x4FFFF、0x5FFFE、0x5FFFF、0x6FFFE、0x6FFFF、0x7FFFE、0x7FFFF、0x8FFFE、0x8FFFF、0x9FFFE、0x9FFFF、0xAFFFE、0xAFFFF、0xBFFFE、0xBFFFF、0xCFFFE、0xCFFFF、0xDFFFE、0xDFFFF、0xEFFFE、0xEFFFF、0xFFFFE、0xFFFFF、0x10FFFE、0x10FFFF。</li></ul> <p>​	考虑到 Vue.js 的模板编译器在编译过程中已经对 noncharacters 以及控制字符集进行了处理，所以我们只需要小范围处理即可，任何不满足上述条件的属性名称都是不安全且不合法的。</p> <p>​	另外，**在虚拟节点中的 props 对象中，通常会包含仅用于组件运行时逻辑的相关属性。**例如，key 属性仅用于虚拟 DOM 的 Diff 算法，ref 属性仅用于实现template ref 的功能等。**在进行服务端渲染时，应该忽略这些属性。**除此之外，服务端渲染也无须考虑事件绑定。因此，<strong>也应该忽略 props 对象中的事件处理函数。</strong></p> <p>​	更加严谨的属性处理方案如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
   <span class="token keyword">const</span> isVoidElement <span class="token operator">=</span> <span class="token constant">VOID_TAGS</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>

   <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用 renderAttrs 函数进行严谨处理</span>
     ret <span class="token operator">+=</span> <span class="token function">renderAttrs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   ret <span class="token operator">+=</span> isVoidElement <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/&gt;</span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&gt;</span><span class="token template-punctuation string">`</span></span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>isVoidElement<span class="token punctuation">)</span> <span class="token keyword">return</span> ret

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     ret <span class="token operator">+=</span> children
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>child <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       ret <span class="token operator">+=</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   ret <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tag<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&gt;</span><span class="token template-punctuation string">`</span></span>

   <span class="token keyword">return</span> ret
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>​	可以看到，在 renderElementVNode 函数内，我们调用了 renderAttrs 函数来实现对 props 的处理。renderAttrs 函数的具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 应该忽略的属性</span>
 <span class="token keyword">const</span> shouldIgnoreProp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'ref'</span><span class="token punctuation">]</span>

 <span class="token keyword">function</span> <span class="token function">renderAttrs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token string">''</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>
       <span class="token comment">// 检测属性名称，如果是事件或应该被忽略的属性，则忽略它</span>
       shouldIgnoreProp<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">||</span>
       <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^on[^a-z]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
     <span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">continue</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">const</span> value <span class="token operator">=</span> props<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
     <span class="token comment">// 调用 renderDynamicAttr 完成属性的渲染</span>
     ret <span class="token operator">+=</span> <span class="token function">renderDynamicAttr</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> ret
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>​	renderDynamicAttr 函数的实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用来判断属性是否是 boolean attribute</span>
 <span class="token keyword">const</span> <span class="token function-variable function">isBooleanAttr</span> <span class="token operator">=</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
 <span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly</span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
   <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">,async,autofocus,autoplay,controls,default,defer,disabled,hidden,</span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
   <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">loop,open,required,reversed,scoped,seamless,</span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span>
   <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">checked,muted,multiple,selected</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

 <span class="token comment">// 用来判断属性名称是否合法且安全</span>
 <span class="token keyword">const</span> <span class="token function-variable function">isSSRSafeAttrName</span> <span class="token operator">=</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[&gt;/=&quot;'\u0009\u000a\u000c\u0020]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

 <span class="token keyword">function</span> <span class="token function">renderDynamicAttr</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBooleanAttr</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 对于 boolean attribute，如果值为 false，则什么都不需要渲染，否则只需要渲染 key 即可</span>
     <span class="token keyword">return</span> value <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSSRSafeAttrName</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 对于其他安全的属性，执行完整的渲染，</span>
     <span class="token comment">// 注意：对于属性值，我们需要对它执行 HTML 转义操作</span>
     <span class="token keyword">return</span> value <span class="token operator">===</span> <span class="token string">''</span> <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">escapeHtml</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;</span><span class="token template-punctuation string">`</span></span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 跳过不安全的属性，并打印警告信息</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>
       <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">[@vue/server-renderer] Skipped rendering unsafe attribute name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
     <span class="token punctuation">)</span>
     <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>​	这样我们就实现了对普通元素类型的虚拟节点的渲染。实际上，在 Vue.js 中，由于 class 和 style 这两个属性可以使用多种合法的数据结构来表示，例如 class 的值可以是字符串、对象、数组，所以理论上我们还需要考虑这些情况。不过原理都是相通的，<strong>对于使用不同数据结构表示的 class 或 style，我们只需要将不同类型的数据结构序列化成字符串表示即可。</strong></p> <p>​	另外，观察上面代码中的 renderDynamicAttr 函数的实现能够发现，在处理属性值时，我们调用了 escapeHtml 对其进行转义处理，这对于防御 XSS 攻击至关重要。</p> <blockquote><p>XSS 跨站脚本攻击，一般就是通过对标签<code>&lt;&gt;</code>符号的截取注入恶意代码，比如 script 标签之类的，对用户的信息 cookie 等进行抓取。</p></blockquote> <p>​	**HTML 转义指的是将特殊字符转换为对应的 HTML 实体。**其转换规则很简单：</p> <ul><li><p>如果该字符串作为普通内容被拼接，则应该对以下字符进行转义。</p> <ul><li><p>将字符 <code>&amp;</code> 转义为实体 <code>&amp;amp;</code>。</p></li> <li><p>将字符 <code>&lt;</code> 转义为实体 <code>&amp;lt;</code>。</p></li> <li><p>将字符 <code>&gt;</code> 转义为实体 <code>&amp;gt;</code>。</p></li></ul></li> <li><p>如果该字符串作为属性值被拼接，那么除了上述三个字符应该被转义之外，还应该转义下面两个字符。</p> <ul><li><p>将字符 <code>&quot;</code> 转义为实体 <code>&amp;quot;</code>。</p></li> <li><p>将字符 <code>'</code> 转义为实体<code>&amp;#39;</code>。</p></li></ul></li></ul> <p>具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> escapeRE <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[&quot;'&amp;&lt;&gt;]</span><span class="token regex-delimiter">/</span></span>
 <span class="token keyword">function</span> <span class="token function">escapeHtml</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">''</span> <span class="token operator">+</span> <span class="token builtin">string</span>
   <span class="token keyword">const</span> match <span class="token operator">=</span> escapeRE<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>match<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> str
   <span class="token punctuation">}</span>

   <span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token string">''</span>
   <span class="token keyword">let</span> escaped
   <span class="token keyword">let</span> index
   <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> match<span class="token punctuation">.</span>index<span class="token punctuation">;</span> index <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">switch</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">case</span> <span class="token number">34</span><span class="token operator">:</span> <span class="token comment">// &quot;</span>
         escaped <span class="token operator">=</span> <span class="token string">'&amp;quot;'</span>
         <span class="token keyword">break</span>
       <span class="token keyword">case</span> <span class="token number">38</span><span class="token operator">:</span> <span class="token comment">// &amp;</span>
         escaped <span class="token operator">=</span> <span class="token string">'&amp;amp;'</span>
         <span class="token keyword">break</span>
       <span class="token keyword">case</span> <span class="token number">39</span><span class="token operator">:</span> <span class="token comment">// '</span>
         escaped <span class="token operator">=</span> <span class="token string">'&amp;#39;'</span>
         <span class="token keyword">break</span>
       <span class="token keyword">case</span> <span class="token number">60</span><span class="token operator">:</span> <span class="token comment">// &lt;</span>
         escaped <span class="token operator">=</span> <span class="token string">'&amp;lt;'</span>
         <span class="token keyword">break</span>
       <span class="token keyword">case</span> <span class="token number">62</span><span class="token operator">:</span> <span class="token comment">// &gt;</span>
         escaped <span class="token operator">=</span> <span class="token string">'&amp;gt;'</span>
         <span class="token keyword">break</span>
       <span class="token keyword">default</span><span class="token operator">:</span>
         <span class="token keyword">continue</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">if</span> <span class="token punctuation">(</span>lastIndex <span class="token operator">!==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       html <span class="token operator">+=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>

     lastIndex <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>
     html <span class="token operator">+=</span> escaped
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> lastIndex <span class="token operator">!==</span> index <span class="token operator">?</span> html <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">:</span> html
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><blockquote><p>原理很简单，只需要<strong>在给定字符串中查找需要转义的字符，然后将其替换为对应的 HTML 实体</strong>即可。</p></blockquote> <h2 id="将组件渲染为-html-字符串"><a href="#将组件渲染为-html-字符串" class="header-anchor">#</a> 将组件渲染为 HTML 字符串</h2> <div class="custom-block tip"><p class="title"></p><p>在渲染组件时，需要考虑以下几点：</p> <ul><li>服务端渲染不存在数据变更后的重新渲染，所以无须调用 reactive 函数对 data等数据进行包装，也无须使用 shallowReactive 函数对 props 数据进行包装。正因如此，我们也无须调用 beforeUpdate 和 updated 钩子。</li> <li>服务端渲染时，由于不需要渲染真实 DOM 元素，所以无须调用组件的beforeMount 和 mounted 钩子。</li></ul></div><p>​	假设我们有如下组件，以及用来描述组件的虚拟节点：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 组件</span>
 <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token comment">// 该组件渲染一个 div 标签</span>
       <span class="token keyword">return</span> <span class="token punctuation">{</span>
         type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
         children<span class="token operator">:</span> <span class="token string">'hello'</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 用来描述组件的 VNode 对象</span>
 <span class="token keyword">const</span> CompVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>​	我们将实现 renderComponentVNode 函数，并用它把组件类型的虚拟节点渲染为 HTML 字符串：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">renderComponentVNode</span><span class="token punctuation">(</span>CompVNode<span class="token punctuation">)</span>
 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span> <span class="token comment">// 输出：&lt;div&gt;hello&lt;/div&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	实际上，把组件渲染为 HTML 字符串与把普通标签节点渲染为 HTML 字符串并没有本质区别。我们知道，**组件的渲染函数用来描述组件要渲染的内容，它的返回值是虚拟 DOM。**所以，我们只需要执行组件的渲染函数取得对应的虚拟 DOM，再将该虚拟 DOM 渲染为 HTML 字符串，并作为 renderComponentVNode 函数的返回值即可：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderComponentVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 获取 setup 组件选项</span>
   <span class="token keyword">let</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token punctuation">{</span> setup <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
   <span class="token comment">// 执行 setup 函数得到渲染函数 render</span>
   <span class="token keyword">const</span> render <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 执行渲染函数得到 subTree，即组件要渲染的内容</span>
   <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 调用 renderElementVNode 完成渲染，并返回其结果</span>
   <span class="token keyword">return</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>subTree<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	上面这段代码的逻辑非常简单，它仅仅展示了渲染组件的最基本原理，仍然存在很多问题：</p> <ul><li>subTree 本身可能是任意类型的虚拟节点，包括组件类型。因此，我们不能直接使用 renderElementVNode 来渲染它。</li> <li>执行 setup 函数时，也应该提供 setupContext 对象。而执行渲染函数 render时，也应该将其 this 指向 renderContext 对象。实际上，在组件的初始化和渲染方面，其完整流程与客户端的渲染流程一致。例如，也需要初始化 data，也需要得到 setup 函数的执行结果，并检查 setup 函数的返回值是函数还是 setupState 等。</li></ul> <p>​	对于第一个问题，我们可以通过封装通用函数来解决，如下面 renderVNode 函数的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token keyword">typeof</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token class-name"><span class="token keyword">if</span></span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token function">renderElementVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> type <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token function">renderComponentVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>type <span class="token operator">===</span> Text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 处理文本...</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>type <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 处理片段...</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 其他 VNode 类型</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​	有了 renderVNode 后，我们就可以在 renderComponentVNode 中使用它来渲染 subTree 了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderComponentVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token punctuation">{</span> setup <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
   <span class="token keyword">const</span> render <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 使用 renderVNode 完成对 subTree 的渲染</span>
   <span class="token keyword">return</span> <span class="token function">renderVNode</span><span class="token punctuation">(</span>subTree<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	第二个问题则涉及组件的初始化流程。我们先回顾一下组件在客户端渲染时的整体流程：</p> <p><img src="/vivien-blog/assets/img/18-4.10734a9b.png" alt="客户端渲染时，组件的初始化流程"></p> <p>​	在进行服务端渲染时，组件的初始化流程与客户端渲染时组件的初始化流程基本一致，但有两个重要的区别：</p> <ul><li>服务端渲染的是应用的当前快照，它不存在数据变更后重新渲染的情况。因此，**所有数据在服务端都无须是响应式的。**利用这一点，我们可以减少服务端渲染过程中创建响应式数据对象的开销。</li> <li>服务端渲染只需要获取组件要渲染的 subTree 即可，无须调用渲染器完成真实DOM 的创建。因此，<strong>在服务端渲染时，可以忽略“设置 render effect 完成渲染”这一步。</strong></li></ul> <p>下图给出了服务端渲染时初始化组件的流程：</p> <p><img src="/vivien-blog/assets/img/18-5.7f9cf25b.png" alt="服务端渲染时，组件的初始化流程"></p> <p>​	可以看到，只需要对客户端初始化组件的逻辑稍作调整，即可实现组件在服务端的渲染。另外，<strong>由于组件在服务端渲染时，不需要渲染真实 DOM 元素，所以无须创建并执行 render effect。<strong>这意味着，组件的 beforeMount 以及 mounted 钩子不会被触发。而且，由于</strong>服务端渲染不存在数据变更后的重新渲染逻辑</strong>，所以 beforeUpdate 和 updated 钩子也不会在服务端执行。完整的实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">renderComponentVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> isFunctional <span class="token operator">=</span> <span class="token keyword">typeof</span> vnode<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'function'</span>
   <span class="token keyword">let</span> componentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span><span class="token keyword">type</span>
   <span class="token class-name"><span class="token keyword">if</span></span> <span class="token punctuation">(</span>isFunctional<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     componentOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
       render<span class="token operator">:</span> vnode<span class="token punctuation">.</span>type<span class="token punctuation">,</span>
       props<span class="token operator">:</span> vnode<span class="token punctuation">.</span>type<span class="token punctuation">.</span>props
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">let</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> data<span class="token punctuation">,</span> setup<span class="token punctuation">,</span> beforeCreate<span class="token punctuation">,</span> created<span class="token punctuation">,</span> props<span class="token operator">:</span> propsOption <span class="token punctuation">}</span> <span class="token operator">=</span> componentOptions

   beforeCreate <span class="token operator">&amp;&amp;</span> <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token comment">// 无须使用 reactive() 创建 data 的响应式版本</span>
   <span class="token keyword">const</span> state <span class="token operator">=</span> data <span class="token operator">?</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token keyword">const</span> <span class="token punctuation">[</span>props<span class="token punctuation">,</span> attrs<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">resolveProps</span><span class="token punctuation">(</span>propsOption<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span>

   <span class="token keyword">const</span> slots <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

   <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>
     state<span class="token punctuation">,</span>
     props<span class="token punctuation">,</span> <span class="token comment">// props 无须 shallowReactive</span>
     isMounted<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
     subTree<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
     slots<span class="token punctuation">,</span>
     mounted<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     keepAliveCtx<span class="token operator">:</span> <span class="token keyword">null</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">function</span> <span class="token function">emit</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token operator">...</span>payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> eventName <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">on</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>event<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
     <span class="token keyword">const</span> handler <span class="token operator">=</span> instance<span class="token punctuation">.</span>props<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">handler</span><span class="token punctuation">(</span><span class="token operator">...</span>payload<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'事件不存在'</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// setup</span>
   <span class="token keyword">let</span> setupState <span class="token operator">=</span> <span class="token keyword">null</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>setup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> setupContext <span class="token operator">=</span> <span class="token punctuation">{</span> attrs<span class="token punctuation">,</span> emit<span class="token punctuation">,</span> slots <span class="token punctuation">}</span>
     <span class="token keyword">const</span> prevInstance <span class="token operator">=</span> <span class="token function">setCurrentInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
     <span class="token keyword">const</span> setupResult <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token function">shallowReadonly</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">,</span> setupContext<span class="token punctuation">)</span>
     <span class="token function">setCurrentInstance</span><span class="token punctuation">(</span>prevInstance<span class="token punctuation">)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setupResult <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>render<span class="token punctuation">)</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'setup 函数返回渲染函数，render 选项将被忽略'</span><span class="token punctuation">)</span>
       render <span class="token operator">=</span> setupResult
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       setupState <span class="token operator">=</span> setupContext
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   vnode<span class="token punctuation">.</span>component <span class="token operator">=</span> instance

   <span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props<span class="token punctuation">,</span> slots <span class="token punctuation">}</span> <span class="token operator">=</span> t

       <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">===</span> <span class="token string">'$slots'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> slots

       <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> state<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> props<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>setupState <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> setupState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> setupState<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'不存在'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token function">set</span> <span class="token punctuation">(</span>t<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> props <span class="token punctuation">}</span> <span class="token operator">=</span> t
       <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         state<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">in</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         props<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>setupState <span class="token operator">&amp;&amp;</span> k <span class="token keyword">in</span> setupState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         setupState<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'不存在'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   created <span class="token operator">&amp;&amp;</span> <span class="token function">created</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span>

   <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span>

   <span class="token keyword">return</span> <span class="token function">renderVNode</span><span class="token punctuation">(</span>subTree<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br></div></div><blockquote><p>观察上面的代码可以发现，该实现与客户端渲染的逻辑基本一致。这段代码与第13章给出的关于组件渲染的代码也非常相似，唯一的区别在于，<strong>在服务端渲染时，无须使用 reactive 函数为 data 数据创建响应式版本，并且 props 数据也无须是浅响应的。</strong></p></blockquote> <h2 id="客户端激活的原理"><a href="#客户端激活的原理" class="header-anchor">#</a> 客户端激活的原理</h2> <div class="custom-block tip"><p class="title"></p><p>激活操作可以总结为两个步骤:</p> <ul><li>在虚拟节点与真实 DOM 元素之间建立联系，即 vnode.el = el。这样才能保证后续更新程序正确运行。</li> <li>为 DOM 元素添加事件绑定。</li></ul></div><p>​	对于同构渲染来说，组件的代码会在服务端和客户端<strong>分别执行一次</strong>。在服务端，组件会被渲染为静态的 HTML 字符串，然后发送给浏览器，浏览器再把这段纯静态的 HTML 渲染出来。这意味着，此时页面中已经存在对应的 DOM 元素。同时，该组件还会被打包到一个 JavaScript 文件中，并在客户端被下载到浏览器中解释并执行。</p> <p>​	问题来了，当组件的代码在客户端执行时，会再次创建 DOM 元素吗？答案是“不会”。由于浏览器在渲染了由服务端发送过来的 HTML 字符串之后，页面中已经存在对应的 DOM 元素了，所以组件代码在客户端运行时，不需要再次创建相应的 DOM 元素。但是，组件代码在客户端运行时，仍然需要做两件重要的事：</p> <ul><li>在页面中的 DOM 元素与虚拟节点对象之间建立联系；</li> <li>为页面中的 DOM 元素添加事件绑定。</li></ul> <p>​	一个虚拟节点被挂载之后，为了保证更新程序能正确运行，需要<strong>通过该虚拟节点的 vnode.el 属性存储对真实 DOM 对象的引用</strong>。而同构渲染也是一样，为了应用程序在后续更新过程中能够正确运行，我们需要**在页面中已经存在的 DOM 对象与虚拟节点对象之间建立正确的联系。<strong>另外，在服务端渲染的过程中，会忽略虚拟节点中与事件相关的 props。所以，当组件代码在客户端运行时，我们需要</strong>将这些事件正确地绑定到元素上。**其实，这两个步骤就体现了客户端激活的含义。</p> <p>​	理解了客户端激活的含义后，我们再来看一下它的具体实现。当组件进行纯客户端渲染时，我们通过渲染器的 renderer.render 函数来完成渲染，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	而对于同构应用，我们将使用独立的 renderer.hydrate 函数来完成激活：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>renderer<span class="token punctuation">.</span><span class="token function">hydrate</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	实际上，我们可以用代码模拟从服务端渲染到客户端激活的整个过程：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// html 代表由服务端渲染的字符串</span>
 <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">renderComponentVNode</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">)</span>

 <span class="token comment">// 假设客户端已经拿到了由服务端渲染的字符串</span>
 <span class="token comment">// 获取挂载点</span>
 <span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
 <span class="token comment">// 设置挂载点的 innerHTML，模拟由服务端渲染的内容</span>
 container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> html

 <span class="token comment">// 接着调用 hydrate 函数完成激活</span>
 renderer<span class="token punctuation">.</span><span class="token function">hydrate</span><span class="token punctuation">(</span>compVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​	其中 CompVNode 的代码如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
   name<span class="token operator">:</span> <span class="token string">'App'</span><span class="token punctuation">,</span>
   <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token punctuation">{</span>
         type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
         children<span class="token operator">:</span> <span class="token punctuation">[</span>
           <span class="token punctuation">{</span>
             type<span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
             children<span class="token operator">:</span> str<span class="token punctuation">.</span>value<span class="token punctuation">,</span>
             props<span class="token operator">:</span> <span class="token punctuation">{</span>
               <span class="token function-variable function">onClick</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                 str<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">'bar'</span>
               <span class="token punctuation">}</span>
             <span class="token punctuation">}</span>
           <span class="token punctuation">}</span><span class="token punctuation">,</span>
           <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'baz'</span> <span class="token punctuation">}</span>
         <span class="token punctuation">]</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">const</span> CompVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> MyComponent<span class="token punctuation">,</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>​	接下来，我们着手实现 renderer.hydrate 函数。与 renderer.render 函数一样，renderer.hydrate 函数也是渲染器的一部分，因此它也会作为 createRenderer 函数的返回值：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">function</span> <span class="token function">hydrate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// ...</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
     render<span class="token punctuation">,</span>
     <span class="token comment">// 作为 createRenderer 函数的返回值</span>
     hydrate
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	这样，我们就可以通过 renderer.hydrate 函数来完成客户端激活了。在具体实现之前，我们先来看一下页面中已经存在的真实 DOM 元素与虚拟 DOM 对象之间的关系。下图给出了上面代码中 MyComponent 组件所渲染的真实 DOM 和它所渲染的虚拟 DOM 对象之间的关系：</p> <p><img src="/vivien-blog/assets/img/18-6.7e50fa7d.png" alt="真实DOM与虚拟DOM之间的关系"></p> <p>​	由上图可知，真实 DOM 元素与虚拟 DOM 对象都是树型结构，并且节点之间存在一一对应的关系。因此，我们可以认为它们是“同构”的。而激活的原理就是基于这一事实，<strong>递归地在真实 DOM 元素与虚拟 DOM 节点之间建立关系</strong>。另外，在虚拟 DOM 中并不存在与容器元素（或挂载点）对应的节点。因此，在激活的时候，应该从容器元素的第一个子节点开始，如下面的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">hydrate</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 从容器元素的第一个子节点开始</span>
   <span class="token function">hydrateNode</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>firstChild<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	其中，hydrateNode 函数接收两个参数，分别是真实 DOM 元素和虚拟 DOM 元素。hydrateNode 函数的具体实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">hydrateNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token punctuation">{</span> type <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
   <span class="token comment">// 1. 让 vnode.el 引用真实 DOM</span>
   vnode<span class="token punctuation">.</span>el <span class="token operator">=</span> node
   <span class="token comment">// 2. 检查虚拟 DOM 的类型，如果是组件，则调用 mountComponent 函数完成激活</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 3. 检查真实 DOM 的类型与虚拟 DOM 的类型是否匹配</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeType <span class="token operator">!==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'mismatch'</span><span class="token punctuation">)</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'服务端渲染的真实 DOM 节点是：'</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'客户端渲染的虚拟 DOM 节点是：'</span><span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 4. 如果是普通元素，则调用 hydrateElement 完成激活</span>
       <span class="token function">hydrateElement</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 5. 重要：hydrateNode 函数需要返回当前节点的下一个兄弟节点，以便继续进行后续的激活操作</span>
   <span class="token keyword">return</span> node<span class="token punctuation">.</span>nextSibling
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>hydrateNode 函数的关键点比较多。首先，要在真实 DOM 元素与虚拟 DOM 元素之间建立联系，即 vnode.el = node。这样才能保证后续更新操作正常进行。其次，我们需要检测虚拟 DOM 的类型，并据此判断应该执行怎样的激活操作。</p></blockquote> <p>​	在上面的代码中，我们展示了对组件和普通元素类型的虚拟节点的处理。可以看到，在激活普通元素类型的节点时，我们<strong>检查真实 DOM 元素的类型与虚拟 DOM 的类型是否相同</strong>，如果不同，则需要打印 mismatch 错误，即客户端渲染的节点与服务端渲染的节点不匹配。</p> <p>​	同时，为了能够让用户快速定位问题节点，保证开发体验，我们最好<strong>将客户端渲染的虚拟节点与服务端渲染的真实 DOM 节点都打印出来</strong>，供用户参考。对于<strong>组件</strong>类型节点的激活操作，则可以直接通过 <strong>mountComponent</strong> 函数来完成。对于<strong>普通元素</strong>的激活操作，则可以通过 <strong>hydrateElement</strong> 函数来完成。</p> <p>​	最后，<strong>hydrateNode 函数需要返回当前激活节点的下一个兄弟节点</strong>，以便进行后续的激活操作。hydrateNode 函数的返回值非常重要，它的用途体现在 hydrateElement 函数内：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用来激活普通元素类型的节点</span>
 <span class="token keyword">function</span> <span class="token function">hydrateElement</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 1. 为 DOM 元素添加事件</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 只有事件类型的 props 需要处理</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^on</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">patchProps</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>props<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 递归地激活子节点</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 从第一个子节点开始</span>
     <span class="token keyword">let</span> nextNode <span class="token operator">=</span> el<span class="token punctuation">.</span>firstChild
     <span class="token keyword">const</span> len <span class="token operator">=</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 激活子节点，注意，每当激活一个子节点，hydrateNode 函数都会返回当前子节点的下一个兄弟节点，</span>
       <span class="token comment">// 于是可以进行后续的激活了</span>
       nextNode <span class="token operator">=</span> <span class="token function">hydrateNode</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">,</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>hydrateElement 函数有两个关键点：</p> <ul><li>因为服务端渲染是忽略事件的，浏览器只是渲染了静态的 HTML 而已，所以激活 DOM 元素的操作之一就是为其<strong>添加事件处理程序</strong>。</li> <li><strong>递归地激活当前元素的子节点</strong>，从第一个子节点 el.firstChild 开始，递归地调用 hydrateNode 函数完成激活。注意这里的小技巧，hydrateNode 函数会返回当前节点的下一个兄弟节点，利用这个特点即可完成所有子节点的处理。</li></ul> <blockquote><p>其实就是服务端渲染返回的 HTML 文件中的 DOM 是没有绑定事件的，虚拟节点等 JS 数据都在 JS 文件中，所以在浏览器加载的时候 Vue. js 将服务器拼接的 DOM 和虚拟节点对应起来，将虚拟节点的 props 中的事件绑定到 DOM 上，从而实现事件绑定。</p></blockquote> <p>​	对于组件的激活，我们还需要针对性地处理 mountComponent 函数。**由于服务端渲染的页面中已经存在真实 DOM 元素，所以当调用 mountComponent 函数进行组件的挂载时，无须再次创建真实 DOM 元素。**基于此，我们需要对 mountComponent 函数做一些调整：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">mountComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   instance<span class="token punctuation">.</span>update <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> subTree <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">.</span>isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       beforeMount <span class="token operator">&amp;&amp;</span> <span class="token function">beforeMount</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span>
       <span class="token comment">// 如果 vnode.el 存在，则意味着要执行激活</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 直接调用 hydrateNode 完成激活</span>
         <span class="token function">hydrateNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> subTree<span class="token punctuation">)</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token comment">// 正常挂载</span>
         <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
       instance<span class="token punctuation">.</span>isMounted <span class="token operator">=</span> <span class="token boolean">true</span>
       mounted <span class="token operator">&amp;&amp;</span> <span class="token function">mounted</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span>
       instance<span class="token punctuation">.</span>mounted <span class="token operator">&amp;&amp;</span> instance<span class="token punctuation">.</span>mounted<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>hook <span class="token operator">=&gt;</span> <span class="token function">hook</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       beforeUpdate <span class="token operator">&amp;&amp;</span> <span class="token function">beforeUpdate</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>subTree<span class="token punctuation">,</span> subTree<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
       updated <span class="token operator">&amp;&amp;</span> <span class="token function">updated</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>renderContext<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     instance<span class="token punctuation">.</span>subTree <span class="token operator">=</span> subTree
   <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
     scheduler<span class="token operator">:</span> queueJob
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>唯一需要调整的地方就是组件的渲染副作用，即 render effect。<strong>hydrateNode 函数所做的第一件事是在真实 DOM 与虚拟 DOM 之间建立联系，即 vnode.el = node。<strong>所以，当渲染副作用执行挂载操作时，我们</strong>优先检查虚拟节点的 vnode.el 属性是否已经存在</strong>，如果存在，则意味着无须进行全新的挂载，只需要进行激活操作即可，否则仍然按照之前的逻辑进行全新的挂载。最后一个关键点是，<strong>组件的激活操作需要在真实 DOM 与 subTree 之间进行。</strong></p> <p>解析：正常情况下，如果是客户端渲染，在组件挂载元素之前，vnode 的 el 属性是空的。如果在挂载之前就有 vnode.el，说明这是服务端渲染的 DOM，即对 DOM 进行事件等的相关绑定。</p></blockquote> <h2 id="编写同构的代码"><a href="#编写同构的代码" class="header-anchor">#</a> 编写同构的代码</h2> <p>​	同构”一词指的是一份代码既在服务端运行，又在客户端运行。因此，在编写组件代码时，应该额外注意因代码运行环境的不同所导致的差异。</p> <div class="custom-block tip"><p class="title"></p><p>由于组件代码既运行于服务端，也运行于客户端，所以当我们编写组件代码时要额外注意。具体可以总结为以下几点:</p> <ul><li>注意组件的生命周期。beforeUpdate、updated、beforeMount、mounted、beforeUnmount、unmounted 等生命周期钩子函数不会在服务端执行。</li> <li>使用跨平台的 API。由于组件的代码既要在浏览器中运行，也要在服务器中运行，所以编写组件代码时，要额外注意代码的跨平台性。通常我们在选择第三方库的时候，会选择支持跨平台的库，例如使用 Axios 作为网络请求库。</li> <li>特定端的实现。无论在客户端还是在服务端，都应该保证功能的一致性。例如，组件需要读取 cookie 信息。在客户端，我们可以通过 document.cookie 来实现读取；而在服务端，则需要根据请求头来实现读取。所以，很多功能模块需要我们为客户端和服务端分别实现。</li> <li>避免交叉请求引起的状态污染。状态污染既可以是应用级的，也可以是模块级的。对于应用，我们应该为每一个请求创建一个独立的应用实例。对于模块，我们应该避免使用模块级的全局变量。这是因为在不做特殊处理的情况下，多个请求会共用模块级的全局变量，造成请求间的交叉污染。</li> <li>仅在客户端渲染组件中的部分内容。这需要我们自行封装 <code>&lt;ClientOnly&gt;</code> 组件，被该组件包裹的内容仅在客户端才会被渲染。</li></ul></div><h3 id="组件的生命周期"><a href="#组件的生命周期" class="header-anchor">#</a> 组件的生命周期</h3> <p>​	我们知道，当组件的代码在服务端运行时，由于不会对组件进行真正的挂载操作，即不会把虚拟 DOM 渲染为真实 DOM 元素，所以组件的 beforeMount 与mounted 这两个钩子函数不会执行。又因为服务端渲染的是应用的快照，所以不存在数据变化后的重新渲染，因此，组件的 beforeUpdate 与 updated 这两个钩子函数也不会执行。另外，在服务端渲染时，也不会发生组件被卸载的情况，所以组件的 beforeUnmount 与 unmounted 这两个钩子函数也不会执行。</p> <p>​	<strong>实际上，只有 beforeCreate 与 created 这两个钩子函数会在服务端执行</strong>，所以当编写组件代码时需要额外注意。如下是一段常见的问题代码：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token comment">// 做一些事情</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token function">beforeUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 清除定时器</span>
     <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>在 created 钩子函数中设置了一个定时器，并尝试在组件被卸载之前将其清除，即在 beforeUnmount 钩子函数执行时将其清除。</p> <p>如果在客户端运行这段代码，并不会产生任何问题；但如果在服务端运行，则会造成内存泄漏。因为 beforeUnmount 钩子函数不会在服务端运行，所以这个定时器将永远不会被清除。</p></blockquote> <p>​	实际上，在 created 钩子函数中设置定时器对于服务端渲染没有任何意义。这是因为**服务端渲染的是应用程序的快照，所谓快照，指的是在当前数据状态下页面应该呈现的内容。**所以，在定时器到时，修改数据状态之前，应用程序的快照已经渲染完毕了。所以我们说，在服务端渲染时，定时器内的代码没有任何意义。遇到这类问题时，我们通常有两个解决方案：</p> <ul><li>方案一：将创建定时器的代码<strong>移动到 mounted 钩子</strong>中，即只在客户端执行定时器；</li> <li>方案二：<strong>使用环境变量包裹</strong>这段代码，让其不在服务端运行。</li></ul> <p>​	方案一应该很好理解，而方案二依赖项目的环境变量。例如，在通过 webpack 或Vite 等构建工具搭建的同构项目中，通常带有这种环境变量。以 Vite 为例，我们可以使用 import.meta.env.SSR 来判断当前代码的运行环境：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 只在非服务端渲染时执行，即只在客户端执行</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">SSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token comment">// 做一些事情</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token function">beforeUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>我们通过 import.meta.env.SSR 来使代码只在特定环境中运行。实际上，**构建工具会分别为客户端和服务端输出两个独立的包。**构建工具在为客户端打包资源的时候，会在资源中排除被 import.meta.env.SSR 包裹的代码。换句话说，上面的代码中被 !import.meta.env.SSR 包裹的代码只会在客户端包中存在。</p></blockquote> <h3 id="使用跨平台的-api"><a href="#使用跨平台的-api" class="header-anchor">#</a> 使用跨平台的 API</h3> <p>​	编写同构代码的另一个关键点是使用跨平台的 API。**由于组件的代码既运行于浏览器，又运行于服务器，所以在编写代码的时候要避免使用平台特有的 API。**例如，仅在浏览器环境中才存在的 window、document 等对象。然而，<strong>有时你不得不使用这些平台特有的 API。这时你可以使用诸如 <code>import.meta.env.SSR</code> 这样的环境变量来做代码守卫</strong>：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">SSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 使用浏览器平台特有的 API</span>
   window<span class="token punctuation">.</span>xxx
 <span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	类似地，Node.js 中特有的 API 也无法在浏览器中运行。因此，为了减轻开发时的心智负担，我们可以选择跨平台的第三方库。例如，使用 Axios 作为网络请求库。</p> <h3 id="只在某一端引入模块"><a href="#只在某一端引入模块" class="header-anchor">#</a> 只在某一端引入模块</h3> <p>​	通常情况下，我们自己编写的组件的代码是可控的，这时我们可以使用跨平台的API 来保证代码“同构”。然而，<strong>第三方模块的代码非常不可控</strong>。假设我们有如下组件：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">import</span> storage <span class="token keyword">from</span> <span class="token string">'./storage.js'</span>
 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	这段组件代码本身没有任何问题，但它依赖了 ./storage.js 模块。**如果该模块中存在非同构的代码，则仍然会发生错误。**假设 ./storage.js 模块的代码如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// storage.js</span>
 <span class="token keyword">export</span> <span class="token keyword">const</span> storage <span class="token operator">=</span> window<span class="token punctuation">.</span>localStorage
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>./storage.js 模块中依赖了浏览器环境下特有的 API，即 window.localStorage。因此，当进行服务端渲染时会发生错误。</p></blockquote> <p>​	对于这个问题，有两种解决方案，<strong>方案一是使用 <code>import.meta.env.SSR</code> 来做代码守卫</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// storage.js</span>
 <span class="token keyword">export</span> <span class="token keyword">const</span> storage <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">SSR</span> <span class="token operator">?</span> window<span class="token punctuation">.</span>localStorage <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​	这样做虽然能解决问题，但是在大多数情况下我们无法修改第三方模块的代码。因此，更多时候我们会<strong>采用方案二来解决问题，即条件引入</strong>：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">let</span> storage
 <span class="token comment">// 只有在非 SSR 下才引入 ./storage.js 模块</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">SSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   storage <span class="token operator">=</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./storage.js'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>这段代码是修改后的组件代码，我们通过 <code>import.meta.env.SSR</code> 做了代码守卫，实现了特定环境下的模块加载。</p></blockquote> <p>​	但是，**仅在特定环境下加载模板，就意味着该模板的功能仅在该环境下生效。**例如在上面的代码中，./storage.js 模板的代码仅会在客户端生效。也就是说，服务端将会缺失该模块的功能。为了弥补这个缺陷，我们通常需要根据实际情况，再实现一个具有同样功能并且可运行于服务端的模块：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token keyword">let</span> storage
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">SSR</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 用于客户端</span>
   storage <span class="token operator">=</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./storage.js'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">// 用于服务端</span>
   storage <span class="token operator">=</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./storage-server.js'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>我们根据环境的不同，引入不同的模块实现。</p></blockquote> <h3 id="避免交叉请求引起的状态污染"><a href="#避免交叉请求引起的状态污染" class="header-anchor">#</a> 避免交叉请求引起的状态污染</h3> <p>​	编写同构代码时，额外需要注意的是，避免交叉请求引起的状态污染。<strong>在服务端渲染时，我们会为每一个请求创建一个全新的应用实例</strong>，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">import</span> <span class="token punctuation">{</span> createSSRApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
 <span class="token keyword">import</span> <span class="token punctuation">{</span> renderToString <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@vue/server-renderer'</span>
 <span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'App.vue'</span>

 <span class="token comment">// 每个请求到来，都会执行一次 render 函数</span>
 <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> manifest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 为当前请求创建应用实例</span>
    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createSSRApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>

   <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span>

   <span class="token keyword">return</span> html
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>每次调用 render 函数进行服务端渲染时，都会为当前请求调用 createSSRApp 函数来创建一个新的应用实例。这是为了避免不同请求共用同一个应用实例所导致的状态污染。</p></blockquote> <p>​	除了要为每一个请求创建独立的应用实例之外，状态污染的情况还可能发生在单个组件的代码中，如下所示：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
 <span class="token comment">// 模块级别的全局变量</span>
 <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>

 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
   <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     count<span class="token operator">++</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	如果上面这段组件的代码在浏览器中运行，则不会产生任何问题，因为<strong>浏览器与用户是一对一的关系</strong>，每一个浏览器都是独立的。但如果这段代码在服务器中运行，情况会有所不同，因为<strong>服务器与用户是一对多的关系</strong>。当用户 A 发送请求到服务器时，服务器会执行上面这段组件的代码，即执行 count++。接着，用户 B 也发送请求到服务器，服务器再次执行上面这段组件的代码，此时的 count 已经因用户 A 的请求自增了一次，因此对于用户 B 而言，用户 A 的请求会影响到他，于是就会造成请求间的交叉污染。所以，<strong>在编写组件代码时，要额外注意组件中出现的全局变量。</strong></p> <h3 id="clientonly-组件"><a href="#clientonly-组件" class="header-anchor">#</a> <code>&lt;ClientOnly&gt;</code> 组件</h3> <p>​	<code>&lt;ClientOnly&gt;</code>是一个对编写同构代码非常有帮助的组件，在日常开发中，我们经常会使用第三方模块。而它们不一定对 SSR 友好，例如：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SsrIncompatibleComp</span> <span class="token punctuation">/&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​	假设 <code>&lt;SsrIncompatibleComp /&gt;</code> 是一个不兼容 SSR 的第三方组件，我们没有办法修改它的源代码，这时应该怎么办呢？这时我们会想，既然这个组件不兼容SSR，那么能否只在客户端渲染该组件呢？其实是可以的，我们可以自行实现一个<code>&lt;ClientOnly&gt;</code> 的组件，该组件可以让模板的一部分内容仅在客户端渲染：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ClientOnly</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SsrIncompatibleComp</span> <span class="token punctuation">/&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ClientOnly</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>使用 <code>&lt;ClientOnly&gt;</code> 组件包裹了不兼容 SSR 的<code>&lt;SsrIncompatibleComp/&gt;</code> 组件。这样，在服务端渲染时就会忽略该组件，且该组件仅会在客户端被渲染。</p></blockquote> <p>​	那么，<code>&lt;ClientOnly&gt;</code> 组件是如何做到这一点的呢？这其实是**利用了 CSR 与 SSR 的差异。**如下是 <code>&lt;ClientOnly&gt;</code> 组件的实现：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

 <span class="token keyword">export</span> <span class="token keyword">const</span> ClientOnly <span class="token operator">=</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
   <span class="token function">setup</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">{</span> slots <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 标记变量，仅在客户端渲染时为 true</span>
     <span class="token keyword">const</span> show <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
     <span class="token comment">// onMounted 钩子只会在客户端执行</span>
     <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       show<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">true</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
     <span class="token comment">// 在服务端什么都不渲染，在客户端才会渲染 &lt;ClientOnly&gt; 组件的插槽内容</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>show<span class="token punctuation">.</span>value <span class="token operator">&amp;&amp;</span> slots<span class="token punctuation">.</span>default <span class="token operator">?</span> slots<span class="token punctuation">.</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>​	**其原理是利用了 onMounted 钩子只会在客户端执行的特性。**我们创建了一个标记变量 show，初始值为 false，并且仅在客户端渲染时将其设置为 true。这意味着，在服务端渲染的时候，<code>&lt;ClientOnly&gt;</code> 组件的插槽内容不会被渲染。而在客户端渲染时，只有等到 mounted 钩子触发后才会渲染 <code>&lt;ClientOnly&gt;</code> 组件的插槽内容。这样就实现了被 <code>&lt;ClientOnly&gt;</code> 组件包裹的内容仅会在客户端被渲染。</p> <p>​	另外，<code>&lt;ClientOnly&gt;</code> 组件并**不会导致客户端激活失败。**因为在客户端激活的时候，mounted 钩子还没有触发，所以服务端与客户端渲染的内容一致，即什么都不渲染。等到激活完成，且 mounted 钩子触发执行之后，才会在客户端将<code>&lt;ClientOnly&gt;</code> 组件的插槽内容渲染出来。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>当我们为应用程序选择渲染架构时，需要结合软件的需求及场景，选择合适的渲染方案。</li> <li>在服务端渲染组件与渲染普通标签并没有本质区别。我们只需要通过执行组件的 render 函数，得到该组件所渲染的 subTree 并将其渲染为 HTML 字符串即可。</li> <li>在同构渲染过程中，组件的代码会分别在服务端和浏览器中执行一次。在服务端，组件会被渲染为静态的 HTML 字符串，并发送给浏览器。浏览器则会渲染由服务端返回的静态的 HTML 内容，并下载打包在静态资源中的组件代码。当下载完毕后，浏览器会解释并执行该组件代码。当组件代码在客户端执行时，由于页面中已经存在对应的 DOM 元素，所以渲染器并不会执行创建 DOM 元素的逻辑，而是会执行激活操作。</li> <li>由于组件代码既运行于服务端，也运行于客户端，所以当我们编写组件代码时要额外注意。</li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/23 00:32:25</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="prev">
          17.编译优化
        </a></span> <!----></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#csr、ssr-以及同构渲染" class="sidebar-link reco-side-csr、ssr-以及同构渲染" data-v-9f22dc18>CSR、SSR 以及同构渲染</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#ssr" class="sidebar-link reco-side-ssr" data-v-9f22dc18>SSR</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#csr" class="sidebar-link reco-side-csr" data-v-9f22dc18>CSR</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#对比-ssr-与-csr" class="sidebar-link reco-side-对比-ssr-与-csr" data-v-9f22dc18>对比 SSR 与 CSR</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#同构渲染" class="sidebar-link reco-side-同构渲染" data-v-9f22dc18>同构渲染</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#对比-ssr、csr-和同构渲染" class="sidebar-link reco-side-对比-ssr、csr-和同构渲染" data-v-9f22dc18>对比 SSR、CSR 和同构渲染</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#将虚拟-dom-渲染为-html-字符串" class="sidebar-link reco-side-将虚拟-dom-渲染为-html-字符串" data-v-9f22dc18>将虚拟 DOM 渲染为 HTML 字符串</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#将组件渲染为-html-字符串" class="sidebar-link reco-side-将组件渲染为-html-字符串" data-v-9f22dc18>将组件渲染为 HTML 字符串</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#客户端激活的原理" class="sidebar-link reco-side-客户端激活的原理" data-v-9f22dc18>客户端激活的原理</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#编写同构的代码" class="sidebar-link reco-side-编写同构的代码" data-v-9f22dc18>编写同构的代码</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#组件的生命周期" class="sidebar-link reco-side-组件的生命周期" data-v-9f22dc18>组件的生命周期</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#使用跨平台的-api" class="sidebar-link reco-side-使用跨平台的-api" data-v-9f22dc18>使用跨平台的 API</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#只在某一端引入模块" class="sidebar-link reco-side-只在某一端引入模块" data-v-9f22dc18>只在某一端引入模块</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#避免交叉请求引起的状态污染" class="sidebar-link reco-side-避免交叉请求引起的状态污染" data-v-9f22dc18>避免交叉请求引起的状态污染</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#clientonly-组件" class="sidebar-link reco-side-clientonly-组件" data-v-9f22dc18>&lt;ClientOnly&gt; 组件</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/18.%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.fb52fe8e.js" defer></script><script src="/vivien-blog/assets/js/7.ec60f3e8.js" defer></script><script src="/vivien-blog/assets/js/2.6744b811.js" defer></script><script src="/vivien-blog/assets/js/1.4a3363c7.js" defer></script><script src="/vivien-blog/assets/js/49.fabffcc4.js" defer></script>
  </body>
</html>
