<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>4.响应系统的作用与实现 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.7738f530.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.464cc3ea.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.db1c35d8.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.88465532.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/27.383ae212.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.b772a431.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.62f13f40.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.262eebca.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.d15aec8d.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.3a4e8685.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.d8ef8d42.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.9c62ca3a.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.79799973.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3d688fa2.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.189a67fe.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.815085b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.d29dfabd.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.2ea8565d.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.3253031a.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.5feade57.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.819e6082.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.55297748.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.44b80f99.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.36461d4e.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.99af4d82.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.153f661c.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.df0b310d.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.4edb84f7.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.fa7bfc4d.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.f1a5a11a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.1580535f.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.d2a29b85.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.b5be33e2.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.52480968.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.94af5ec3.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.8dca7f6c.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.c753d508.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.bf5216d1.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.9bb718ff.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.dd72318d.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.025cbb0a.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.7cbb5ff9.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.099aee64.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.c1d6e501.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.2b108764.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.e9bcad68.js"><link rel="prefetch" href="/vivien-blog/assets/js/21.4582846d.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.169fb77c.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.aea2c93b.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.1866cbba.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.9ab9834f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.d71bb6eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.f47e5265.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.d6652043.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.542b86e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.d25326b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e55f1610.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.2fd2d217.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.0d01bb51.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.18330ce2.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.f63999dd.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.9c63570f.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.7e649a94.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.5cd0ff12.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.1380315b.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.9a8bc83a.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.dfc3dc84.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.9f0491a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.56c7442b.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.572118ca.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.a2889e9a.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.94b92181.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.546a376b.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.6e1296f2.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.294c2556.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.5c64fcbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.f38ecb23.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.a7eaecbc.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.566ea0ad.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.03726d99.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.44e0a209.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.196020b0.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.cb2a2b01.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.018c7e56.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.0b005dfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.7a746c54.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.9e0d4857.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.16f48649.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.54c9caee.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.932acfca.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.a26eda75.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.d6106a7d.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.0e84a519.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.04cd2610.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f99c6d3c.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.72422da4.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.31dada36.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.d8b153a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.ddda63c0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.6966e143.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.a2fbe5d8.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.48bb5c9c.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.debb65a8.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.0066da58.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.43f489ac.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.95333a2b.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.51dafac2.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6fe5ff10.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.03ddba74.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.1baba6a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.2f8bb846.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.b5976902.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.f64041b6.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.64d19acb.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.f89c690f.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.192fa399.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.ddf16957.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.25fbc2b8.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.4fea84f6.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.e5c8d0d5.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.201c7a26.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.4accbe01.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.a921fb5d.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.c4b024d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.872418d3.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.ae5ba79d.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.043c5690.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.fd1da6ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.a0dec3a9.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.15551b0c.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="active sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>4.响应系统的作用与实现</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">4.响应系统的作用与实现</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/8/22</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="响应式数据与副作用函数"><a href="#响应式数据与副作用函数" class="header-anchor">#</a> 响应式数据与副作用函数</h2> <blockquote><p>一切非纯函数（同样的输入对应同样的输出）都是有副作用的函数，也就是说副作用函数内部会直接或间接地影响到外部变量或函数。</p></blockquote> <p>​	副作用函数指的是会产生副作用的函数，<strong>副作用函数的执行会直接或间接影响其他函数的执行。</strong></p> <p>​	副作用很容易产生，例如一个函数修改了全局变量，这其实也是一个副作用。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 全局变量</span>
 <span class="token keyword">let</span> val <span class="token operator">=</span> <span class="token number">1</span>

 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   val <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 修改全局变量，产生副作用</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	**当一个对象的值发生改变会触发副作用函数执行，这个对象可以称为响应式数据。**响应式数据的核心在于数据变化能够被监测到，并自动触发相关的逻辑更新，无论这些更新是视图的更新，还是其他数据的更新。</p> <h2 id="响应式数据的基本实现"><a href="#响应式数据的基本实现" class="header-anchor">#</a> 响应式数据的基本实现</h2> <p>​	什么是响应式数据？如以下代码所示，副作用函数 effect 会设置 body 元素的 innerText 属性，其值为 obj.text，我们希望当 obj.text 的值发生变化时，副作用函数 effect 能够自动重新执行。如果我们能实现这个目标，那么 obj 就可以称为响应式数据。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">'hello world'</span> <span class="token punctuation">}</span>
 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// effect 函数的执行会读取 obj.text</span>
   document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>通过观察发现，实现该需求的两点线索：</p> <p>①当副作用函数 effect 执行时，会触发字段 obj.text 的<strong>读取操作</strong>；</p> <p>②当修改 obj.text 的值时，会触发字段 obj.text 的<strong>设置操作</strong>。</p> <p>如果我们能在 obj.text 的读取和设置时做一个拦截，事情就好办了。</p></blockquote> <p>​	显然，上面的代码无法实现这一点，因为 obj 只是一个普通的对象。但是如果我们能<strong>拦截一个对象的读取和设置操作</strong>，事情就变得简单了。</p> <ul><li>当读取字段 obj.text 时，我们可以把副作用函数 effect 存储到一个“桶”里，</li></ul> <p><img src="/vivien-blog/assets/img/image-20240821170256722.cf596e17.png" alt="存储到一个桶里"></p> <ul><li>接着，当设置 obj.text 时，再把副作用函数 effect 从“桶”里取出并执行即可。</li></ul> <p><img src="/vivien-blog/assets/img/image-20240821170330842.8f0c5518.png" alt="从桶里取出并执行"></p> <p>​	现在问题的关键变成了我们如何才能拦截一个对象属性的读取和设置操作。</p> <ul><li>在 ES2015 之前，只能通过 <strong>Object.defineProperty 函数</strong>实现，这也是 Vue.js 2 所采用的方式。</li> <li>在 ES2015+ 中，我们可以使用<strong>代理对象 Proxy</strong> 来实现，这也是 Vue.js 3 所采用的方式。</li></ul> <h3 id="用-set-作为桶的数据结构"><a href="#用-set-作为桶的数据结构" class="header-anchor">#</a> 用 Set 作为桶的数据结构</h3> <p>接下来我们就根据如上思路，采用 Proxy 来实现这一功能：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 存储副作用函数的桶</span>
 <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

 <span class="token comment">// 原始数据</span>
 <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">'hello world'</span> <span class="token punctuation">}</span>
 <span class="token comment">// 对原始数据的代理</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token comment">// 拦截读取操作</span>
   <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将副作用函数 effect 添加到存储副作用函数的桶中</span>
     bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
     <span class="token comment">// 返回属性值</span>
     <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// 拦截设置操作</span>
   <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 设置属性值（更新原始数据）</span>
     target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
     <span class="token comment">// 把副作用函数从桶里取出并执行</span>
     bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token comment">// 返回 true 代表设置操作成功</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p>在浏览器中运行以下这段代码，会得到期望的结果。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 副作用函数</span>
 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   	document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
 <span class="token punctuation">}</span>
 <span class="token comment">// 执行副作用函数，触发读取</span>
 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token comment">// 1 秒后修改响应式数据</span>
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   	obj<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'hello vue3'</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></blockquote> <p>​	但是目前的实现还存在很多缺陷，例如我们直接通过名字（effect）来获取副作用函数，这种硬编码的方式很不灵活。副作用函数的名字可以任意取，我们完全可以把副作用函数命名为 myEffect，甚至是一个匿名函数，因此我们<strong>要想办法去掉这种硬编码的机制</strong>。</p> <h2 id="设计一个完善的响应系统"><a href="#设计一个完善的响应系统" class="header-anchor">#</a> 设计一个完善的响应系统</h2> <blockquote><p>此前，我们设计了一个微型的响应系统，它还不完善，所以我们需要进一步来完善它。</p></blockquote> <div class="custom-block tip"><p class="title">一个响应系统的工作流程</p><p>当读取操作发生时，将副作用函数收集到“桶”中；</p> <p>当设置操作发生时，从“桶”中取出副作用函数并执行。</p></div><p>​	在上一节的实现中，我们硬编码了副作用函数的名字（effect），导致一旦<strong>副作用函数的名字</strong>不叫 effect，那么这段代码就不能正确地工作了，我们的响应式系统也就失效了。</p> <p>​	而我们希望的是，哪怕副作用函数是一个匿名函数，也能够被正确地收集到“桶”中。为了实现这一点，我们需要<strong>提供一个用来注册副作用函数的机制</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用一个全局变量存储被注册的副作用函数（初始值是 undefined）</span>
 <span class="token keyword">let</span> activeEffect
 <span class="token comment">// effect 函数用于注册副作用函数</span>
 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect（fn是要注册的副作用函数）</span>
   activeEffect <span class="token operator">=</span> fn
   <span class="token comment">// 执行副作用函数</span>
   <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>当 effect 函数执行时，首先会把匿名的副作用函数 fn 赋值给全局变量activeEffect，接着执行被注册的匿名副作用函数 fn。</p></blockquote> <p>我们可以使用 effect 函数来注册一个副作用函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span>
   <span class="token comment">// 一个匿名的副作用函数</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>这将会触发响应式数据 obj.text 的读取操作，进而触发代理对象 Proxy 的 get 拦截函数。</p></blockquote> <p>我们的响应式系统也需要进行一些修改：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token comment">// 拦截读取操作</span>
   <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将 activeEffect 中存储的副作用函数收集到“桶”中</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 新增</span>
       bucket<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     <span class="token punctuation">}</span>  <span class="token comment">// 新增</span>
     <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// 拦截设置操作</span>
   <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 设置属性值</span>
     target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
     <span class="token comment">// 把副作用函数从 bucket 中取出并执行</span>
     bucket<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token comment">// 返回 true 表示设置操作成功</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>由于副作用函数已经存储到了 activeEffect 中，所以在 get 拦截函数内应该把 activeEffect 收集到“桶”中，这样，响应式系统就不依赖副作用函数的名字了。</p></blockquote> <p>但如果我们在响应式数据 obj 上设置一个不存在的属性时：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span>
   <span class="token comment">// 匿名副作用函数</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'effect run'</span><span class="token punctuation">)</span> <span class="token comment">// 会打印 2 次</span>
     document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>

 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 副作用函数中并没有读取 notExist 属性的值</span>
   obj<span class="token punctuation">.</span>notExist <span class="token operator">=</span> <span class="token string">'hello vue3'</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在1秒后，我们给 obj 增加了一个新的属性，副作用函数也会执行，这是不正确的。</p> <blockquote><ul><li><p>匿名副作用函数内部读取了字段 obj.text 的值，于是匿名副作用函数与字段 obj.text 之间会建立响应联系。</p></li> <li><p>但是匿名副作用函数内并没有读取 obj.notExist 属性的值，所以理论上，字段obj.notExist 并没有与副作用建立响应联系，因此，定时器内语句的执行不应该触发匿名副作用函数重新执行。</p></li> <li><p>但我们执行上述代码发现，定时器到时后，匿名副作用函数却重新执行了，这是不正确的。为了解决这个问题，我们需要重新设计“桶”的数据结构。</p></li></ul></blockquote> <p>​	导致该问题的根本原因是，我们<strong>没有在副作用函数与被操作的目标字段之间建立明确的联系，无论我们设置的是什么属性，副作用函数都会被收集到&quot;桶&quot;中</strong>。例如当读取属性时，无论读取的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；当设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函数取出并执行。</p> <h3 id="用-weakmap-作为桶的数据结构"><a href="#用-weakmap-作为桶的数据结构" class="header-anchor">#</a> 用 WeakMap 作为桶的数据结构</h3> <p>​	解决方法很简单，我们<strong>只需要在副作用函数与被操作的字段之间建立联系即可</strong>，这就需要我们重新设计“桶”的数据结构，而不能简单地使用一个 Set 类型的数据作为“桶”了。</p> <p>我们仔细观察以下代码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>text
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以发现，如果用 target 来表示一个代理对象所代理的原始对象，用 key 来表示被操作的字段名，用 effectFn 来表示被注册的副作用函数，那么可以为这三个角色建立如下关系：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>target <span class="token comment">// 一个代理对象所代理的原始对象 obj</span>
  └── key <span class="token comment">// 被操作的字段名 text</span>
      └── effectFn <span class="token comment">// 被注册的副作用函数 effectFn </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这其实就是一个树型数据结构，这个联系建立起来之后，就可以解决前文提到的问题了。</p> <p>一个 target 可以有多个 key；一个 key 可以有多个 effectFn；一个 effectFn 可以对应多个 key。</p> <blockquote><p>下面举几个例子：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>text
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>关系如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>target
  └── key
      └── effectFn1
  	  └── effectFn2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><hr> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>foo
  obj<span class="token punctuation">.</span>bar
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>关系如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>target
  └── foo
  	  └── effectFn
  └── bar
  	  └── effectFn
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><hr> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj1<span class="token punctuation">.</span>foo
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj2<span class="token punctuation">.</span>bar
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>关系如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code>target1
  └── foo
  	  └── effectFn1
target2
  └── bar
  	  └── effectFn2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></blockquote> <div class="custom-block tip"><p class="title"></p><p>全局创建一个 Map 桶和 activeEffect 副作用函数，被代理的目标对象作为 key 放到桶里面，值是每个对象的 Map，对象的 Map 根据属性 key，访问装着副作用函数的 Set。</p> <p>读取属性值的时候，副作用函数存在就添加到 Set；写入属性值的时候，Set 中存在副作用函数就运行。</p> <p>这里的副作用函数就是同步到模版展示的函数。</p></div><blockquote><p>Set、Map 和 WeakMap 是 JavaScript 中的三种不同的集合类型，它们各自有着不同的特点和用途。</p> <table><thead><tr><th>集合类型</th> <th>特点和用途</th></tr></thead> <tbody><tr><td>Set</td> <td>Set 是一种<strong>无序且唯一</strong>的值的集合。<br>它只存储唯一的值，重复的值会被忽略。<br> Set 对象允许你插入、删除和检查某个值是否存在于集合中。<br> 它提供了一些方法和属性，如add()、delete()、has()等。</td></tr> <tr><td>Map</td> <td>Map 是一种<strong>键值对</strong>的集合。<br>在 Map 中，每个元素都由一个键（key）和一个值（value）组成，类似于字典。<br>与 Set 不同，Map 中的键可以是任何类型的值，包括基本数据类型和对象引用。<br>Map 对象提供了通过键进行操作的一系列方法，如set()、get()、delete()等。</td></tr> <tr><td>WeakMap</td> <td>WeakMap 与 Map 类似，也是一种<strong>键值对</strong>的集合。<br>但是，WeakMap 的键只能是对象。 WeakMap 中的键是<strong>弱引用</strong>，这意味着如果没有其他引用指向该键对象时，垃圾回收机制会自动回收该对象。<br>WeakMap 没有提供像 Map 那样的迭代方法，也没有 size 属性。</td></tr></tbody></table> <ul><li>Set 用于存储唯一值的集合。</li> <li>Map 用于存储键值对的集合，键可以是任何类型。</li> <li>WeakMap 与 Map 类似，但只接受对象作为键，并且键是弱引用，可自动回收。</li></ul></blockquote> <p>针对以上的分析，我们需要重新设置响应式系统。</p> <p>1、首先，需要使用 WeakMap 代替Set 作为桶的数据结构：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 存储副作用函数的桶</span>
 <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2、然后修改 get/set 拦截器代码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token comment">// 拦截读取操作</span>
   <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 没有 activeEffect，直接 return</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
     <span class="token comment">// 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --&gt; effects</span>
     <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token comment">// 初次为空</span>
     <span class="token comment">// 如果不存在 depsMap，那么新建一个 Map 并与 target 关联</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，</span>
     <span class="token comment">// 里面存储着所有与当前 key 相关联的副作用函数：effects</span>
     <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
     <span class="token comment">// 如果 deps 不存在，同样新建一个 Set 并与 key 关联</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 最后将当前激活的副作用函数添加到“桶”里</span>
     deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>

     <span class="token comment">// 返回属性值</span>
     <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// 拦截设置操作</span>
   <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 设置属性值</span>
     target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
     <span class="token comment">// 根据 target 从桶中取得 depsMap，它是 key --&gt; effects</span>
     <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token comment">// 初次为空</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
     <span class="token comment">// 根据 key 取得所有副作用函数 effects</span>
     <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
     <span class="token comment">// 执行副作用函数</span>
     effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><blockquote><p>实际上是这样的三层数据结构：WeakMap&lt;原始对象, Map&lt;原始对象的某个属性, 副作用函数Set&gt;&gt;</p> <p>WeakMap 的 key 是源对象，value 是一个 Map。而这个 Map 的 key 是源对象的键名，value 是获取这个键所在的副作用函数列表，也就是依赖（把 Set 数据结构所存储的副作用函数集合称为 key 的依赖集合）。</p> <p>桶和对象是 WeakMap 关系，对象和属性是 Map 关系，属性和副作用函数是 Set 关系，大树下是小树。</p></blockquote> <p>​	<code>WeakMap</code> 由 target --&gt; <code>Map</code> 构成；<code>Map</code> 由 key --&gt; <code>Set</code> 构成。</p> <p>​	其中， WeakMap 的键是原始对象 target，WeakMap 的值是一个 Map 实例，而 Map 的键是原始对象 target 的 key，Map 的值是一个由副作用函数组成的 Set。</p> <p><img src="/vivien-blog/assets/img/image-20240822091635172.913a032b.png" alt="WeakMap"></p> <div class="custom-block warning"><p class="title">这里为什么要使用WeakMap？</p><ul><li>**WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。**据这个特性可知，**一旦 key 被垃圾回收器回收，那么对应的键和值就访问不到了。**所以 WeakMap 经常用于存储那些只有当 key 所引用的对象存在时(没有被回收)才有价值的信息。</li> <li>如果 target 对象没有任何引用了，说明用户侧不再需要它了，这时垃圾回收器会完成回收任务。但如果使用 Map 来代替 WeakMap，那么即使用户侧的代码对 target 没有任何引用，这个 target 也不会被回收，最终可能导致内存溢出。</li></ul></div><p>3、最后，我们对上文中的代码做一些封装处理。在目前的实现中，当读取属性值时，我们直接在 get 拦截函数里编写<strong>把副作用函数收集到“桶”里</strong>的这部分逻辑，但更好的做法是将这部分逻辑单独封装到一个 <strong>track 函数</strong>中，track 是表达<strong>追踪</strong>的含义。同样，我们也可以把<strong>触发副作用函数重新执行</strong>的逻辑封装到 <strong>trigger 函数</strong>中，trigger 是表达<strong>触发</strong>的含义。：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 存储副作用的“桶”</span>
 <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token comment">// 原始数据</span>
 <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">'Hello world.'</span> <span class="token punctuation">}</span>
 <span class="token comment">// 对原始数据进行代理</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token comment">// 拦截读取操作</span>
   <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span>
     <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
     <span class="token comment">// 返回属性值</span>
     <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// 拦截设置操作</span>
   <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 设置属性值</span>
     target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
     <span class="token comment">// 把副作用函数从桶里取出并执行</span>
     <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
     <span class="token comment">// 返回 true 表示设置操作成功</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token comment">// 在 get 拦截函数内调用 track 函数追踪变化</span>
  <span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 没有 activeEffect（不存在副作用函数），直接 return</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token comment">// 从 bucket 中取出 depsMap，它是一个 Map 类型</span>
   <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 再根据 key 从 depsMap 中取出 deps，它是一个 Set 类型</span>
   <span class="token comment">// 里面存储着所有与当前 key 相当的副作用函数</span>
   <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 最后将副作用函数存储进 deps 里面</span>
   deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span>
 <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 根据 target 从 bucket 中取出所有的 depsMap</span>
   <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token comment">// 根据 key 从 depsMap 中取出所有的副作用函数</span>
   <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
   effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><blockquote><p>如以上代码所示，分别把逻辑封装到 track 和 trigger 函数内，这能为我们带来极大的灵活性。</p> <p>track 和 trigger 函数是 Vue 中依赖收集的核心。</p> <ul><li>track 函数在 get 拦截器中被调用，用于追踪此对象的某个属性。当我们访问一个属性时，该函数将activeEffect（即对应的副作用函数）添加到一个名为 bucket 的 WeakMap 中，具体的存放位置是<code>bucket[target][key]</code>。这意味着，当属性 key 的值改变时，需要执行的函数（activeEffect）已经被正确地记住了。</li> <li>trigger 函数在 set 拦截器中被调用，用于在修改属性的值时触发更新。当我们设置一个属性的新值时，该函数会从 bucket 中找到对应的副作用函数并执行它们。</li> <li>effects 语义：执行并收集一个函数的依赖，当这些依赖发生改变时，重新执行这个函数。依赖需要被清晰地描述，以避免发生冲突，详细记录函数依赖了哪个对象的哪个属性。</li></ul></blockquote> <h2 id="分支切换与-cleanup"><a href="#分支切换与-cleanup" class="header-anchor">#</a> 分支切换与 cleanup</h2> <h3 id="分支切换"><a href="#分支切换" class="header-anchor">#</a> 分支切换</h3> <p>​	首先，我们需要明确分支切换的定义，如下面的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> ok<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">'hello world'</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>ok <span class="token operator">?</span> obj<span class="token punctuation">.</span>text <span class="token operator">:</span> <span class="token string">'not'</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	在 effectFn 函数内部存在一个三元表达式，根据字段 <code>obj.ok</code> 值的不同会执行不同的代码分支。当字段 <code>obj.ok</code> 的值发生变化时，代码执行的分支会跟着变化，这就是所谓的<strong>分支切换</strong>。</p> <p>​	分支切换可能会<strong>产生遗留的副作用函数</strong>。拿上面这段代码来说，当 effectFn 函数执行时会触发字段 <code>obj.ok</code> 和字段 <code>obj.text</code> 这两个属性的读取操作，此时副作用函数 effectFn 与响应式数据之间建立的联系如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> data
     └── ok
         └── effectFn
     └── text
         └── effectFn
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="/vivien-blog/assets/img/image-20240822094655591.b3628df3.png" alt="effectFn与响应式数据之间建立的联系"></p> <p>​	可见，副作用函数 effectFn 分别被字段 <code>data.ok</code> 和字段 <code>data.text</code> 所对应的依赖集合收集。</p> <p>​	当字段 <code>obj.ok</code> 的值修改为 false，并触发副作用函数重新执行后，由于此时字段 <code>obj.text</code> 不会被读取，只会触发字段 <code>obj.ok</code> 的读取操作，所以理想情况下副作用函数 effectFn 不应该被字段 <code>obj.text</code> 所对应的依赖集合收集：</p> <p><img src="/vivien-blog/assets/img/image-20240822095332060.1430c10f.png" alt="理想情况"></p> <p>​	但按照前文的实现，我们还做不到这一点。也就是说，当我们把字段<code>obj.ok</code> 的值修改为 false，并触发副作用函数重新执行之后，整个依赖关系仍然保持一开始所描述的那样，这时就产生了遗留的副作用函数。</p> <blockquote><p><code>obj.text</code> 对应的 effectFn 还是被收集起来了，当我们改变 <code>obj.text</code> 的值时，会触发更新，导致副作用函数重新运行，即使 <code>document.body.textContent</code> 的值不需要变化。这就会导致无用的更新。</p></blockquote> <p>​	<strong>遗留的副作用函数会导致不必要的更新。</strong></p> <p>​	仍然拿前文的这段代码来说，</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> ok<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">'hello world'</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>ok <span class="token operator">?</span> obj<span class="token punctuation">.</span>text <span class="token operator">:</span> <span class="token string">'not'</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	<code>obj.ok</code> 的初始值为 true，当我们将其修改为 false 后，会触发更新，即副作用函数会重新执行。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> obj<span class="token punctuation">.</span>ok <span class="token operator">=</span> <span class="token boolean">false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	但由于此时 <code>obj.ok</code> 的值为false，所以不再会读取字段 <code>obj.text</code> 的值。换句话说，无论字段 <code>obj.text</code> 的值如何改变，document.body.innerText 的值始终都是字符串 'not'。</p> <p>​	所以最好的结果是，无论 <code>obj.text</code> 的值怎么变，都不需要重新执行副作用函数。但事实并非如此，如果我们再尝试修改 <code>obj.text</code> 的值：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> obj<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'hello vue3'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​	这仍然会导致副作用函数重新执行，即使 document.body.innerText 的值不需要变化，说明<strong>原来收集的依赖还在</strong>。</p> <h3 id="cleanup"><a href="#cleanup" class="header-anchor">#</a> cleanup</h3> <p>​	解决这个问题的思路很简单，<strong>每次副作用函数执行时，我们可以先把它从所有与之关联的依赖集合中删除</strong>（清除它关联的副作用函数）。当副作用函数执行完毕后，会重新再建立联系，但在新的联系中不再包含遗留的副作用函数。</p> <p><img src="/vivien-blog/assets/img/image-20240822100936419.0797cf7d.png" alt="思路"></p> <blockquote><p>注意：</p> <ul><li>此处的依赖集合是上面提到的，Set 数据结构所存储的副作用函数集合。</li> <li>对应的关系是：target --&gt; key --&gt; effects；</li> <li>使用的数据结构是：WeakMap(target --&gt;  depsMap) --&gt; Map(key  --&gt; deps) --&gt; Set(effects)</li></ul></blockquote> <p>​	如果我们能做到每次副作用函数执行前，将其从相关联的依赖集合中移除，那么问题就迎刃而解了。**只对执行到的副作用函数进行收集/保留，而删掉那些多余的，**这就是一种更新机制。</p> <blockquote><p>相当于每次执行过程前先清除依赖 deps，执行完之后如果有三元，会将仅存的有读取的属性绑定 effetFn 依赖。</p> <p>每次在副作用回调函数 fn 执行前，都将 effectFn 从相关联的依赖集合中删除，然后再执行回调函数 fn，重新建立联系。</p></blockquote> <p>​	要将一个副作用函数从所有与之关联的依赖集合中移除，就需要明确知道哪些依赖集合中包含它，因此我们需要重新设计副作用函数，如下面的代码所示。<strong>在 effect 内部我们定义了新的 effectFn 函数，并为其添加了effectFn.deps 属性</strong>，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用一个全局变量存储被注册的副作用函数</span>
 <span class="token keyword">let</span> activeEffect
 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 当 effectFn 执行时，将其设置为当前激活的副作用函数</span>
     activeEffect <span class="token operator">=</span> effectFn
     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span>
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 执行副作用函数</span>
   <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​	那么 effectFn.deps 数组中的依赖集合是如何收集的呢？其实是在 track 函数中：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 没有 activeEffect，直接 return</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>activeEffect<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token keyword">let</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     bucket<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">let</span> deps <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> 
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>deps<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
     depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>deps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
   <span class="token punctuation">}</span> 
   <span class="token comment">// 把当前激活的副作用函数添加到依赖集合 deps 中</span>
   deps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span> 
   <span class="token comment">// deps 就是一个与当前副作用函数存在联系的依赖集合</span>
   <span class="token comment">// 将其添加到 activeEffect.deps 数组中</span>
   activeEffect<span class="token punctuation">.</span>deps<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>deps<span class="token punctuation">)</span> <span class="token comment">// 新增</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>​	在 track 函数中我们将当前执行的副作用函数 activeEffect 添加到依赖集合 deps 中，这说明 <strong>deps 就是一个与当前副作用函数存在联系的依赖集合</strong>，于是我们也把它添加到 activeEffect.deps 数组中，这样就完成了对依赖集合的收集。</p> <p><img src="/vivien-blog/assets/img/image-20240822101649570.0c673f21.png" alt="对依赖集合的收集"></p> <p>​	有了这个联系后，我们就可以在每次副作用函数执行时，先清除之前的联系，即根据 effectFn.deps 获取所有相关联的依赖集合，进而<strong>将副作用函数从依赖集合中移除</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用一个全局变量存储被注册的副作用函数</span>
 <span class="token keyword">let</span> activeEffect
 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 调用 cleanup 函数完成清除工作</span>
     <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     activeEffect <span class="token operator">=</span> effectFn
     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​	下面是 cleanup 函数的实现：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 遍历 effectFn.deps 数组</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// deps 是依赖集合</span>
     <span class="token keyword">const</span> deps <span class="token operator">=</span> effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token comment">// 将 effectFn 从依赖集合中移除</span>
     deps<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 最后需要重置 effectFn.deps 数组</span>
   effectFn<span class="token punctuation">.</span>deps<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​	cleanup 函数接收副作用函数作为参数，遍历副作用函数的effectFn.deps 数组，该数组的每一项都是一个依赖集合，然后将该副作用函数从依赖集合中移除，最后<strong>重置 effectFn.deps 数组</strong>。</p> <p>​	至此，我们的响应系统已经可以避免副作用函数产生遗留了。</p> <p>​	但目前的实现会导致无限循环执行，问题出在 trigger函数中：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
   effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 问题出在这句代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	在 trigger 函数内部，我们遍历 effects 集合，它是一个 Set 集合，里面存储着副作用函数。当副作用函数执行时，会调用 cleanup 进行清除，实际上就是从 effects 集合中将当前执行的副作用函数剔除，但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 effects 集合的遍历仍在进行。</p> <blockquote><ul><li>其实就是在同一个 Set 中 forEach 遍历，某个值又删又增的情况（不断删除添加同一个元素），会进行无限循环，所以需要新增一个 Set，这样，一个负责遍历，另一个负责增删，本质上是避开规范带来的bug 而已。</li> <li>执行副作用函数时移除它的依赖项，如果它的副作用函数执行了 set，又会重新收集依赖项。所以会形成死循环，解决办法是用一个新 set。</li></ul></blockquote> <div class="custom-block danger"><p class="title">为何会出现这样的现象？</p><p>执行步骤：</p> <p>1、副作用函数注册执行，在 track 函数中收集了对应的依赖关系。</p> <p>2、此时，访问了代理对象的 set 方法，触发了 trigger 函数;</p> <p>3、trigge r函数此时先调用 cleanup 函数，后调用原始的 fn 副作用函数</p> <p>4、问题来了，在 trigger 函数中对副作用队列遍历执行中，先从队列中删除了副作用函数（执行了cleanup），后又因为执行了 fn 函数，导致依赖被重新收集到队列中，从而出现了死循环。</p></div><p>这个行为可以用如下简短的代码来表达：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

 set<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'遍历中'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote><p>语言规范中对此有明确的说明：在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但该值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么该值会重新被访问。因此，上面的代码会无限执行。解决办法很简单，我们可以<strong>构造另外一个 Set 集合并遍历它</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

 <span class="token keyword">const</span> newSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span>
 newSet<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   set<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'遍历中'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这样就不会无限执行了。</p></blockquote> <p>回到 trigger 函数，我们需要同样的手段来防止代码进入死循环：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
   
   <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>effects<span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
   effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>effectFn <span class="token operator">=&gt;</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
   <span class="token comment">// effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn()) // 删除</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如以上代码所示，我们新构造了 effectsToRun 集合并遍历它，代替直接遍历 effects 集合，从而避免了无限执行。</p> <blockquote><p>new 一个新的 set 去遍历，但实际上修改的是原来的 set 结构，所以不会循环。分成了 2 个 set，一个负责遍历，一个负责增删。</p></blockquote> <p>最后我们的检验一下代码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token comment">// 副作用函数</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'run'</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerText <span class="token operator">=</span> obj<span class="token punctuation">.</span>ok <span class="token operator">?</span> obj<span class="token punctuation">.</span>text <span class="token operator">:</span> <span class="token string">'plain text.'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>ok <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>text <span class="token operator">=</span> <span class="token string">'Hello again.'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>控制台一共输出两次 run，一次是 <code>obj.ok</code> 初始值为 true时，另一次为 <code>obj.ok</code> 的值设置为 false 时。当 <code>obj.text</code> 的值改变时，副作用不再执行，说明我们上面的改动是符合需求的。</p></blockquote> <h2 id="嵌套的-effect-与-effect-栈"><a href="#嵌套的-effect-与-effect-栈" class="header-anchor">#</a> 嵌套的 effect 与 effect 栈</h2> <p>​	**effect 是可以发生嵌套的。**例如下面这段代码，effectFn1 内部嵌套了 effectFn2，effectFn1 的执行会导致 effectFn2 的执行。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token comment">/* ... */</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="为什么-effect-要设计成可嵌套的"><a href="#为什么-effect-要设计成可嵌套的" class="header-anchor">#</a> 为什么 effect 要设计成可嵌套的</h3> <p>那么什么场景会出现嵌套的 effect 呢？实际上， Vue.js 的渲染函数就是在一个 effect 中执行的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// Foo 组件</span>
 <span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token comment">/* ... */</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在一个 effect 中执行 Foo 组件的渲染函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   Foo<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当组件发生嵌套时，例如 Foo 组件渲染了 Bar 组件：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// Bar 组件</span>
 <span class="token keyword">const</span> Bar <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// Foo 组件渲染了 Bar 组件</span>
 <span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
   <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">&lt;</span>Bar <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">// jsx 语法</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>此时就发生了 effect 嵌套，它相当于：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   Foo<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token comment">// 嵌套</span>
   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     Bar<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="如果-effect-不支持嵌套会发生什么"><a href="#如果-effect-不支持嵌套会发生什么" class="header-anchor">#</a> 如果 effect 不支持嵌套会发生什么</h3> <p>​	实际上，按照前文的实现，我们所实现的响应系统并不支持 effect 嵌套，可以用下面的代码来测试一下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 原始数据</span>
 <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
 <span class="token comment">// 代理对象</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token comment">// 全局变量</span>
 <span class="token keyword">let</span> temp1<span class="token punctuation">,</span> temp2

 <span class="token comment">// effectFn1 嵌套了 effectFn2</span>
 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'effectFn1 执行'</span><span class="token punctuation">)</span>

   <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'effectFn2 执行'</span><span class="token punctuation">)</span>
     <span class="token comment">// 在 effectFn2 中读取 obj.bar 属性</span>
     temp2 <span class="token operator">=</span> obj<span class="token punctuation">.</span>bar
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token comment">// 在 effectFn1 中读取 obj.foo 属性</span>
   temp1 <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>在理想情况下，我们希望副作用函数与对象属性之间的联系如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> data
   └── foo
     └── effectFn1
   └── bar
     └── effectFn2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>我们希望当修改 obj.foo 时会触发 effectFn1 执行。由于effectFn2 嵌套在 effectFn1 里，所以会间接触发 effectFn2 执行，而当修改 obj.bar 时，只会触发 effectFn2 执行。</p></blockquote> <p>但结果不是这样的，我们尝试修改 obj.foo 的值，会发现输出为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token string">'effectFn1 执行'</span>
 <span class="token string">'effectFn2 执行'</span>
 <span class="token string">'effectFn2 执行'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>我们修改了字段 obj.foo 的值，发现 effectFn1 并没有重新执行，反而使得 effectFn2重新执行了，这显然不符合预期。</p></blockquote> <p>**问题出在哪里呢？**其实就出在我们实现的 effect 函数与 activeEffect 上。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用一个全局变量存储当前激活的 effect 函数</span>
 <span class="token keyword">let</span> activeEffect
 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span>
     activeEffect <span class="token operator">=</span> effectFn
     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span>
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 执行副作用函数</span>
   <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>我们用<strong>全局变量 activeEffect</strong> 来存储通过 effect 函数注册的副作用函数，这意味着<strong>同一时刻</strong> activeEffect 所存储的副作用函数<strong>只能有一个</strong>。</p> <p>当副作用函数发生嵌套时，<strong>内层副作用函数的执行会覆盖 activeEffect 的值</strong>，并且永远<strong>不会恢复</strong>到原来的值。</p> <p>这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也<strong>都会是内层副作用函数</strong>，这就是问题所在。</p></blockquote> <h3 id="函数栈-effectstack"><a href="#函数栈-effectstack" class="header-anchor">#</a> 函数栈 effectStack</h3> <p>​	为了解决这个问题，我们<strong>需要一个副作用函数栈 effectStack</strong> 来缓存外层函数的副作用函数，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况。</p> <blockquote><p><strong>副作用函数执行时 push，执行完成就从栈中 pop，始终保持 activeEffect 指向栈顶的副作用函数。</strong></p></blockquote> <p>​	如以下代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 用一个全局变量存储当前激活的 effect 函数</span>
 <span class="token keyword">let</span> activeEffect
 <span class="token comment">// effect 栈</span>
 <span class="token keyword">const</span> effectStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// 新增</span>

 <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span>
     activeEffect <span class="token operator">=</span> effectFn
     <span class="token comment">// 在调用副作用函数之前将当前副作用函数压入栈中</span>
     effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈</span>
     effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     <span class="token comment">// 并把 activeEffect 还原为之前的值</span>
     activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// 新增 </span>
   <span class="token punctuation">}</span>
   <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span>
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 执行副作用函数</span>
   <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>​	定义了 effectStack 数组，用它来模拟栈，activeEffect 没有变化，它仍然指向当前正在执行的副作用函数。不同的是，当前执行的副作用函数会被压入栈顶，这样当副作用函数发生嵌套时，栈底存储的就是外层副作用函数，而栈顶存储的则是内层副作用函数。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 第一次 effect() 执行</span>
<span class="token comment">// effectFn === effectFn1</span>
<span class="token comment">// 那么 effectStack.push(effectFn) 后，effectStack 就变成了 [effectFn1]</span>
<span class="token comment">// 之后 fn() 执行，也就是整个 effectFn1() 执行，</span>
<span class="token comment">// effectFn1() 的执行，导致 effect() 再次执行</span>
<span class="token comment">// 此时 effectFn === effectFn2</span>
<span class="token comment">// 那么 effectStack.push(effectFn) 后，effectStack 就变成了 [effectFn1, effectFn2]</span>
<span class="token comment">// fn() 执行后，会回到 effectFn1 的副作用函数上面</span>
<span class="token comment">// 此时 effectStack.pop() 后 effectStack 就变成了 [effectFn1]</span>
<span class="token comment">// 我们从 effectStack 中取出最后一项给 activeEffect</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><img src="/vivien-blog/assets/img/image-20240822133818580.89e987f2.png" alt="activeEffect"></p> <blockquote><p>当内层副作用函数 effectFn2 执行完毕后，它会被弹出栈，并将副作用函数 effectFn1 设置为 activeEffect</p></blockquote> <p><img src="/vivien-blog/assets/img/image-20240822134018301.09f6f182.png" alt="弹出"></p> <blockquote><p>如此一来，响应式数据就只会收集直接读取其值的副作用函数作为依赖，从而避免发生错乱。</p></blockquote> <h2 id="避免无限递归循环"><a href="#避免无限递归循环" class="header-anchor">#</a> 避免无限递归循环</h2> <p>​	实现一个完善的响应系统要考虑诸多细节，而无限递归循环就是其中之一。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo<span class="token operator">++</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>可以看到，在 effect 注册的副作用函数内有一个自增操作 obj.foo++，该操作会引起栈溢出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> Uncaught RangeError<span class="token operator">:</span> Maximum call stack size exceeded
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <p>​	实际上，我们可以把 obj.foo++ 这个自增操作分开来看，它相当于：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 语句</span>
   obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo <span class="token operator">+</span> <span class="token number">1</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	在这个语句中，既会读取 obj.foo 的值，又会设置 obj.foo 的值，而这就是导致问题的根本原因。</p> <blockquote><ul><li>执行流程：首先读取 obj.foo 的值，这会触发 track 操作，将当前副作用函数收集到“桶”中，接着将其加 1 后再赋值给 obj.foo，此时会触发 trigger 操作，即把“桶”中的副作用函数取出并执行。</li> <li>但问题是<strong>该副作用函数正在执行中，还没有执行完毕，就要开始下一次的执行</strong>。这样会导致无限递归地调用自己，于是就产生了栈溢出。</li></ul></blockquote> <p>​	通过分析这个问题我们能够发现，读取和设置操作是<strong>在同一个副作用函数内</strong>进行的。此时无论是 track 时收集的副作用函数，还是 trigger 时要触发执行的副作用函数，<strong>都是</strong> activeEffect。</p> <p>​	基于此，我们可以在 trigger 动作发生时增加守卫条件：<strong>如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</strong>。如以下代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

   <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>effectFn <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 新增</span>
       effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
   effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>effectFn <span class="token operator">=&gt;</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token comment">// effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn())</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>​	这样我们就能够避免无限递归调用，从而避免栈溢出。</p> <h2 id="调度执行"><a href="#调度执行" class="header-anchor">#</a> 调度执行</h2> <p>​	可调度性是响应系统非常重要的特性。所谓<strong>可调度</strong>，指的是当 trigger 动作触发副作用函数重新执行时，<strong>有能力决定副作用函数执行的时机、次数以及方式</strong>。简单的来说，可调度性就是让用户可以根据需求来决定什么时候执行副作用函数。</p> <h3 id="执行顺序"><a href="#执行顺序" class="header-anchor">#</a> 执行顺序</h3> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>

 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'结束了'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>这段代码的输出结果如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token number">1</span>
 <span class="token number">2</span>
 <span class="token string">'结束了'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>现在假设需求有变，输出顺序需要调整为：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token number">1</span>
 <span class="token string">'结束了'</span>
 <span class="token number">2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>根据打印结果我们很容易想到对策，即把语句 obj.foo++ 和语句console.log('结束了') <strong>位置互换即可</strong>。</p></blockquote> <p>​	那么有没有什么办法能够<strong>在不调整代码的情况下实现需求</strong>呢？这时就<strong>需要响应系统支持调度</strong>。</p> <p>​	我们可以为 effect 函数设计一个选项参数 options，允许用户指定调度器：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// options</span>
   <span class="token punctuation">{</span>
     <span class="token comment">// 调度器 scheduler 是一个函数</span>
     <span class="token function">scheduler</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// ...</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>用户在调用 effect 函数注册副作用函数时，可以传递第二个参数 options。它是一个对象，其中<strong>允许指定 scheduler 调度函数，同时在 effect 函数内部我们需要把 options 选项挂载到对应的副作用函数上</strong>。</p></blockquote> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span>
     activeEffect <span class="token operator">=</span> effectFn
     <span class="token comment">// 在调用副作用函数之前将当前副作用函数压栈</span>
     effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把 activeEffect 还原为之前的值</span>
     effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 将 options 挂载到 effectFn 上</span>
   effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options  <span class="token comment">// 新增</span>
   <span class="token comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span>
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 执行副作用函数</span>
   <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>​	有了调度函数，我们在 trigger 函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，从而把控制权交给用户：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> depsMap <span class="token operator">=</span> bucket<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token keyword">const</span> effects <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

   <span class="token keyword">const</span> effectsToRun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   effects <span class="token operator">&amp;&amp;</span> effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>effectFn <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn <span class="token operator">!==</span> activeEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       effectsToRun<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
   effectsToRun<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>effectFn <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 新增</span>
       effectFn<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 否则直接执行副作用函数（之前的默认行为）</span>
       <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>在 trigger 动作触发副作用函数执行时，我们<strong>优先判断该副作用函数是否存在调度器，如果有，则将副作用函数作为调度器的参数，并执行调度器函数</strong>，由用户自己控制如何执行；否则保留之前的行为，即直接执行副作用函数。</p></blockquote> <p>有了这些基础设施之后，我们就可以实现前文的需求了，如以下代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// options</span>
   <span class="token punctuation">{</span>
     <span class="token comment">// 调度器 scheduler 是一个函数</span>
     <span class="token function">scheduler</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 将副作用函数放到宏任务队列中执行</span>
       <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>


 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>

 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'结束了'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>我们使用 setTimeout 开启一个宏任务来执行副作用函数 fn，这样就能实现期望的打印顺序了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token number">1</span>
 <span class="token string">'结束了'</span>
 <span class="token number">2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></blockquote> <h3 id="执行次数"><a href="#执行次数" class="header-anchor">#</a> 执行次数</h3> <p>除了控制副作用函数的执行顺序，通过调度器还可以做到控制它的执行次数，这一点也尤为重要。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>在没有指定调度器的情况下，这段代码的输出如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token number">1</span>
 <span class="token number">2</span>
 <span class="token number">3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>字段 obj.foo 的值一定会从 1 自增到 3，2 只是它的过渡状态。如果我们只关心最终结果而不关心过程，那么执行三次打印操作是多余的，我们期望的打印结果是不包含过渡状态的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token number">1</span>
 <span class="token number">3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <p>基于调度器我们可以很容易地实现此功能：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 定义一个任务队列</span>
 <span class="token keyword">const</span> jobQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 目的是利用 Set 数据结构的自动去重能力</span>
 <span class="token comment">// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列</span>
 <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

 <span class="token comment">// 一个标志代表是否正在刷新队列</span>
 <span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// 判断是否需要执行，只有当其为 false 时才需要执行</span>
 <span class="token keyword">function</span> <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果队列正在刷新，则什么都不做</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushing<span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token comment">// 设置为 true，代表正在刷新</span>
   isFlushing <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 无论调用多少次 flushJob 函数，在一个周期内都只会执行一次</span>
   <span class="token comment">// 在微任务队列中刷新 jobQueue 队列</span>
   p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 通过p.then将一个函数添加到微任务队列，在微任务队列内完成对jobQueue的遍历执行</span>
     jobQueue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>job <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 结束后重置 isFlushing</span>
     isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>


 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token function">scheduler</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 每次调度时，将副作用函数添加到 jobQueue 队列中</span>
     jobQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
     <span class="token comment">// 调用 flushJob 刷新队列</span>
     <span class="token function">flushJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><blockquote><p>连续对 obj.foo 执行两次自增操作，会同步且连续地执行两次 scheduler 调度函数，这意味着同一个副作用函数会被jobQueue.add(fn) 语句添加两次，但<strong>由于 Set 数据结构的去重能力</strong>，最终 jobQueue 中只会有一项，即当前副作用函数。</p> <p>类似地，flushJob 也会同步且连续地执行两次，但<strong>由于 isFlushing 标志的存在</strong>，实际上 flushJob 函数在一个事件循环内只会执行一次，即在微任务队列内执行一次。</p> <p>当微任务队列开始执行时，就会<strong>遍历 jobQueue 并执行里面存储的副作用函数</strong>。由于此时 jobQueue 队列内只有一个副作用函数，所以只会执行一次，并且当它执行时，字段 obj.foo 的值已经是 3 了，这样我们就实现了期望的输出：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token number">1</span>
 <span class="token number">3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></blockquote> <p>​	<strong>通过 isFlushing 标志和 Set 数据结构去重和微任务队列的结合，解决了频繁更新响应式变量而频繁触发 effect 回调的问题，使多次修改响应式变量，只会触发最终的 effect 回调，从而提升性能。</strong></p> <p>​	这个功能有点类似于在 Vue.js 中连续多次修改响应式数据但只会触发一次更新，实际上 Vue.js 内部实现了一个更加完善的调度器，思路与上文介绍的相同。</p> <h2 id="计算属性-computed-与-lazy"><a href="#计算属性-computed-与-lazy" class="header-anchor">#</a> 计算属性 computed 与 lazy</h2> <h3 id="lazy-的-effect"><a href="#lazy-的-effect" class="header-anchor">#</a> lazy 的 effect</h3> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span>
   <span class="token comment">// 这个函数会立即执行</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	<strong>但在有些场景下，我们并不希望它立即执行，而是希望它在需要的时候才执行</strong>，例如计算属性。这时我们可以通过在 options 中添加 lazy 属性来达到目的：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span>
   <span class="token comment">// 指定了 lazy 选项，这个函数不会立即执行</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token comment">// options</span>
   <span class="token punctuation">{</span>
     lazy<span class="token operator">:</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>​	有了它，我们就可以修改 effect 函数的实现逻辑了，<strong>当 options.lazy 为true 时，则不立即执行副作用函数</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     activeEffect <span class="token operator">=</span> effectFn
     effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
   <span class="token punctuation">}</span>
   effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token comment">// 只有非 lazy 的时候，才执行</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 新增</span>
     <span class="token comment">// 执行副作用函数</span>
     <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 将副作用函数作为返回值返回</span>
   <span class="token keyword">return</span> effectFn  <span class="token comment">// 新增</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>​	我们将副作用函数 effectFn 作为 effect 函数的返回值，这就意味着当调用effect 函数时，通过其返回值能够拿到对应的副作用函数，这样我们就能手动执行该副作用函数了（实现 lazy 的 effect）：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> lazy<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token comment">// 手动执行副作用函数</span>
 <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	如果仅仅能够手动执行副作用函数，其意义并不大。但如果我们把传递给effect 的函数看作一个 getter，那么这个 getter 函数可以返回任何值，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
<span class="token comment">// getter 返回 obj.foo 与 obj.bar 的和</span>
<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo <span class="token operator">+</span> obj<span class="token punctuation">.</span>bar<span class="token punctuation">,</span>
<span class="token punctuation">{</span> lazy<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token comment">// 这样，当我们手动执行副作用函数时，就能拿到obj.foo+obj.bar的结果</span>
<span class="token comment">// value 是 getter 的返回值</span>
<span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	为了实现这个目标，我们需要再对 effect 函数做一些修改：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">const</span> <span class="token function-variable function">effectFn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token function">cleanup</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     activeEffect <span class="token operator">=</span> effectFn
     effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effectFn<span class="token punctuation">)</span>
     <span class="token comment">// 将 fn 的执行结果存储到 res 中</span>
     <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 新增</span>
     effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
     <span class="token comment">// 将 res 作为 effectFn 的返回值</span>
     <span class="token keyword">return</span> res  <span class="token comment">// 新增</span>
   <span class="token punctuation">}</span>
   effectFn<span class="token punctuation">.</span>options <span class="token operator">=</span> options
   effectFn<span class="token punctuation">.</span>deps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> effectFn
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>传递给 effect 函数的参数 fn 才是真正的副作用函数，而 effectFn 是我们包装后的副作用函数。</p> <p>为了通过 effectFn 得到真正的副作用函数 fn 的执行结果，我们需要将其保存到 res 变量中，然后将其作为 effectFn 函数的返回值。</p></blockquote> <h3 id="计算属性-懒计算"><a href="#计算属性-懒计算" class="header-anchor">#</a> 计算属性 - 懒计算</h3> <p>​	现在我们已经能够实现懒执行的副作用函数，并且能够拿到副作用函数的执行结果了，接下来就可以实现计算属性了：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span>getter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span>
   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     lazy<span class="token operator">:</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token comment">// 当读取 value 时才执行 effectFn</span>
     <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> obj
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>只有当读取 value 的值时，才会执行 effectFn 并将其结果作为返回值返回。</p></blockquote> <p>​	我们可以使用 computed 函数来创建一个计算属性：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token keyword">const</span> sumRes <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo <span class="token operator">+</span> obj<span class="token punctuation">.</span>bar<span class="token punctuation">)</span>

 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sumRes<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	可以看到它能够正确地工作，不过现在我们实现的计算属性只做到了懒计算，但是还做不到对值进行缓存，我们多次访问就会导致 effectFn 多次计算，即使访问的值本身并无变化。</p> <h3 id="计算属性-缓存"><a href="#计算属性-缓存" class="header-anchor">#</a> 计算属性 - 缓存</h3> <p>​	为了解决这个问题，就需要我们在实现 computed 函数时，添加对值进行缓存的功能：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span>getter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// value 用来缓存上一次计算的值</span>
   <span class="token keyword">let</span> value
   <span class="token comment">// dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算</span>
   <span class="token keyword">let</span> dirty <span class="token operator">=</span> <span class="token boolean">true</span>

   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     lazy<span class="token operator">:</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 只有“脏”时才计算值，并将得到的值缓存到 value 中</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token comment">// 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值</span>
         dirty <span class="token operator">=</span> <span class="token boolean">false</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> value
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> obj
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p><strong>只有当 dirty 为 true 时才会调用 effectFn 重新计算值</strong>，否则直接使用上一次缓存在 value 中的值。</p></blockquote> <p>​	这样子虽然解决了缓存问题，但是如果此时我们修改 obj.foo 或 obj.bar 的值，再访问 sumRes.value，会发现访问到的值没有发生变化：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token keyword">const</span> sumRes <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo <span class="token operator">+</span> obj<span class="token punctuation">.</span>bar<span class="token punctuation">)</span>

 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sumRes<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment">// 3</span>
 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sumRes<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment">// 3</span>

 <span class="token comment">// 修改 obj.foo</span>
 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>

 <span class="token comment">// 再次访问，得到的仍然是 3，但预期结果应该是 4</span>
 <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sumRes<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>​	这是因为，当第一次访问 sumRes.value 的值后，变量 dirty 会设置为false，代表不需要计算。即使我们修改了 obj.foo 的值，但只要 dirty 的值为 false，就不会重新计算，所以导致我们得到了错误的值。</p></blockquote> <p>​	解决办法很简单，当 obj.foo 或 obj.bar 的值发生变化时，只要 dirty 的值重置为 true 就可以了。（利用调度器，在依赖的响应式数据发生变化而触发 <code>trigger()</code> 函数执行时，把 dirty 的值改成 true 就行）</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span>getter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> value
   <span class="token keyword">let</span> dirty <span class="token operator">=</span> <span class="token boolean">true</span>

   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
     <span class="token comment">// 添加调度器，在调度器中将 dirty 重置为 true</span>
     <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       dirty <span class="token operator">=</span> <span class="token boolean">true</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         dirty <span class="token operator">=</span> <span class="token boolean">false</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> value
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> obj
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote><p>当响应式数据发生变化时，会触发 trigger()，执行副作用函数的调度器 scheduler 方法，将 dirty 重置为 true，当再次访问 value 时，重新调用副作用函数 effectFn 计算值，得到最新的结果，这样就能够得到预期的结果了。</p></blockquote> <p>​	当我们在另外一个 effect 中读取计算属性的值时，会发现一个缺陷：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> sumRes <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo <span class="token operator">+</span> obj<span class="token punctuation">.</span>bar<span class="token punctuation">)</span>

 <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 在该副作用函数中读取 sumRes.value</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sumRes<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token comment">// 修改 obj.foo 的值</span>
 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>修改 obj.foo 的值并不会触发副作用函数的渲染。</p></blockquote> <p>​	这就是一个典型的 effect 嵌套。一个计算属性内部拥有自己的 effect，并且它是懒执行的，<strong>只有当真正读取计算属性的值时才会执行</strong>。对于计算属性的 getter 函数来说，它里面访问的响应式数据只会把 computed 内部的 effect 收集为依赖。而<strong>当把计算属性用于另外一个 effect 时，就会发生 effect 嵌套，外层的 effect 不会被内层 effect 中的响应式数据收集。</strong></p> <blockquote><p>外层的是普通的 effect，内层的是 computed 的 effect，computed 的 effect 是没有收集依赖的，所以要主动添加响应性的依赖收集。</p></blockquote> <p>​	解决办法很简单。当读取计算属性的值时，我们可以手动调用 track 函数进行追踪；当计算属性依赖的响应式数据发生变化时，会执行调度器函数，在调度器函数内，我们可以手动调用 trigger 函数触发响应：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span>getter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> value
   <span class="token keyword">let</span> dirty <span class="token operator">=</span> <span class="token boolean">true</span>

   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
     <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         dirty <span class="token operator">=</span> <span class="token boolean">true</span>
         <span class="token comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应</span>
         <span class="token function">trigger</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         value <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         dirty <span class="token operator">=</span> <span class="token boolean">false</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// 当读取 value 时，手动调用 track 函数进行追踪</span>
       <span class="token function">track</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span>
       <span class="token keyword">return</span> value
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> obj
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><blockquote><p>执行顺序：computed 函数依赖的值产生变动，dirty 被设为 true，triigger 通知之前 track 收集的依赖副作用函数执行，副作用函数内部会调用一次 computed 产生的 obj 的 value，从而进行一次副作用计算更新值，同时把 dirty 设为false，之后执行的依赖副作用读取的是缓存的值。</p></blockquote> <p>​	**计算属性依赖的值变化时，计算属性会触发内层 effect；而内层 effect 的改变也会触发外层 effect 的改变，这样就间接使得外层 effect 可以被内层 effect 的依赖收集到。**而这一实现通过的是手动追踪依赖实现的，即手动调用 track 和 trigger 函数。</p> <blockquote><p>这时，对于如下代码来说：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sumRes<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>它会建立这样的联系：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">computed</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
     └── value
         └── effectFn
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/vivien-blog/assets/img/image-20240822160042959.f89ac0bd.png" alt="建立这样的联系"></p></blockquote> <div class="custom-block tip"><p class="title">在 effect 中读取计算属性与前面章节中 effect 嵌套之间的区别?</p><p>1、前文中的 effect 嵌套在内外层的 effect 函数分别读取了与之关联的响应式数据，因此正确执行的关键是在读取操作中收集正确的activeEffect，因此我们需要通过引入effect 栈来实现 activeEffect 的及时更新。</p> <p>2、而在 effect 中读取计算属性的情况中只有计算属性中的 getter 触发了响应式数据的读取操作，因此计算属性的变更无法引起外层 effec t函数的重新执行，因此我们需要在计算属性的读取与变更行为中手动触发 track 与 trigger 操作，注意，由于 track 函数是在计算属性 effectFn 执行完毕后调用，因此，此时 activeEffect 的指向也是外层 effect，因此，这里的 trigger 可以准确将计算属性和外层的 effect 关联起来。</p></div><h2 id="watch-的实现原理"><a href="#watch-的实现原理" class="header-anchor">#</a> watch 的实现原理</h2> <div class="custom-block danger"><p class="title"></p><p>​	在一个副作用函数中访问响应式数据 ，这会在副作用函数与响应式数据之间建立联系，当响应式数据变化时，会触发副作用函数重新执行。</p> <p>​	如果副作用函数存在 scheduler 选项，当响应式数据发生变化时，会触发 scheduler 调度函数执行，而非直接触发副作用函数执行。</p> <p>​	其实 scheduler调度函数就相当于一个回调函数，而 watch 的实现就是利用了这个特点。</p></div><p>​	所谓 watch，其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函数。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'数据变了'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token comment">// 修改响应数据的值，会导致回调函数执行</span>
 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​	watch 的实现本质上就是利用了 effect 以及 options.scheduler 选项。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 当 obj.foo 的值变化时，会执行 scheduler 调度函数</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>​	我们可以如下所示使用 watch 函数:</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
 <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'数据变化了'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>​	可以看到它能够正确地工作，但是我们在 watch 函数的实现中，硬编码了对 obj.foo 的读取操作，换句话说，现在只能观测 obj.foo 的改变。</p> <p>​	为了让 watch 函数具有通用性，我们需要一个封装一个通用的读取操作：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">effect</span><span class="token punctuation">(</span>
     <span class="token comment">// 调用 traverse 递归地读取</span>
     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 当数据变化时，调用回调函数 cb</span>
         <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> seen<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
   <span class="token comment">// 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环</span>
   seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
   <span class="token comment">// 暂时不考虑数组等其他结构</span>
   <span class="token comment">// 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">traverse</span><span class="token punctuation">(</span>value<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> seen<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">return</span> value
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><blockquote><p>在 watch 内部的 effect 中调用 traverse 函数进行递归的读取操作，代替硬编码的方式，这样就能读取一个对象上的任意属性，从而当任意属性发生变化时都能够触发回调函数执行。</p></blockquote> <p>​	watch 函数除了可以观测响应式数据，还可以接收一个 getter 函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>
   <span class="token comment">// getter 函数</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">,</span>
   <span class="token comment">// 回调函数</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj.foo 的值变了'</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>在 getter 函数内部，用户可以指定该 watch 依赖哪些响应式数据，只有当这些数据变化时，才会触发回调函数执行。</p></blockquote> <p>​	我们需要对 watch 函数做一些修改来实现这一功能：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 定义 getter</span>
   <span class="token keyword">let</span> getter
   <span class="token comment">// 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋值给 getter</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     getter <span class="token operator">=</span> source
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
     <span class="token comment">// 否则按照原来的实现调用 traverse 递归地读取</span>
     <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token function">effect</span><span class="token punctuation">(</span>
     <span class="token comment">// 执行 getter</span>
     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><blockquote><p>有个大问题：在回调函数中拿不到旧值与新值。</p></blockquote> <p>​	通常我们在使用 Vue.js 中的 watch 函数时，能够在回调函数中得到变化前后的值：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>
   <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">,</span>
   <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>  <span class="token comment">// 2, 1</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">)</span>

 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-block tip"><p class="title"></p><p>lazy 属性为 true 代表使用 effect 的时候副作用回调不会立即执行，根据这个特性，实现了 watch 中的新I旧值获取问题和 computed 的特性。</p></div><p>​	  那么如何获得新值与旧值呢？最核心的改动是使用 lazy 选项创建了一个懒执行的 effect：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> getter
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     getter <span class="token operator">=</span> source
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 定义旧值与新值</span>
   <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue
   <span class="token comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到 effectFn 中以便后续手动调用</span>
   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
       <span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span>
         newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token comment">// 将旧值和新值作为回调函数的参数</span>
         <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
         <span class="token comment">// 更新旧值，不然下一次会得到错误的旧值</span>
         oldValue <span class="token operator">=</span> newValue
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
   <span class="token comment">// 手动调用副作用函数，拿到的值就是旧值</span>
   oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><blockquote><p>我们手动调用 effectFn 函数得到的返回值就是旧值，即第一次执行得到的值。</p> <p>当变化发生并触发 scheduler 调度函数执行时，会重新调用 effectFn 函数并得到新值，这样我们就拿到了旧值与新值，接着将它们作为参数传递给回调函数 cb 就可以了。</p> <p>最后，使用新值更新旧值：oldValue = newValue，否则在下一次变更发生时会得到错误的旧值。</p></blockquote> <h2 id="立即执行的-watch-与回调执行时机"><a href="#立即执行的-watch-与回调执行时机" class="header-anchor">#</a> 立即执行的 watch 与回调执行时机</h2> <p>​	<strong>watch 的本质其实是对 effect 的二次封装。</strong> watch的两个特性：一个是立即执行的回调函数，另一个是回调函数的执行时机。</p> <h3 id="立即执行的回调函数"><a href="#立即执行的回调函数" class="header-anchor">#</a> 立即执行的回调函数</h3> <p>​	默认情况下，一个 watch 的回调只会在响应式数据发生变化时才执行：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 回调函数只有在响应式数据 obj 后续发生变化时才执行</span>
 <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'变化了'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​	在 Vue.js 中可以通过选项参数 immediate 来指定回调是否需要立即执行：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'变化了'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token comment">// 回调函数会在 watch 创建时立即执行一次</span>
   immediate<span class="token operator">:</span> <span class="token boolean">true</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>​	回调函数的立即执行与后续执行本质上没有任何差别，所以我们可以把 scheduler 调度函数封装为一个通用函数，分别在初始化和变更时执行它：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> getter
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     getter <span class="token operator">=</span> source
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue

   <span class="token comment">// 提取 scheduler 调度函数为一个独立的 job 函数</span>
   <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
     oldValue <span class="token operator">=</span> newValue
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
     <span class="token comment">// 执行 getter</span>
     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
       <span class="token comment">// 使用 job 函数作为调度器函数</span>
       scheduler<span class="token operator">:</span> job
     <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 当 immediate 为 true 时立即执行 job，从而触发回调执行</span>
     <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><blockquote><p>由于回调函数是立即执行的，所以第一次回调执行时没有所谓的旧值，因此此时回调函数的 oldValue 值为 undefined，这也是符合预期的。</p></blockquote> <h3 id="回调函数的执行时机"><a href="#回调函数的执行时机" class="header-anchor">#</a> 回调函数的执行时机</h3> <p>​	除了指定回调函数为立即执行之外，还可以通过其他选项参数来指定回调函数的执行时机，例如在 Vue.js 3 中使用 flush 选项来指定：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'变化了'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
   <span class="token comment">// 回调函数会在 watch 创建时立即执行一次</span>
   flush<span class="token operator">:</span> <span class="token string">'pre'</span> <span class="token comment">// 还可以指定为 'post' | 'sync'</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>flush 本质上是在指定调度函数的执行时机。前文讲解过如何在微任务队列中执行调度函数 scheduler，这与 flush 的功能相同。</p></blockquote> <p>​	 flush 的值为'post' 时，代表调度函数需要将副作用函数放到一个微任务队列中，并等待 DOM 更新结束后再执行，我们可以用如下代码进行模拟：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> getter
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     getter <span class="token operator">=</span> source
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue

   <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
     oldValue <span class="token operator">=</span> newValue
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
     <span class="token comment">// 执行 getter</span>
     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
       <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token comment">// 在调度函数中判断 flush 是否为 'post'，如果是，将其放到微任务队列中执行</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">'post'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
           p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><blockquote><p>在调度器函数内检测 options.flush 的值是否为 post，如果是，则将 job 函数放到微任务队列中，从而实现异步延迟执行；否则直接执行 job 函数，这本质上相当于 'sync' 的实现机制，即同步执行。</p> <p>对于 options.flush 的值为'pre' 的情况，我们暂时还没有办法模拟，因为这涉及组件的更新时机。</p></blockquote> <h2 id="过期的副作用"><a href="#过期的副作用" class="header-anchor">#</a> 过期的副作用</h2> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">let</span> finalData

 <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 发送并等待网络请求</span>
   <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/path/to/request'</span><span class="token punctuation">)</span>
   <span class="token comment">// 将请求结果赋值给 data</span>
   finalData <span class="token operator">=</span> res
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>假设 fetch() 第一次请求（请求 A）需要 1000ms 才会返回请求结果，而第二次（请求 B）只需要 100ms 就能完成。那么会造成最终我们的 finalData 拿到的是第一次请求结果，和我们预期的不一样。</p></blockquote> <p><img src="/vivien-blog/assets/img/image-20240822165946590.99ae764a.png" alt="请求结果"></p> <blockquote><ul><li>请求 A 是副作用函数第一次执行所产生的副作用，请求 B 是副作用函数第二次执行所产生的副作用。</li> <li>如果请求 B 先于请求 A 返回结果，就会导致最终 finalData 中存储的是 A 请求的结果。</li> <li>但是我们希望变量 finalData 存储的值应该是由请求 B 返回的结果，而非请求 A 返回的结果。由于请求 B 后发生，所以请求 B 的结果应该被视为“最新”的，而请求 A已经“过期”了，其产生的结果应被视为无效。通过这种方式就可以避免竞态问题导致的错误结果。</li></ul></blockquote> <p>​	我们需要的是一个让副作用过期的手段。在 Vue.js 中，watch 函数的回调函数接收第三个参数 onInvalidate，它是一个函数，类似于事件监听器，我们可以使用 onInvalidate 函数注册一个回调，这个回调函数会在当前副作用函数过期时执行：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期</span>
   <span class="token keyword">let</span> expired <span class="token operator">=</span> <span class="token boolean">false</span>
   <span class="token comment">// 调用 onInvalidate() 函数注册一个过期回调</span>
   <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     <span class="token comment">// 当过期时，将 expired 设置为 true</span>
     expired <span class="token operator">=</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token comment">// 发送网络请求</span>
   <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/path/to/request'</span><span class="token punctuation">)</span>

   <span class="token comment">// 只有当该副作用函数的执行没有过期时，才会执行后续操作。</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     finalData <span class="token operator">=</span> res
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><ul><li>在发送请求之前，定义了 expired 标志变量，用来标识当前副作用函数的执行是否过期；接着调用 onInvalidate 函数注册了一个过期回调，当该副作用函数的执行过期时将 expired 标志变量设置为 true；只有当没有过期时，才采用请求结果，这样就可以有效地避免上述问题了。</li> <li>await 要等异步操作完成才会执行后面的语句，所以可以利用同步操作 B 改变 A 的 expired 变量，等恢复 await 后面的执行，A 场景的 expired 变量已经变成 true 了。</li></ul></blockquote> <p>​	那么 Vue.js 是怎么做到的呢？<strong>onInvalidate 的原理是什么呢</strong>？在 watch 内部每次检测到变更后，在副作用函数重新执行之前，会先调用我们通过 onInvalidate 函数注册的过期回调，仅此而已。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> cb<span class="token punctuation">,</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> getter
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> source <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     getter <span class="token operator">=</span> source
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token function-variable function">getter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">let</span> oldValue<span class="token punctuation">,</span> newValue

   <span class="token comment">// cleanup 用来存储用户注册的过期回调</span>
   <span class="token keyword">let</span> cleanup
   <span class="token comment">// 定义 onInvalidate 函数</span>
   <span class="token keyword">function</span> <span class="token function">onInvalidate</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 将过期回调存储到 cleanup 中</span>
     cleanup <span class="token operator">=</span> fn
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> <span class="token function-variable function">job</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     newValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token comment">// 在调用回调函数 cb 之前，先调用过期回调</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>cleanup<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 将 onInvalidate 作为回调函数的第三个参数传递给 cb，以便用户使用</span>
     <span class="token function">cb</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span>
     oldValue <span class="token operator">=</span> newValue
   <span class="token punctuation">}</span>

   <span class="token keyword">const</span> effectFn <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
     <span class="token comment">// 执行 getter</span>
     <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
       lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
       <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>flush <span class="token operator">===</span> <span class="token string">'post'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
           p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     oldValue <span class="token operator">=</span> <span class="token function">effectFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>很巧妙，通过栈+回调 +闭包，追踪当前函数调用栈是否结束。我们还是通过一个例子来进一步说明：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token function">watch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">,</span> onInvalidate<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> expired <span class="token operator">=</span> <span class="token boolean">false</span>
   <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     expired <span class="token operator">=</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/path/to/request'</span><span class="token punctuation">)</span> <span class="token comment">// 假设请求 A需要 1000ms 才能返回结果</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>expired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     finalData <span class="token operator">=</span> res
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>

 <span class="token comment">// 第一次修改是立即执行的，这会导致 watch 的回调函数执行。</span>
 obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 200ms 后做第二次修改，这又会导致 watch 的回调函数执行。</span>
   obj<span class="token punctuation">.</span>foo<span class="token operator">++</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>**每次 foo 发生变化，都会触发 watch 的回调，但是每次触发新一次的回调函数，都会调用上一次中 onlnvalidate 的回调函数，从而影响了上一次的结果。**只有回调函数最后一次执行的时候，expired 才不会被设置为 true，因为设置 expired 的条件是当前回调后面还有回调，只有在第二次回调执行的时候，第一次注册的过期回调才会执行。</p> <p>每次执行回调函数之前要先检查过期回调是否存在，如果存在，会优先执行过期回调。由于在 watch 的回调函数第一次执行时，我们已经注册了一个过期回调，所以在 watch 的回调函数第二次执行之前，会优先执行之前注册的过期回调，这会使得第一次执行的副作用函数内闭包的变量 expired 的值变为 true，即副作用函数的执行过期了。于是等请求 A的结果返回时，其结果会被抛弃，从而避免了过期的副作用函数带来的影响。</p></blockquote> <p><img src="/vivien-blog/assets/img/image-20240822172105578.25750b86.png" alt="避免"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>一个响应式数据最基本的实现依赖于对“读取”和“设置”操作的拦截，从而在副作用函数与响应式数据之间建立联系。当“读取”操作发生时，我们将当前执行的副作用函数存储到“桶”中；当“设置”操作发生时，再将副作用函数从“桶”里取出并执行。这就是响应系统的根本实现原理。</li> <li>使用 WeakMap 配合 Map 构建了新的“桶”结构，从而能够在响应式数据与副作用函数之间建立更加精确的联系。</li> <li>分支切换会导致冗余副作用的问题，这个问题会导致副作用函数进行不必要的更新。为了解决这个问题，我们需要在每次副作用函数重新执行之前，清除上一次建立的响应联系，而当副作用函数重新执行后，会再次建立新的响应联系，新的响应联系中不存在冗余副作用问题。</li> <li>遍历 Set 数据结构导致无限循环的新问题，该问题产生的原因可以从 ECMA 规范中得知，即“在调用 forEach 遍历 Set 集合时，如果一个值已经被访问过了，但这个值被删除并重新添加到集合，如果此时 forEach 遍历没有结束，那么这个值会重新被访问。”解决方案是建立一个新的 Set 数据结构用来遍历。</li> <li>在实际场景中，嵌套的副作用函数发生在组件嵌套的场景中，即父子组件关系。这时为了避免在响应式数据与副作用函数之间建立的响应联系发生错乱，我们需要使用副作用函数栈来存储不同的副作用函数。当一个副作用函数执行完毕后，将其从栈中弹出，当读取响应式数据的时候，被读取的响应式数据只会与当前栈顶的副作用函数建立响应联系</li> <li>副作用函数无限递归地调用自身，导致栈溢出的问题。该问题的根本原因在于，对响应式数据的读取和设置操作发生在同一个副作用函数内。解决办法很简单，如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行。</li> <li>所谓可调度，指的是当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式。为了实现调度能力，我们为 effect 函数增加了第二个选项参数，可以通过 scheduler 选项指定调用器，这样用户可以通过调度器自行完成任务的调度。可以通过调度器实现任务去重，即通过一个微任务队列对任务进行缓存，从而实现去重。</li> <li>计算属性实际上是一个懒执行的副作用函数，我们通过 lazy 选项使得副作用函数可以懒执行。被标记为懒执行的副作用函数可以通过手动方式让其执行。利用这个特点，我们设计了计算属性，当读取计算属性的值时，只需要手动执行副作用函数即可。当计算属性依赖的响应式数据发生变化时，会通过 scheduler 将dirty 标记设置为 true，代表“脏”。这样，下次读取计算属性的值时，我们会重新计算真正的值。</li> <li>watch 的实现原理：它本质上利用了副作用函数重新执行时的可调度性。一个 watch 本身会创建一个 effect，当这个 effect 依赖的响应式数据发生变化时，会执行该 effect 的调度器函数，即scheduler。这里的 scheduler 可以理解为“回调”，所以我们只需要在scheduler 中执行用户通过 watch 函数注册的回调函数即可。立即执行回调的 watch 通过添加新的 immediate 选项来实现，通过 flush 选项来指定回调函数具体的执行时机，本质上是利用了调用器和异步的微任务队列。</li> <li>过期的副作用函数，它会导致竞态问题。为了解决这个问题，Vue.js 为 watch 的回调函数设计了第三个参数，即 onInvalidate。它是一个函数，用来注册过期回调。每当 watch 的回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过期”，从而解决竞态问题。</li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/10 02:14:23</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="prev">
          3.Vue.js3的设计思路
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html">
          5.非原始值的响应式方案
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#响应式数据与副作用函数" class="sidebar-link reco-side-响应式数据与副作用函数" data-v-9f22dc18>响应式数据与副作用函数</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#响应式数据的基本实现" class="sidebar-link reco-side-响应式数据的基本实现" data-v-9f22dc18>响应式数据的基本实现</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#用-set-作为桶的数据结构" class="sidebar-link reco-side-用-set-作为桶的数据结构" data-v-9f22dc18>用 Set 作为桶的数据结构</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#设计一个完善的响应系统" class="sidebar-link reco-side-设计一个完善的响应系统" data-v-9f22dc18>设计一个完善的响应系统</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#用-weakmap-作为桶的数据结构" class="sidebar-link reco-side-用-weakmap-作为桶的数据结构" data-v-9f22dc18>用 WeakMap 作为桶的数据结构</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#分支切换与-cleanup" class="sidebar-link reco-side-分支切换与-cleanup" data-v-9f22dc18>分支切换与 cleanup</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#分支切换" class="sidebar-link reco-side-分支切换" data-v-9f22dc18>分支切换</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#cleanup" class="sidebar-link reco-side-cleanup" data-v-9f22dc18>cleanup</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#嵌套的-effect-与-effect-栈" class="sidebar-link reco-side-嵌套的-effect-与-effect-栈" data-v-9f22dc18>嵌套的 effect 与 effect 栈</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#为什么-effect-要设计成可嵌套的" class="sidebar-link reco-side-为什么-effect-要设计成可嵌套的" data-v-9f22dc18>为什么 effect 要设计成可嵌套的</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#如果-effect-不支持嵌套会发生什么" class="sidebar-link reco-side-如果-effect-不支持嵌套会发生什么" data-v-9f22dc18>如果 effect 不支持嵌套会发生什么</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#函数栈-effectstack" class="sidebar-link reco-side-函数栈-effectstack" data-v-9f22dc18>函数栈 effectStack</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#避免无限递归循环" class="sidebar-link reco-side-避免无限递归循环" data-v-9f22dc18>避免无限递归循环</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#调度执行" class="sidebar-link reco-side-调度执行" data-v-9f22dc18>调度执行</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#执行顺序" class="sidebar-link reco-side-执行顺序" data-v-9f22dc18>执行顺序</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#执行次数" class="sidebar-link reco-side-执行次数" data-v-9f22dc18>执行次数</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#计算属性-computed-与-lazy" class="sidebar-link reco-side-计算属性-computed-与-lazy" data-v-9f22dc18>计算属性 computed 与 lazy</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#lazy-的-effect" class="sidebar-link reco-side-lazy-的-effect" data-v-9f22dc18>lazy 的 effect</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#计算属性-懒计算" class="sidebar-link reco-side-计算属性-懒计算" data-v-9f22dc18>计算属性 - 懒计算</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#计算属性-缓存" class="sidebar-link reco-side-计算属性-缓存" data-v-9f22dc18>计算属性 - 缓存</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#watch-的实现原理" class="sidebar-link reco-side-watch-的实现原理" data-v-9f22dc18>watch 的实现原理</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#立即执行的-watch-与回调执行时机" class="sidebar-link reco-side-立即执行的-watch-与回调执行时机" data-v-9f22dc18>立即执行的 watch 与回调执行时机</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#立即执行的回调函数" class="sidebar-link reco-side-立即执行的回调函数" data-v-9f22dc18>立即执行的回调函数</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#回调函数的执行时机" class="sidebar-link reco-side-回调函数的执行时机" data-v-9f22dc18>回调函数的执行时机</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#过期的副作用" class="sidebar-link reco-side-过期的副作用" data-v-9f22dc18>过期的副作用</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/4.%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.7738f530.js" defer></script><script src="/vivien-blog/assets/js/7.464cc3ea.js" defer></script><script src="/vivien-blog/assets/js/2.db1c35d8.js" defer></script><script src="/vivien-blog/assets/js/1.88465532.js" defer></script><script src="/vivien-blog/assets/js/27.383ae212.js" defer></script>
  </body>
</html>
