<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>9.简单的Diff算法 | Vivien&#39;s Notebook</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vivien-blog/logo.jpg">
    <meta name="description" content="Vivien个人博客">
    
    <link rel="preload" href="/vivien-blog/assets/css/0.styles.4edee94f.css" as="style"><link rel="preload" href="/vivien-blog/assets/js/app.1b7b4fd5.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/7.210383a7.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/2.00d63d32.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/1.96251043.js" as="script"><link rel="preload" href="/vivien-blog/assets/js/21.06b93e75.js" as="script"><link rel="prefetch" href="/vivien-blog/assets/js/10.fa80c4ef.js"><link rel="prefetch" href="/vivien-blog/assets/js/100.057c90a7.js"><link rel="prefetch" href="/vivien-blog/assets/js/101.19c4abac.js"><link rel="prefetch" href="/vivien-blog/assets/js/102.8bc66b45.js"><link rel="prefetch" href="/vivien-blog/assets/js/103.a3435343.js"><link rel="prefetch" href="/vivien-blog/assets/js/104.0068d84a.js"><link rel="prefetch" href="/vivien-blog/assets/js/105.04fc30e6.js"><link rel="prefetch" href="/vivien-blog/assets/js/106.9ff39244.js"><link rel="prefetch" href="/vivien-blog/assets/js/107.3b79619c.js"><link rel="prefetch" href="/vivien-blog/assets/js/108.d5bf9027.js"><link rel="prefetch" href="/vivien-blog/assets/js/109.698ce34c.js"><link rel="prefetch" href="/vivien-blog/assets/js/11.45f08108.js"><link rel="prefetch" href="/vivien-blog/assets/js/110.3681f055.js"><link rel="prefetch" href="/vivien-blog/assets/js/111.387f6115.js"><link rel="prefetch" href="/vivien-blog/assets/js/112.4d7580b7.js"><link rel="prefetch" href="/vivien-blog/assets/js/113.c3fe5fe0.js"><link rel="prefetch" href="/vivien-blog/assets/js/114.f0df6d73.js"><link rel="prefetch" href="/vivien-blog/assets/js/115.2388eeb0.js"><link rel="prefetch" href="/vivien-blog/assets/js/116.94a902d0.js"><link rel="prefetch" href="/vivien-blog/assets/js/117.35c6f7e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/118.f7ecaac7.js"><link rel="prefetch" href="/vivien-blog/assets/js/119.53eceb0f.js"><link rel="prefetch" href="/vivien-blog/assets/js/120.1bbfbebb.js"><link rel="prefetch" href="/vivien-blog/assets/js/121.b66bb0a4.js"><link rel="prefetch" href="/vivien-blog/assets/js/122.1a72171a.js"><link rel="prefetch" href="/vivien-blog/assets/js/123.49317ff6.js"><link rel="prefetch" href="/vivien-blog/assets/js/124.1919ad13.js"><link rel="prefetch" href="/vivien-blog/assets/js/125.46542121.js"><link rel="prefetch" href="/vivien-blog/assets/js/126.d20b2438.js"><link rel="prefetch" href="/vivien-blog/assets/js/127.096c8422.js"><link rel="prefetch" href="/vivien-blog/assets/js/128.6f10ade2.js"><link rel="prefetch" href="/vivien-blog/assets/js/129.be3e0f7e.js"><link rel="prefetch" href="/vivien-blog/assets/js/130.92794b90.js"><link rel="prefetch" href="/vivien-blog/assets/js/131.93cec235.js"><link rel="prefetch" href="/vivien-blog/assets/js/14.41118c66.js"><link rel="prefetch" href="/vivien-blog/assets/js/15.3131a535.js"><link rel="prefetch" href="/vivien-blog/assets/js/16.0fcf1058.js"><link rel="prefetch" href="/vivien-blog/assets/js/17.c4515dab.js"><link rel="prefetch" href="/vivien-blog/assets/js/18.2fe122be.js"><link rel="prefetch" href="/vivien-blog/assets/js/19.341cf97a.js"><link rel="prefetch" href="/vivien-blog/assets/js/20.c523984f.js"><link rel="prefetch" href="/vivien-blog/assets/js/22.9f594ab7.js"><link rel="prefetch" href="/vivien-blog/assets/js/23.409fd3e4.js"><link rel="prefetch" href="/vivien-blog/assets/js/24.5a3a4049.js"><link rel="prefetch" href="/vivien-blog/assets/js/25.21fac10f.js"><link rel="prefetch" href="/vivien-blog/assets/js/26.c590614b.js"><link rel="prefetch" href="/vivien-blog/assets/js/27.b8c03943.js"><link rel="prefetch" href="/vivien-blog/assets/js/28.2c65a62c.js"><link rel="prefetch" href="/vivien-blog/assets/js/29.15a38861.js"><link rel="prefetch" href="/vivien-blog/assets/js/3.934f6b75.js"><link rel="prefetch" href="/vivien-blog/assets/js/30.8704b94b.js"><link rel="prefetch" href="/vivien-blog/assets/js/31.e6e61ee0.js"><link rel="prefetch" href="/vivien-blog/assets/js/32.c193bc49.js"><link rel="prefetch" href="/vivien-blog/assets/js/33.03974196.js"><link rel="prefetch" href="/vivien-blog/assets/js/34.7e51c94f.js"><link rel="prefetch" href="/vivien-blog/assets/js/35.1da6c0eb.js"><link rel="prefetch" href="/vivien-blog/assets/js/36.44155ea4.js"><link rel="prefetch" href="/vivien-blog/assets/js/37.c892cb88.js"><link rel="prefetch" href="/vivien-blog/assets/js/38.20dcb46a.js"><link rel="prefetch" href="/vivien-blog/assets/js/39.ab72969e.js"><link rel="prefetch" href="/vivien-blog/assets/js/4.35261d9d.js"><link rel="prefetch" href="/vivien-blog/assets/js/40.d1f877b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/41.58cf6028.js"><link rel="prefetch" href="/vivien-blog/assets/js/42.1056cd44.js"><link rel="prefetch" href="/vivien-blog/assets/js/43.d32266a5.js"><link rel="prefetch" href="/vivien-blog/assets/js/44.652b8114.js"><link rel="prefetch" href="/vivien-blog/assets/js/45.1deb9d35.js"><link rel="prefetch" href="/vivien-blog/assets/js/46.1b0a642d.js"><link rel="prefetch" href="/vivien-blog/assets/js/47.f74917b1.js"><link rel="prefetch" href="/vivien-blog/assets/js/48.b394b7e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/49.b1d92ead.js"><link rel="prefetch" href="/vivien-blog/assets/js/5.fa969ab7.js"><link rel="prefetch" href="/vivien-blog/assets/js/50.3676a039.js"><link rel="prefetch" href="/vivien-blog/assets/js/51.8625a796.js"><link rel="prefetch" href="/vivien-blog/assets/js/52.85e6ae67.js"><link rel="prefetch" href="/vivien-blog/assets/js/53.cf3b4106.js"><link rel="prefetch" href="/vivien-blog/assets/js/54.195eccac.js"><link rel="prefetch" href="/vivien-blog/assets/js/55.a23fa0b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/56.cc54345c.js"><link rel="prefetch" href="/vivien-blog/assets/js/57.3074601a.js"><link rel="prefetch" href="/vivien-blog/assets/js/58.5861d737.js"><link rel="prefetch" href="/vivien-blog/assets/js/59.89926beb.js"><link rel="prefetch" href="/vivien-blog/assets/js/6.28daaf49.js"><link rel="prefetch" href="/vivien-blog/assets/js/60.7333cd13.js"><link rel="prefetch" href="/vivien-blog/assets/js/61.c0ec386a.js"><link rel="prefetch" href="/vivien-blog/assets/js/62.47dd6986.js"><link rel="prefetch" href="/vivien-blog/assets/js/63.7a8aca22.js"><link rel="prefetch" href="/vivien-blog/assets/js/64.45edd43b.js"><link rel="prefetch" href="/vivien-blog/assets/js/65.7b6e7073.js"><link rel="prefetch" href="/vivien-blog/assets/js/66.f8cbb551.js"><link rel="prefetch" href="/vivien-blog/assets/js/67.6cc4496a.js"><link rel="prefetch" href="/vivien-blog/assets/js/68.91f8578c.js"><link rel="prefetch" href="/vivien-blog/assets/js/69.2a8f1cef.js"><link rel="prefetch" href="/vivien-blog/assets/js/70.7a4f08f0.js"><link rel="prefetch" href="/vivien-blog/assets/js/71.072edcd7.js"><link rel="prefetch" href="/vivien-blog/assets/js/72.11e37d34.js"><link rel="prefetch" href="/vivien-blog/assets/js/73.b2ed6145.js"><link rel="prefetch" href="/vivien-blog/assets/js/74.b0ffe6f1.js"><link rel="prefetch" href="/vivien-blog/assets/js/75.37f798b5.js"><link rel="prefetch" href="/vivien-blog/assets/js/76.4a2f8418.js"><link rel="prefetch" href="/vivien-blog/assets/js/77.26d75a07.js"><link rel="prefetch" href="/vivien-blog/assets/js/78.de800dca.js"><link rel="prefetch" href="/vivien-blog/assets/js/79.6ac0d041.js"><link rel="prefetch" href="/vivien-blog/assets/js/8.cbde96fb.js"><link rel="prefetch" href="/vivien-blog/assets/js/80.96d5beb2.js"><link rel="prefetch" href="/vivien-blog/assets/js/81.4d9e115c.js"><link rel="prefetch" href="/vivien-blog/assets/js/82.948fa90e.js"><link rel="prefetch" href="/vivien-blog/assets/js/83.246d9e36.js"><link rel="prefetch" href="/vivien-blog/assets/js/84.79d82321.js"><link rel="prefetch" href="/vivien-blog/assets/js/85.d881655a.js"><link rel="prefetch" href="/vivien-blog/assets/js/86.0d3c4c1c.js"><link rel="prefetch" href="/vivien-blog/assets/js/87.241b57a2.js"><link rel="prefetch" href="/vivien-blog/assets/js/88.4cb09072.js"><link rel="prefetch" href="/vivien-blog/assets/js/89.6b6a6d21.js"><link rel="prefetch" href="/vivien-blog/assets/js/9.09f385e1.js"><link rel="prefetch" href="/vivien-blog/assets/js/90.684c40fa.js"><link rel="prefetch" href="/vivien-blog/assets/js/91.3abfbc85.js"><link rel="prefetch" href="/vivien-blog/assets/js/92.8e112cc6.js"><link rel="prefetch" href="/vivien-blog/assets/js/93.ccd72f8f.js"><link rel="prefetch" href="/vivien-blog/assets/js/94.50ca9f79.js"><link rel="prefetch" href="/vivien-blog/assets/js/95.bfe29f10.js"><link rel="prefetch" href="/vivien-blog/assets/js/96.a5f404ee.js"><link rel="prefetch" href="/vivien-blog/assets/js/97.c86f128e.js"><link rel="prefetch" href="/vivien-blog/assets/js/98.59512bfd.js"><link rel="prefetch" href="/vivien-blog/assets/js/99.cf1ceb98.js"><link rel="prefetch" href="/vivien-blog/assets/js/vendors~docsearch.36c01082.js">
    <link rel="stylesheet" href="/vivien-blog/assets/css/0.styles.4edee94f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-222e0b9d><div data-v-222e0b9d><div class="password-shadow password-wrapper-out" style="display:none;" data-v-15719524 data-v-222e0b9d data-v-222e0b9d><h3 class="title" data-v-15719524>Vivien's Notebook</h3> <p class="description" data-v-15719524>Vivien个人博客</p> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div class="hide" data-v-222e0b9d><header class="navbar" data-v-222e0b9d><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vivien-blog/" class="home-link router-link-active"><img src="/vivien-blog/logo.jpg" alt="Vivien's Notebook" class="logo"> <span class="site-name">Vivien's Notebook</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-222e0b9d></div> <aside class="sidebar" data-v-222e0b9d><div class="personal-info-wrapper" data-v-2710484f data-v-222e0b9d><img src="/vivien-blog/avator.jpg" alt="author-avatar" class="personal-img" data-v-2710484f> <!----> <div class="num" data-v-2710484f><div data-v-2710484f><h3 data-v-2710484f>92</h3> <h6 data-v-2710484f>文章</h6></div> <div data-v-2710484f><h3 data-v-2710484f>11</h3> <h6 data-v-2710484f>标签</h6></div></div> <ul class="social-links" data-v-2710484f><li class="social-item" data-v-2710484f><i class="iconfont reco-github" style="color:#f47e60;" data-v-2710484f></i></li></ul> <hr data-v-2710484f></div> <nav class="nav-links"><div class="nav-item"><a href="/vivien-blog/base/browser/输入URL到页面展示发生了什么/" class="nav-link"><i class="undefined"></i>
  前端基础
</a></div><div class="nav-item"><a href="/vivien-blog/Vue/Vue3学习笔记/Vue3与Vue2对比/" class="nav-link"><i class="undefined"></i>
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      微前端
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端基础知识/" class="nav-link"><i class="undefined"></i>
  微前端基础知识
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/微前端解决方案/" class="nav-link"><i class="undefined"></i>
  微前端解决方案
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/MicroFrontends/使用MicroApp重构旧项目/" class="nav-link"><i class="undefined"></i>
  使用MicroApp重构旧项目
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      前端工程化
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/代码规范/概述/" class="nav-link"><i class="undefined"></i>
  代码规范
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/webpack/webpack执行流程/" class="nav-link"><i class="undefined"></i>
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/CICD/半自动化部署/" class="nav-link"><i class="undefined"></i>
  CICD
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/devops/渲染架构/前端渲染模式/" class="nav-link"><i class="undefined"></i>
  架构&amp;方案
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      书籍
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/books/深入浅出webpack/为什么要使用webpack/" class="nav-link"><i class="undefined"></i>
  深入浅出webpack
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/ES6入门教程/ES6与JavaScript/" class="nav-link"><i class="undefined"></i>
  ES6入门教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/TypeScript教程/简介和基本用法/" class="nav-link"><i class="undefined"></i>
  TypeScript教程
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术/" class="nav-link"><i class="undefined"></i>
  Vue.js设计与实现
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      项目实践
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vivien-blog/project/权限控制/权限控制基础知识/" class="nav-link"><i class="undefined"></i>
  权限控制
</a></li><li class="dropdown-item"><!----> <a href="/vivien-blog/project/项目搭建/搭建一个组件库/" class="nav-link"><i class="undefined"></i>
  项目搭建
</a></li></ul></div></div><div class="nav-item"><a href="/vivien-blog/React/React基础知识/" class="nav-link"><i class="undefined"></i>
  React
</a></div><div class="nav-item"><a href="/vivien-blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/vivien-blog/messageBoard/messageBoard.html" class="nav-link"><i class="iconfont reco-message"></i>
  留言板
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      contact Vivien
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/yoguoer" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.csdn.net/Vivien_CC" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  CSDN
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入浅出webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6入门教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript教程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue.js设计与实现</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vivien-blog/books/Vue.js设计与实现/1.权衡的艺术.html" class="sidebar-link">1.权衡的艺术</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/2.框架设计的核心要素.html" class="sidebar-link">2.框架设计的核心要素</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/3.Vue.js3的设计思路.html" class="sidebar-link">3.Vue.js3的设计思路</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/4.响应系统的作用与实现.html" class="sidebar-link">4.响应系统的作用与实现</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/5.非原始值的响应式方案.html" class="sidebar-link">5.非原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/6.原始值的响应式方案.html" class="sidebar-link">6.原始值的响应式方案</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/7.渲染器的设计.html" class="sidebar-link">7.渲染器的设计</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="sidebar-link">8.挂载与更新</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/9.简单的Diff算法.html" class="active sidebar-link">9.简单的Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html" class="sidebar-link">10.双端Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/11.快速Diff算法.html" class="sidebar-link">11.快速Diff算法</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/12.组件的实现原理.html" class="sidebar-link">12.组件的实现原理</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/13.异步组件和函数式组件.html" class="sidebar-link">13.异步组件和函数式组件</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/14.内建组件和模块.html" class="sidebar-link">14.内建组件和模块</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/15.编译器核心技术概览.html" class="sidebar-link">15.编译器核心技术概览</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/16.解析器.html" class="sidebar-link">16.解析器</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/17.编译优化.html" class="sidebar-link">17.编译优化</a></li><li><a href="/vivien-blog/books/Vue.js设计与实现/18.同构渲染.html" class="sidebar-link">18.同构渲染</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-15719524 data-v-222e0b9d><h3 class="title" data-v-15719524>9.简单的Diff算法</h3> <!----> <label id="box" class="inputBox" data-v-15719524><input type="password" value="" data-v-15719524> <span data-v-15719524>Konck! Knock!</span> <button data-v-15719524>OK</button></label> <div class="footer" data-v-15719524><span data-v-15719524><i class="iconfont reco-theme" data-v-15719524></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-15719524>vuePress-theme-reco</a></span> <span data-v-15719524><i class="iconfont reco-copyright" data-v-15719524></i> <a data-v-15719524><!---->
          
        <!---->
        2025
      </a></span></div></div> <div data-v-222e0b9d><div data-v-222e0b9d><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">9.简单的Diff算法</h1> <div data-v-f31d237c><i class="iconfont reco-account" data-v-f31d237c><span data-v-f31d237c>vivien</span></i> <i class="iconfont reco-date" data-v-f31d237c><span data-v-f31d237c>2024/9/9</span></i> <i class="iconfont reco-eye" data-v-f31d237c><span id="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f31d237c><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f31d237c><span class="tag-item" data-v-f31d237c>Vue</span></i></div></div> <div class="theme-reco-content content__default"><blockquote><p>从暴力卸载再挂载，再到稍微优化（patch公共部分，剩余部分根据数组长短情况执行挂载或卸载），最后通过 diff 算法改进，一步步变得更好。</p></blockquote> <p>​	操作 DOM 的性能开销通常比较大，而渲染器的核心 Diff 算法就是为了解决这个问题而诞生的。</p> <p>​	当新旧 vnode 的子节点都是一组节点时，为了以最小的性能开销完成更新操作，需要比较两组子节点，用于比较的算法就叫作 Diff 算法。</p> <h2 id="减少-dom-操作的性能开销"><a href="#减少-dom-操作的性能开销" class="header-anchor">#</a> 减少 DOM 操作的性能开销</h2> <div class="custom-block tip"><p class="title"></p><p>直接使用 patch 函数去处理对应位置的新旧子节点，当它们类型一样时无需卸载重新挂载，还处理了新旧子节点长度不一样的情况。但这种思路处理不了不同类型子节点移动时的复用。</p></div><p>​	核心 Diff 只关心新旧虚拟节点都存在一组子节点的情况。在前面的学习中，我们针对两组子节点的更新，采用了一种<strong>简单直接</strong>的手段，即卸载全部旧子节点，再挂载全部新子节点。这么做的确可以完成更新，但由于没有复用任何 DOM 元素，所以会产生极大的性能开销。</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// 旧 vnode</span>
 <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'3'</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 新 vnode</span>
 <span class="token keyword">const</span> newVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'4'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'5'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'6'</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote><p>按照之前的做法，当更新子节点时，我们需要执行 6 次 DOM 操作：</p> <ul><li>卸载所有旧子节点，需要 3 次 DOM 删除操作；</li> <li>挂载所有新子节点，需要 3 次 DOM 添加操作。</li></ul> <p>但是，通过观察上面新旧 vnode 的子节点，可以发现：</p> <ul><li>更新前后的所有子节点都是 p 标签，即标签元素不变；</li> <li>只有 p 标签的子节点（文本节点）会发生变化。</li></ul></blockquote> <p>​	最理想的更新方式是，直接更新这个 p 标签的文本节点的内容。这样，一共只需要 3 次 DOM 操作就可以完成全部节点的更新。相比原来需要执行 6 次 DOM 操作才能完成更新的方式，其性能提升了一倍。</p> <p>​	按照这个思路，我们可以<strong>重新实现</strong>两组子节点的更新逻辑：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 重新实现两组子节点的更新方式</span>
     <span class="token comment">// 新旧 children</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token comment">// 遍历旧的 children</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 调用 patch 函数逐个更新子节点</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><blockquote><p>oldChildren 和 newChildren 分别是旧的一组子节点和新的一组子节点。我们遍历前者，并将两者中对应位置的节点分别传递给 patch 函数进行更新。patch 函数在执行更新时，发现新旧子节点只有文本内容不同，因此只会更新其文本节点的内容。这样，我们就成功地将 6 次 DOM 操作减少为 3 次。</p></blockquote> <p>​	整个更新过程的示意图如下：</p> <p><img src="/vivien-blog/assets/img/image-20240908164912970.122f7b74.png" alt="image-20240908164912970"></p> <p>​	这种做法虽然能够减少 DOM 操作次数，但通过遍历旧的一组子节点，并假设新的一组子节点的数量与之相同，只有在这种情况下，这段代码才能正确地工作。但是，新旧两组子节点的数量未必相同。</p> <p>​	当新的一组子节点的数量少于旧的一组子节点的数量时，意味着有些节点在更新后应该被卸载：</p> <p><img src="/vivien-blog/assets/img/image-20240908165138168.12a3a697.png" alt="image-20240908165138168"></p> <p>类似地，新的一组子节点的数量也可能比旧的一组子节点的数量多，意味着我们应该挂载新增节点：</p> <p><img src="/vivien-blog/assets/img/image-20240908165310831.9b37ae70.png" alt="image-20240908165310831"></p> <p>​	通过上面的分析我们意识到，在进行新旧两组子节点的更新时，不应该总是遍历旧的一组子节点或遍历新的一组子节点，而是应该<strong>遍历其中长度较短的那一组</strong>。这样，我们才能够尽可能少地调用 patch 函数进行更新。接着，再对比新旧两组子节点的长度，如果<strong>新的一组子节点更长</strong>，则说明有新子节点<strong>需要挂载</strong>，<strong>否则</strong>说明有旧子节点<strong>需要卸载</strong>。这样，无论新旧两组子节点的数量关系如何，渲染器都能够正确地挂载或卸载它们，最终实现如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token comment">// 旧的一组子节点的长度</span>
     <span class="token keyword">const</span> oldLen <span class="token operator">=</span> oldChildren<span class="token punctuation">.</span>length
     <span class="token comment">// 新的一组子节点的长度</span>
     <span class="token keyword">const</span> newLen <span class="token operator">=</span> newChildren<span class="token punctuation">.</span>length
     <span class="token comment">// 两组子节点的公共长度，即两者中较短的那一组子节点的长度</span>
     <span class="token keyword">const</span> commonLength <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>oldLen<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span>
     <span class="token comment">// 遍历 commonLength 次</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> commonLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">patch</span><span class="token punctuation">(</span>oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 如果 newLen &gt; oldLen，说明有新子节点需要挂载</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>newLen <span class="token operator">&gt;</span> oldLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> commonLength<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldLen <span class="token operator">&gt;</span> newLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果 oldLen &gt; newLen，说明有旧子节点需要卸载</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> commonLength<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">unmount</span><span class="token punctuation">(</span>oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><blockquote><p>这种做法比暴力卸载再重新挂载性能要好一点。具体处理时，不考虑节点的移动，直接先在数量少的节点组上循环进行 patch 操作。然后判断新节点是不是比旧节点多，如果多，就在多的那部分上（其实就是末尾部分，因为没考虑 diff 移动）执行挂载操作；反之对旧节点未尾部分执行卸载操作。</p></blockquote> <h2 id="dom-复用与-key-的作用"><a href="#dom-复用与-key-的作用" class="header-anchor">#</a> DOM 复用与 key 的作用</h2> <div class="custom-block tip"><p class="title"></p><p>复用 DOM 元素省去了删除和创建的过程，但是仍需要 patch 操作。</p> <p>patch 是在原有的节点上进行的，先通过 patch 更新节点内容，使得新旧节点内容保持一致，再通过移动节点位置完成更新操作。</p></div><p>​	前面，我们通过减少 DOM 操作的次数，提升了更新性能。但这种方式仍然存在可优化的空间。举个例子，假设新旧两组子节点的内容如下：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// oldChildren</span>
 <span class="token punctuation">[</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'div'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'span'</span> <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
 <span class="token comment">// newChildren</span>
 <span class="token punctuation">[</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'span'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'div'</span> <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><blockquote><p>如果使用上一节介绍的算法来完成上述两组子节点的更新，则需要 6 次 DOM 操作：</p> <ul><li>调用 patch 函数在旧子节点 { type: 'p' } 与新子节点 { type: 'span' } 之间打补丁，由于两者是不同的标签，所以 patch 函数会卸载 { type: 'p' }，然后再挂载 {type: 'span' }，这需要执行 2 次 DOM 操作。</li> <li>与第 1 步类似，卸载旧子节点 { type: 'div' }，然后再挂载新子节点 { type: 'p'}，这也需要执行 2 次 DOM 操作。</li> <li>与第 1 步类似，卸载旧子节点 { type: 'span' }，然后再挂载新子节点 { type:'div' }，同样需要执行 2 次 DOM 操作。</li></ul> <p>但是，观察新旧两组子节点，可以发现：二者只是顺序不同。</p></blockquote> <p>​	最优的处理方式是，通过 DOM 的移动来完成子节点的更新，这要比不断地执行子节点的卸载和挂载性能更好。</p> <p>​	想要通过 DOM 的移动来完成更新，必须要保证一个前提：新旧两组子节点中<strong>的确存在可复用的节点</strong>。那么该如何确定新的子节点是否出现在旧的一组子节点呢？</p> <blockquote><p>一种答案是，通过 <code>vnode.type</code> 来判断，只要 <code>vnode.type</code> 的值相同，我们就认为两者是相同的节点。但这种方式并不可靠，例如：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// oldChildren</span>
<span class="token punctuation">[</span>
  <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'3'</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

<span class="token comment">// newChildren</span>
<span class="token punctuation">[</span>
  <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'3'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span> <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>​	这两组子节点同样可以通过移动 DOM 的方式来完成更新。但所有节点的 <code>vnode.type</code> 属性值都相同，这导致无法确定新旧两组子节点中节点的对应关系，也就无法得知应该进行怎样的 DOM 移动才能完成更新。</p></blockquote> <p>​	因此，我们需要引入额外的 <strong>key</strong> 来作为 vnode 的标识，根据 key 来判断哪些 dom 子节点能够被复用，这样可以通过移动 dom 操作来代替增删 dom 完成子节点的更新，提高性能。</p> <p>​	key 属性就像虚拟节点的“身份证”号，<strong>只要两个虚拟节点的 type 属性值和 key 属性值都相同，那么我们就认为它们是相同的，即可以进行 DOM 的复用</strong>：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// oldChildren</span>
 <span class="token punctuation">[</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'3'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
 <span class="token comment">// newChildren</span>
 <span class="token punctuation">[</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'3'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>​	有 key 和 无 key 时新旧两组子节点的映射情况如下：</p> <p><img src="/vivien-blog/assets/img/image-20240908171026026.fed6dc55.png" alt="image-20240908171026026"></p> <p>​	可见，如果没有 key，我们无法知道新子节点与旧子节点间的映射关系，也就无法知道应该如何移动节点。有 key 的话情况则不同，我们根据子节点的 key 属性，能够明确知道新子节点在旧子节点中的位置，这样就可以进行相应的 DOM 移动操作了。</p> <blockquote><p>在 Diff 算法中，我们根据 key 标识来得知每一个节点的位置，进而明确 DOM 节点移动的位置，而不是单纯地销毁和创建节点，最终达到节点复用的效果，提升整体性能。</p></blockquote> <p>​	注意！DOM 可复用并不意味着不需要更新，如下面的两个虚拟节点所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> oldVNode <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'text 1'</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> newVNode <span class="token operator">=</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'text 2'</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>这两个虚拟节点<strong>拥有相同的 key 值和 vnode.type 属性值</strong>。这意味着，在更新时可以复用 DOM 元素，即只需要通过移动操作来完成更新。但<strong>仍需要对这两个虚拟节点进行打补丁操作</strong>，因为新的虚拟节点（newVNode）的文本子节点的内容已经改变了（由 'text 1' 变成 'text 2'）。</p></blockquote> <p>​	因此，在讨论如何移动 DOM 之前，我们需要先完成打补丁操作：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token comment">// 遍历新的 children</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
       <span class="token comment">// 遍历旧的 children</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
         <span class="token comment">// 如果找到了具有相同 key 值的两个节点，说明可以复用，但仍然需要调用 patch 函数更新</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
           <span class="token keyword">break</span> <span class="token comment">// 这里需要 break</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><blockquote><p>使用了两层 for 循环，外层循环用于遍历新的一组子节点，内层循环则遍历旧的一组子节点。在内层循环中，逐个对比新旧子节点的 key 值，试图在旧的子节点中找到可复用的节点。一旦找到，则调用 patch 函数进行打补丁。</p></blockquote> <p>​	经过这一步操作之后，我们能够保证所有可复用的节点本身都已经更新完毕了。以下面的新旧两组子节点为例：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">const</span> newVNode <span class="token operator">=</span> <span class="token punctuation">{</span>
   type<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
   children<span class="token operator">:</span> <span class="token punctuation">[</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'world'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span> children<span class="token operator">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// 首次挂载</span>
 renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// 1 秒钟后更新</span>
   renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>newVNode<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><blockquote><p>1、取新的一组子节点中的第一个子节点，即 key 值为 3 的节点。尝试在旧的一组子节点中寻找具有相同 key 值的节点。发现，旧的子节点 oldVNode[2] 的 key 值为 3，于是调用 patch 函数进行打补丁。在这一步操作完成之后，渲染器会把 key 值为 3 的虚拟节点所对应的真实 DOM 的文本内容由字符串 'hello' 更新为字符串 'world'。</p> <p>2、取新的一组子节点中的第二个子节点，即 key 值为 1 的节点。尝试在旧的一组子节点中寻找具有相同 key 值的节点。我们发现，旧的子节点 oldVNode[0] 的 key 值为 1，于是调用 patch 函数进行打补丁。由于 key 值等于1 的新旧子节点没有任何差异，所以什么都不会做。</p> <p>3、取新的一组子节点中的最后一个子节点，即 key 值为 2 的节点，最终结果与第二步相同。</p> <p>经过上述更新操作后，所有节点对应的真实 DOM 元素都更新完毕了。但真实 DOM 仍然保持旧的一组子节点的顺序，即 key 值为 3 的节点对应的真实 DOM仍然是最后一个子节点。</p> <p>由于在新的一组子节点中，key 值为 3 的节点已经变为 第一个子节点了，因此我们还需要通过移动节点来完成真实 DOM 顺序的更新。</p></blockquote> <h2 id="找到需要移动的元素"><a href="#找到需要移动的元素" class="header-anchor">#</a> 找到需要移动的元素</h2> <div class="custom-block tip"><p class="title"></p><p>判断索引是否非递增，非递增的元素要移动。简单来说，就是后一个的索引比前一个的要小就需要移动。</p> <p>要不要移动看索引是否出现降序，怎么移是参照新节点数组中前一个节点，把当前节点的 el 移动到前个节点的 el 的后面。</p></div><p>​	现在，我们已经能够通过 key 值找到可复用的节点了。接下来需要思考的是，如何判断一个节点<strong>是否需要</strong>移动，以及<strong>如何</strong>移动。对于第一个问题的答案是，<strong>当新旧两组子节点的节点顺序不变时，就不需要额外的移动操作</strong>。</p> <h3 id="新旧子节点顺序不变"><a href="#新旧子节点顺序不变" class="header-anchor">#</a> 新旧子节点顺序不变</h3> <p>​	当新旧子节点顺序不变时：</p> <p><img src="/vivien-blog/assets/img/image-20240908172759338.12d78116.png" alt="image-20240908172759338"></p> <blockquote><p>​	我们对新旧两组子节点采用上一节介绍的更新算法，看看当新旧两组子节点的顺序没有发生变化时，更新算法具有怎样的特点。</p> <p>1、取新的一组子节点中的 p-1，它的 key 为 1。尝试在旧的一组子节点中找到具有相同 key 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 0。</p> <p>2、取新的一组子节点中的 p-2，它的 key 为 2。尝试在旧的一组子节点中找到具有相同 key 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 1。</p> <p>3、取新的一组子节点中的 p-3，它的 key 为 3。尝试在旧的一组子节点中找到具有相同 key 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 2。</p> <p>​	在这个过程中，每一次寻找可复用的节点时，都会<strong>记录</strong>该可复用节点在旧的一组子节点中的<strong>位置索引</strong>。如果把这些位置<strong>索引值按照先后顺序排列</strong>，则可以得到一个序列：0、1、2。这是一个<strong>递增</strong>的序列，在这种情况下<strong>不需要</strong>移动任何节点。</p></blockquote> <h3 id="新旧子节点顺序改变"><a href="#新旧子节点顺序改变" class="header-anchor">#</a> 新旧子节点顺序改变</h3> <p>​	我们再来看看一个新旧子节点顺序改变的例子：</p> <p><img src="/vivien-blog/assets/img/image-20240909083913726.49c0e1db.png" alt="image-20240909083913726"></p> <blockquote><p>​	我们再次执行更新算法，看看这一次会有什么不同。</p> <p>1、取新的一组子节点中的 p-3，它的 key 为 3。尝试在旧的一组子节点中找到具有相同 key 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 2。</p> <p>2、取新的一组子节点中的 p-1，它的 key 为 1。尝试在旧的一组子节点中找到具有相同 key 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 0。</p> <ul><li>到了这一步我们发现，索引值递增的顺序被打破了。节点 p-1 在旧 children 中的索引是 0，它小于节点 p-3 在旧 children 中的索引 2。这说明节点 p-1 在旧 children中排在节点 p-3 前面，但在新的 children 中，它排在节点 p-3 后面。因此，我们能够得出一个结论：节点 p-1 对应的真实 DOM 需要移动。</li></ul> <p>3、取新的一组子节点中的 p-2，它的 key 为 2。尝试在旧的一组子节点中找到具有相同 key 值的可复用节点，发现能够找到，并且该节点在旧的一组子节点中的索引为 1。</p> <ul><li>到了这一步我们发现，节点 p-2 在旧 children 中的索引 1 要小于节点 p-3 在旧children 中的索引 2。这说明，节点 p-2 在旧 children 中排在节点 p-3 前面，但在新的 children 中，它排在节点 p-3 后面。因此，节点 p-2 对应的真实 DOM 也需要移动。</li></ul></blockquote> <p>​	以上就是 Diff 算法在执行更新的过程中，判断节点是否需要移动的方式。在上面的例子中，我们得出了节点 p-1 和节点 p-2 需要移动的结论。这是因为它们在旧children 中的索引要小于节点 p-3 在旧 children 中的索引。如果我们按照先后顺序记录在寻找节点过程中所遇到的位置索引，将会得到序列：2、0、1。可以发现，这个序列不具有递增的趋势。</p> <p>​	其实我们可以将节点 p-3 在旧 children 中的索引定义为：在旧 children 中寻找具有相同 key 值节点的过程中，遇到的<strong>最大索引值</strong>。<strong>如果在后续寻找的过程中，存在索引值比当前遇到的最大索引值还要小的节点，则意味着该节点需要移动</strong>。</p> <p>​	我们可以用 lastIndex 变量存储整个寻找过程中遇到的最大索引值：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token comment">// 用来存储寻找过程中遇到的最大索引值</span>
     <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">// 如果当前找到的节点在旧 children 中的索引小于最大索引值 lastIndex，</span>
             <span class="token comment">// 说明该节点对应的真实 DOM 需要移动</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
             <span class="token comment">// 如果当前找到的节点在旧 children 中的索引不小于最大索引值，</span>
             <span class="token comment">// 则更新 lastIndex 的值</span>
             lastIndex <span class="token operator">=</span> j
           <span class="token punctuation">}</span>
           <span class="token keyword">break</span> <span class="token comment">// 这里需要 break</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>如果新旧节点的 key 值相同，说明我们在旧 children 中找到了可复用 DOM 的节点。</p> <p>此时我们用该节点在旧 children 中的索引 j 与 lastIndex进行比较，如果 j 小于 lastIndex，说明当前 oldVNode 对应的真实 DOM 需要移动，否则说明不需要移动。</p> <p>但此时应该将变量 j 的值赋给变量 lastIndex，以保证寻找节点的过程中，变量 lastIndex 始终存储着当前遇到的最大索引值。</p> <blockquote><p>lastlndex 存储的是旧索引组成的递增序列中的最大值，如果后续出现打破递增序列的索引（即索引小于lastlndex），则意味这这个索引对应的节点需要往后移动。</p> <p>简单理解就是原来在旧 children 中，这个节点索引小于 lastlndex ，说明其原来是排在 lastlndex 对应的节点前面的，但是现在是排在后面（按顺序遍历），所以应该要把它往后移动。</p></blockquote> <h2 id="如何移动元素"><a href="#如何移动元素" class="header-anchor">#</a> 如何移动元素</h2> <p>​	移动节点：指的是移动一个虚拟节点所对应的<strong>真实 DOM 节点</strong>，并不是移动虚拟节点本身。既然移动的是真实 DOM 节点，那么就需要取得对它的引用才行。</p> <p>​	我们知道，当一个虚拟节点被挂载后，其对应的真实 DOM 节点会<strong>存储在它的 vnode.el 属性中</strong>：</p> <p><img src="/vivien-blog/assets/img/image-20240909090917095.26f6f81b.png" alt="image-20240909090917095"></p> <blockquote><p>因此，在代码中，我们可以通过旧子节点的 vnode.el 属性取得它对应的真实 DOM 节点。</p></blockquote> <p>​	当更新操作发生时，渲染器会调用 patchElement 函数在新旧虚拟节点之间进行打补丁。回顾一下 patchElement 函数的代码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchElement</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 新的 vnode 也引用了真实 DOM 元素</span>
   <span class="token keyword">const</span> el <span class="token operator">=</span> n2<span class="token punctuation">.</span>el <span class="token operator">=</span> n1<span class="token punctuation">.</span>el
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>可以看到，patchElement 函数首先将旧节点的 n1.el 属性赋值给新节点的 n2.el 属性。这个赋值语句的真正含义其实就是 DOM 元素的复用。</p></blockquote> <p>​	在复用了 DOM 元素之后，新节点也将持有对真实 DOM 的引用：</p> <p><img src="/vivien-blog/assets/img/image-20240909104016786.3a19519f.png" alt="image-20240909104016786"></p> <blockquote><p>可以看到，无论是新子节点还是旧子节点，都存在对真实 DOM 的引用，在此基础上，我们就可以进行 DOM 移动操作了。</p></blockquote> <div class="custom-block tip"><p class="title"></p><p>新的虚拟节点其实就是真实的新顺序，所以当出现索引降序需要移动节点时，只要参考新节点数组中前一个节点的 el 进行移动即可（移动到它后面，如果没有前一个节点，说明不要移动）。</p></div><p>​	为了阐述具体应该怎样移动 DOM 节点，我们仍然引用上一节的更新案例：</p> <p><img src="/vivien-blog/assets/img/image-20240909083913726.49c0e1db.png" alt="image-20240909083913726"></p> <blockquote><p>​	它的更新步骤如下：</p> <p>1、取新的一组子节点中的 p-3，它的 key 为 3，可复用节点在旧的一组子节点中的索引为 2。此时变量 lastIndex 的值为 0，索引 2 不小于 0，所以节点 p-3 对应的真实 DOM 不需要移动，但需要更新变量 lastIndex 的值为 2。</p> <p>2、取新的一组子节点中的 p-1，它的 key 为 1，可复用节点在旧的一组子节点中的索引为 0。此时变量 lastIndex 的值为 2，索引 0 小于 2，所以节点 p-1 对应的真实 DOM 需要移动。</p> <ul><li><p>到了这一步，我们发现，节点 p-1 对应的真实 DOM 需要移动，但应该移动到哪里呢？我们知道，新 children 的顺序其实就是更新后真实 DOM 节点应有的顺序。所以节点 p-1 在新 children 中的位置就代表了真实 DOM 更新后的位置。由于<strong>节点 p-1在新 children 中排在节点 p-3 后面</strong>，所以我们应该把节点 p-1 所对应的真实 DOM移动到节点 p-3 所对应的真实 DOM 后面。移动后的结果如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909104641825.693e956e.png" alt="2移动后的结果"></p> <p>可以看到，这样操作之后，此时真实 DOM 的顺序为 p-2、p-3、p-1。</p></li></ul> <p>3、取新的一组子节点中的 p-2，它的 key 为 2，可复用节点在旧的一组子节点中的索引为 1。此时变量 lastIndex 的值为 2，索引 1 小于 2，所以节点 p-2 对应的真实 DOM 需要移动。</p> <ul><li><p>第三步与第二步类似，节点 p-2 对应的真实 DOM 也需要移动。同样，由于<strong>节点 p-2在新 children 中排在节点 p-1 后面</strong>，所以我们应该把节点 p-2 对应的真实 DOM 移动到节点 p-1 对应的真实 DOM 后面。移动后的结果如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909104829175.e4611f7d.png" alt="3移动后的结果"></p> <p>经过这一步移动操作之后，我们发现，真实 DOM 的顺序与新的一组子节点的顺序相同了：p-3、p-1、p-2。至此，更新操作完成。</p></li></ul></blockquote> <p>​	接下来，我们着手实现代码。其实并不复杂，如下面 patchChildren 函数的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
       <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">// 代码运行到这里，说明 newVNode 对应的真实 DOM 需要移动</span>
             <span class="token comment">// 先获取 newVNode 的前一个 vnode，即 prevVNode</span>
             <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
             <span class="token comment">// 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">// 由于我们要将 newVNode 对应的真实 DOM 移动到 prevVNode 所对应真实 DOM 后面，</span>
               <span class="token comment">// 所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点</span>
               <span class="token keyword">const</span> anchor <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
               <span class="token comment">// 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面，</span>
               <span class="token comment">// 也就是 prevVNode 对应真实 DOM 的后面</span>
               <span class="token function">insert</span><span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
             <span class="token punctuation">}</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
             lastIndex <span class="token operator">=</span> j
           <span class="token punctuation">}</span>
           <span class="token keyword">break</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><blockquote><p>如果条件 j &lt; lastIndex 成立，则说明当前 newVNode 所对应的真实 DOM 需要移动。</p> <p>思路：我需要移动、则需要知道我的上一个是谁，也就是 newChildren[i - 1]，然后插入。</p></blockquote> <p>​	根据前文的分析可知，我们需要获取当前 newVNode 节点的前一个虚拟节点，即 newChildren[i - 1]，然后使用 insert 函数完成节点的移动，其中 insert 函数依赖浏览器原生的 insertBefore 函数：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
   <span class="token function">insert</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> anchor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// insertBefore 需要锚点元素 anchor</span>
     parent<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 省略部分代码</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="添加新元素"><a href="#添加新元素" class="header-anchor">#</a> 添加新元素</h2> <p>​	如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909110320055.e974ec44.png" alt="添加新元素"></p> <p>​	在新的一组子节点中，多出来一个节点 p-4，它的 key 值为 4，该节点在旧的一组子节点不存在，因此应该将其视为新增节点。对于新增节点，在更新时我们应该正确地将它挂载，这主要分为两步：</p> <ul><li>想办法找到新增节点；</li> <li>将新增节点挂载到正确位置。</li></ul> <p>​	为了搞清楚如何找到新增节点这个问题，我们需要根据上图中给出的例子，模拟执行简单 Diff 算法的逻辑。在此之前，我们需要弄清楚新旧两组子节点与真实 DOM 元素的当前状态：</p> <p><img src="/vivien-blog/assets/img/image-20240909110722082.e3663a87.png" alt="两组子节点与真实DOM元素的当前状态"></p> <p>​	接着，我们开始模拟执行简单 Diff 算法的更新逻辑。</p> <blockquote><p>1、取新的一组子节点中的 p-3，它的 key 值为 3，可复用节点在旧的一组子节点中的索引值为 2。此时，变量 lastIndex 的值为 0，索引值 2 不小于 lastIndex 的值 0，所以节点 p-3 对应的真实 DOM 不需要移动，但是需要将变量 lastIndex 的值更新为 2。</p> <p>2、取新的一组子节点中的 p-1，它的 key 值为 1，可复用节点在旧的一组子节点中的索引值为 0。此时变量 lastIndex 的值为 2，索引值 0 小于 lastIndex 的值 2，所以节点 p-1 对应的真实 DOM 需要移动，并且应该移动到节点 p-3 对应的真实 DOM 后面。经过这一步的移动操作后，真实 DOM 的状态如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909112010904.f19d9b9f.png" alt="2真实DOM的状态"></p> <p><code>此时真实 DOM 的顺序为 p-2、p-3、p-1。</code></p> <p>3、取新的一组子节点中的 p-4，它的 key 值为 4，由于在旧的一组子节点中，没有 key 值为 4 的节点，因此渲染器会把节点 p-4 看作新增节点并挂载它。那么，应该将它挂载到哪里呢？为了搞清楚这个问题，我们需要观察节点 p-4 在新的一组子节点中的位置。由于节点 p-4 出现在节点 p-1 后面，所以我们应该把节点 p-4 挂载到节点 p-1 所对应的真实 DOM 后面。在经过这一步挂载操作之后，真实 DOM 的状态如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909112240588.cda3db11.png" alt="3真实DOM的状态"></p> <p><code>此时真实 DOM 的顺序是：p-2、p-3、p-1、p-4，其中 p-4 是刚刚挂载的。</code></p> <p>4、取新的一组子节点中的p-2，它的 key 值为 2，可复用节点在旧的一组子节点中的索引值为1。此时变量 lastIndex 的值为 2，索引值 1 小于 lastIndex 的值 2，所以节点 p-2 对应的真实 DOM 需要移动，并且应该移动到节点 p-4 对应的真实 DOM 后面。经过这一步移动操作后，真实 DOM 的状态如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909112414503.897bba98.png" alt="4真实DOM的状态"></p> <p><code>此时真实 DOM 的顺序是：p-3、p-1、p-4、p-2。</code></p> <p>至此，真实 DOM 的顺序已经与新的一组子节点的顺序相同了，更新完成。</p></blockquote> <p>​	接下来，我们着手实现代码，如下面 patchChildren 函数的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> newVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
       <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
       <span class="token comment">// 在第一层循环中定义变量 find，代表是否在旧的一组子节点中找到可复用的节点，</span>
       <span class="token comment">// 初始值为 false，代表没找到</span>
       <span class="token keyword">let</span> find <span class="token operator">=</span> <span class="token boolean">false</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldVNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 一旦找到可复用的节点，则将变量 find 的值设为 true</span>
           find <span class="token operator">=</span> <span class="token boolean">true</span>
           <span class="token function">patch</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">)</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> lastIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">const</span> anchor <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
               <span class="token function">insert</span><span class="token punctuation">(</span>newVNode<span class="token punctuation">.</span>el<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
             <span class="token punctuation">}</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
             lastIndex <span class="token operator">=</span> j
           <span class="token punctuation">}</span>
           <span class="token keyword">break</span>
         <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// 如果代码运行到这里，find 仍然为 false，</span>
       <span class="token comment">// 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点</span>
       <span class="token comment">// 也就是说，当前 newVNode 是新增节点，需要挂载</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 为了将节点挂载到正确位置，我们需要先获取锚点元素</span>
         <span class="token comment">// 首先获取当前 newVNode 的前一个 vnode 节点</span>
         <span class="token keyword">const</span> prevVNode <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
         <span class="token keyword">let</span> anchor <span class="token operator">=</span> <span class="token keyword">null</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>prevVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素</span>
           anchor <span class="token operator">=</span> prevVNode<span class="token punctuation">.</span>el<span class="token punctuation">.</span>nextSibling
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token comment">// 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点</span>
           <span class="token comment">// 这时我们使用容器元素的 firstChild 作为锚点</span>
           anchor <span class="token operator">=</span> container<span class="token punctuation">.</span>firstChild
         <span class="token punctuation">}</span>
         <span class="token comment">// 挂载 newVNode</span>
         <span class="token function">patch</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> newVNode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><blockquote><p>找了一轮没找到相同的 key，说明是需要新插入的节点，这个时候看自己的位置，如果不是第一个位置就参照前序节点 el 的 nextsibling；如果是第一个位置，就用 container.firstChild 找到参照位置。 最后插入的操作都是 insert（ insert 封装了/依赖于浏览器原生的 insertBefore 函数）。</p></blockquote> <ul><li>首先，我们在外层循环中定义了名为 find 的变量，它代表渲染器能否在旧的一组子节点中找到可复用的节点。变量 find 的初始值为 false，一旦寻找到可复用的节点，则将变量 find 的值设置为 true。如果内层循环结束后，变量 find 的值仍然为 false，则说明当前 newVNode 是一个全新的节点，需要挂载它。</li> <li>为了将节点挂载到正确位置，我们需要先获取锚点元素：找到 newVNode 的前一个虚拟节点，即 prevVNode，如果存在，则使用它对应的真实 DOM 的下一个兄弟节点作为锚点元素；如果不存在，则说明即将挂载的 newVNode 节点是容器元素的第一个子节点，此时应该使用容器元素的 container.firstChild 作为锚点元素。</li> <li>最后，将锚点元素anchor 作为 patch 函数的第四个参数，调用 patch 函数完成节点的挂载。但由于目前实现的 patch 函数还不支持传递第四个参数，所以我们需要调整 patch 函数的代码。</li></ul> <p>​	但由于目前实现的 patch 函数还不支持传递第四个参数，所以我们需要调整 patch 函数的代码：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token comment">// patch 函数需要接收第四个参数，即锚点元素</span>
 <span class="token keyword">function</span> <span class="token function">patch</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 挂载时将锚点元素作为第三个参数传递给 mountElement 函数</span>
       <span class="token function">mountElement</span><span class="token punctuation">(</span>n2<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token function">patchElement</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment">// mountElement 函数需要增加第三个参数，即锚点元素</span>
 <span class="token keyword">function</span> <span class="token function">mountElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 省略部分代码</span>
   <span class="token comment">// 在插入节点时，将锚点元素透传给 insert 函数</span>
   <span class="token function">insert</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> container<span class="token punctuation">,</span> anchor<span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="移除不存在的元素"><a href="#移除不存在的元素" class="header-anchor">#</a> 移除不存在的元素</h2> <p>​	在更新子节点时，不仅会遇到新增元素，还会出现元素被删除的情况：</p> <p><img src="/vivien-blog/assets/img/image-20240909113232224.abacb1f1.png" alt="移除不存在的元素"></p> <blockquote><p>在新的一组子节点中，节点 p-2 已经不存在了，这说明该节点被删除了。渲染器应该能找到那些需要删除的节点并正确地将其删除。</p></blockquote> <p>​	如何找到需要删除的节点呢？以上图为例，我们来分析它的更新步骤。在模拟执行更新逻辑之前，我们需要清楚新旧两组子节点以及真实 DOM 节点的当前状态：</p> <p><img src="/vivien-blog/assets/img/image-20240909113627645.2a0cbfdf.png" alt="当前状态"></p> <p>接着，我们开始模拟执行更新的过程。</p> <blockquote><p>1、取新的一组子节点中的 p-3，它的 key 值为 3，可复用节点在旧的一组子节点中的索引值为 2。此时变量 lastIndex 的值为 0，索引 2 不小于 lastIndex 的值 0，所以节点 p-3对应的真实 DOM 不需要移动，但需要更新变量 lastIndex 的值为 2。</p> <p>2、取新的一组子节点中的 p-1，它的 key 值为 1，可复用节点在旧的一组子节点中的索引值为 0。此时变量 lastIndex 的值为 2，索引 0 小于 lastIndex 的值 2，所以节点 p-1 对应的真实 DOM 需要移动，并且应该移动到节点 p-3 对应的真实 DOM 后面。经过这一步的移动操作后，真实 DOM 的状态如图所示：</p> <p><img src="/vivien-blog/assets/img/image-20240909141222208.513883e1.png" alt="真实DOM的状态"></p> <p>至此，更新结束。</p></blockquote> <p>​	我们发现，节点 p-2 对应的真实 DOM 仍然存在，所以需要增加额外的逻辑来删除遗留节点。思路很简单，当基本的更新结束时，我们需要遍历旧的一组子节点，然后去新的一组子节点中寻找具有相同 key 值的节点。如果找不到，则说明应该删除该节点，如下面 patchChildren 函数的代码所示：</p> <div class="language-typescript line-numbers-mode"><pre class="language-typescript"><code> <span class="token keyword">function</span> <span class="token function">patchChildren</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n2<span class="token punctuation">.</span>children <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>n2<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">const</span> oldChildren <span class="token operator">=</span> n1<span class="token punctuation">.</span>children
     <span class="token keyword">const</span> newChildren <span class="token operator">=</span> n2<span class="token punctuation">.</span>children
     <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> <span class="token number">0</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 省略部分代码</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 上一步的更新操作完成后</span>
     <span class="token comment">// 遍历旧的一组子节点</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">const</span> oldVNode <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
       <span class="token comment">// 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点</span>
       <span class="token keyword">const</span> has <span class="token operator">=</span> newChildren<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>
         vnode <span class="token operator">=&gt;</span> vnode<span class="token punctuation">.</span>key <span class="token operator">===</span> oldVNode<span class="token punctuation">.</span>key
       <span class="token punctuation">)</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>has<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 如果没有找到具有相同 key 值的节点，则说明需要删除该节点</span>
         <span class="token comment">// 调用 unmount 函数将其卸载</span>
         <span class="token function">unmount</span><span class="token punctuation">(</span>oldVNode<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// 省略部分代码</span>
   <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><blockquote><p>在上一步的更新操作完成之后，我们还需要遍历旧的一组子节点，目的是检查旧子节点在新的一组子节点中是否仍然存在，如果已经不存在了，则调用 unmount 函数将其卸载。</p> <p>因为上一轮循环的外循环是以 newChildren 为目标循环的，不能照顾到旧节点中被删的部分。所以在结束后需要再用一个循环检查被删除的部分，执行 unmount 逻辑。</p></blockquote> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>Diff 算法用来计算两组子节点的差异，并试图最大程度地复用 DOM 元素。</li> <li>采用一种简单的方式来更新子节点，即卸载所有旧子节点，再挂载所有新子节点。然而这种更新方式无法对 DOM元素进行复用，需要大量的 DOM 操作才能完成更新，非常消耗性能。</li> <li>改进后的方案是，遍历新旧两组子节点中数量较少的那一组，并逐个调用 patch 函数进行打补丁，然后比较新旧两组子节点的数量，如果新的一组子节点数量更多，说明有新子节点需要挂载；否则说明在旧的一组子节点中，有节点需要卸载。</li> <li>虚拟节点中 key 属性的作用：它就像虚拟节点的“身份证号”。在更新时，渲染器通过 key 属性找到可复用的节点，然后尽可能地通过 DOM 移动操作来完成更新，避免过多地对 DOM 元素进行销毁和重建。</li> <li>简单 Diff 算法的核心逻辑是，拿新的一组子节点中的节点去旧的一组子节点中寻找可复用的节点。如果找到了，则记录该节点的位置索引。我们把这个位置索引称为最大索引。在整个更新过程中，如果一个节点的索引值小于最大索引，则说明该节点对应的真实 DOM 元素需要移动。</li></ul> <blockquote><p><strong>新增</strong>：新节点组从上往下遍历，嵌套遍历旧节点，通过 key 在找到对应的旧节点，找不到则新增节点。</p> <p><strong>移动</strong>：找到旧节点后用旧索引比对 max 旧索引，如果比 max 还要大，则覆盖；反之则需要移动（因为是上往下遍历，所以当前的节点的新索引肯定比前面节点的新索引大，而此刻旧索引对比结果却相反，说明当前节点需要移动），则移动节点（移动元素其实只有一个原则，移动到前一个节点的后面，如果自己是第一个则不动）</p> <p><strong>删除</strong>：遍历旧节点组，嵌套遍历新节点组，通过 key 寻找对应新节点，找不到则删除。</p></blockquote></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2024/9/10 02:14:23</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/vivien-blog/books/Vue.js设计与实现/8.挂载与更新.html" class="prev">
          8.挂载与更新
        </a></span> <span class="next"><a href="/vivien-blog/books/Vue.js设计与实现/10.双端Diff算法.html">
          10.双端Diff算法
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-9f22dc18 data-v-222e0b9d><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#减少-dom-操作的性能开销" class="sidebar-link reco-side-减少-dom-操作的性能开销" data-v-9f22dc18>减少 DOM 操作的性能开销</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#dom-复用与-key-的作用" class="sidebar-link reco-side-dom-复用与-key-的作用" data-v-9f22dc18>DOM 复用与 key 的作用</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#找到需要移动的元素" class="sidebar-link reco-side-找到需要移动的元素" data-v-9f22dc18>找到需要移动的元素</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#新旧子节点顺序不变" class="sidebar-link reco-side-新旧子节点顺序不变" data-v-9f22dc18>新旧子节点顺序不变</a></li><li class="level-3" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#新旧子节点顺序改变" class="sidebar-link reco-side-新旧子节点顺序改变" data-v-9f22dc18>新旧子节点顺序改变</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#如何移动元素" class="sidebar-link reco-side-如何移动元素" data-v-9f22dc18>如何移动元素</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#添加新元素" class="sidebar-link reco-side-添加新元素" data-v-9f22dc18>添加新元素</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#移除不存在的元素" class="sidebar-link reco-side-移除不存在的元素" data-v-9f22dc18>移除不存在的元素</a></li><li class="level-2" data-v-9f22dc18><a href="/vivien-blog/books/Vue.js%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/9.%E7%AE%80%E5%8D%95%E7%9A%84Diff%E7%AE%97%E6%B3%95.html#总结" class="sidebar-link reco-side-总结" data-v-9f22dc18>总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/vivien-blog/assets/js/app.1b7b4fd5.js" defer></script><script src="/vivien-blog/assets/js/7.210383a7.js" defer></script><script src="/vivien-blog/assets/js/2.00d63d32.js" defer></script><script src="/vivien-blog/assets/js/1.96251043.js" defer></script><script src="/vivien-blog/assets/js/21.06b93e75.js" defer></script>
  </body>
</html>
